---
title: 前端备战(四)
date: 2018-08-14 11:08:46
tags: 前端
keywords: 前端
categories: "备战系列"
---
### 前言
加油，为了更好的明天，前端备战系列四。
<!--more-->
### 知识点
**vue组件之间的通信**
```
   vue是单向数据通信
   父传子 props
   子传父 $on, $emit
   非父子，可以通过使用一个空的Vue实例作为中央事件总线
```
**vue双向数据绑定的原理**
```
   vue是基于object.defneProperty()属性拦截器实现的
```
**object.defneProperty()的缺点**
```
   我暂时也不知道啊
```
**vue的生命周期以及每个周期用来干什么的**
```
    beforeCreate 实例创建前,此时无法读取data、 methods
    created 实例创建后，这是已经有了data,属性和方法的运算，watch/event事件等，但是mount还未挂载,数据还未渲染。
    beforeMount 挂载开始前，相关的render调用
    mounted el的dom节点被vm.$el替换，实例数据在dom上渲染
    beforeUpdate 数据更新是调用，不进行dom重新渲染， 在数据更新前可以进行状态处理
    updated: 数据更新并且dom渲染，这时dom已经更新，每次数据更新都会执行updated
    beforeDestory 实例销毁前调用
    destroyed vue实例销毁后调用，vue所有的东西都会被解绑，所有的子实例也会销毁
    应用场景
    created 异步数据请求，初始化数据
    mounted 挂载元素内的dom节点获取
    nextTick 针对单一事件更新数据后立即操作dom
    updated 任何数据的更新，做同一的业务逻辑处理
    watch: 监听数据变化，做出相应的处理
```
**准确的判断js数据类型**
```
    Object.prototype.toString.call(obj)
```
**es6了解什么**
```
    1. 箭头操作符
    2. 类的支持class
    3. 对象字面量不用写function 什么的了
    4. 字符串模板``这个符号
    5. 解构
    6. 默认参数值
    7. let与const关键字
    8. for of值遍历
    9. 模块export和import
    10. Map和Set
    11. Promises异步处理
```
**call和apply的作用和区别**
```
    call和apply用来调用函数，并用指定对象（第一个参数）替换函数的 this 值.改变this的指向。
    call的参数是一个一个的，而apply是一整个数组。
```
**vuex包括什么？对action理解的怎么样**
```
    Vuex是各个组件的状态管理器，也成为前端数据库吧。
    state: 状态的数据结构
    actions: 从服务端获取数据，（异步）调用commit来改变状态
    mutations: 唯一能改变状态的地方
    getters: 组件获取状态器的数据，需通过这里。
    modules: 一个store可以拆分为多个，每个都有自己的state,actions等
    
    actions我一般用来获取服务器的数据，更新，因为mutations是同步的，不行，而actions是异步的。
```
**垃圾回收机制的理解**
```
    垃圾回收机制是一种自动释放变量的机制。以免变量一直占用内存。
    js的垃圾回收机制是，当js检测到一个变量之后不会再使用的时候，就会把它释放。
    js的垃圾回收的两种方式，标记清除和引用计数
    1. 标记清除
        这是js最常用的回收方式，当变量进入执行环境时，就标记为“进入环境”，
        进入执行环境的变量不能释放，因为他们可能随时用到，当变量离开环境的时候，
        则将其标记为“离开环境”，然后去掉环境中的变量和标记，然后垃圾收集器来搜集。
        例如进入函数，函数里面的标记就变为进入环境，当离开环境后，局部变量就会被回收。
    2. 引用计数
        不太常见的回收策略，跟踪每个值被引用的次数，当一个变量已经没有引用类型引用的时候，
        就会把他回收。
        例如a=3，现在a引用的是3，但当a=4的时候，这里的3仍在，并不是被替换。
        而是a引用到4了，此时3已经没有任何变量引用它，它就会被回收了！
```
**js深浅复制**
```
    浅拷贝：仅仅复制对象的引用，而不是对象本身
    深拷贝：把复制的对象所引用的全部对象都复制一遍
```
### 总结
第四期的内容就是这些啦，不要气馁。
