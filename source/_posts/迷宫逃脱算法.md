---
title: 迷宫逃脱算法
date: 2017-12-18 11:04:07
tags: C++
keywords: C,C++,递归回溯,算法
categories: "算法"
---
### 题目
第一行输入 迷宫x轴，y轴，门几秒开一次。输入S为你的起点，小数点.为可以通过的地方。 
D为门的位置，X是不能通过的位置。当输入 0 0 0时结束。
<!--more-->
### 示例输入
```
4 4 5
S . X .
. . X .
. . X D
. . . .
3 4 5
S . X .
. . X .
. . . D
0 0 0
```
### 示例输出
```
NO
YES
```
### 代码
```
#include <iostream>
#include <string.h> 
#include <stdlib.h> 
using namespace std;//命名空间  

char map[9][9]; 
int n,m,t,di,dj; 
bool escape; 
int dir[4][2]={{0,-1},{0,1},{1,0},{-1,0}}; 

void dfs(int si,int sj,int cnt) //起点以及行走的时间(可根据递归改变) 
{    int i,temp; 
   if(si>n||sj>m||si<=0||sj<=0) return; //不能走出地图之外 
   if(cnt==t&&si==di&&sj==dj)    escape=1;//如果起点的坐标和门的位置相同，并且此时行走的步数和门的开启时间吻合  就能逃脱 
   if(escape) return; //逃脱退出循环 
  
   temp=(t-cnt)-abs(si-di)-abs(sj-dj); //
   if(temp<0||temp&1) return;  
   for(i=0;i<4;i++){ 
      if(map[si+dir[i][0]][sj+dir[i][1]]!='X')
	  { 
         map[si+dir[i][0]][sj+dir[i][1]]='X'; 
         dfs(si+dir[i][0],sj+dir[i][1],cnt+1); 
         map[si+dir[i][0]][sj+dir[i][1]]='.'; //递归回溯 
      } 
   } 
   return; 
} 

int main() 
{ 
	int i,j,si,sj; 
	while(cin>>n>>m>>t)//行列时间 
	{ 
	  if(n==0&&m==0&&t==0) break; //输入000时退出 
	  int wall=0;//墙的个数 
	  for(i=1;i<=n;i++) 
         for(j=1;j<=m;j++) //输入地图 
		 { 
            cin>>map[i][j]; 
            if(map[i][j]=='S') { si=i; sj=j; } //起点位置  这里没有判断起点是否唯一 
            else if(map[i][j]=='D') { di=i; dj=j; } //门的坐标位置 
            else if(map[i][j]=='X') wall++; //墙的数量 
         } 
       if(n * m - wall <= t) //如果行列个数  比墙还少 有误！ 
	   {
		   cout<<"NO"<<endl;
		   continue;
	   }
	   escape=0; //逃脱标记 
       map[si][sj]='X'; //起点默认为X  因为起点走了 不可能在回来了！！而且必须从起点开始出发 相当于起点是必经点 
       dfs(si,sj,0); //递归判断 
       if(escape) cout<<"YES"<<endl; //如果标记为1说明逃脱了 
       else cout<<"NO"<<endl; 
   } 
   return 0; 
} 
```
### 总结
典型的迷宫问题，熟练此题，能够掌握递归回溯的搜索问题。