---
title: 前端备战(二)
date: 2018-08-13 10:00:12
tags: 前端
keywords: 前端
categories: "备战系列"
---
### 前言
加油，为了更好的明天，前端备战系列二。
<!--more-->
### 知识点
**Object和Function的关系**
```
    1. Object和Function都是构造函数,所有的构造函数都是Function的实例，所以Object是Function的实例。
    2. Function.prototype是Object的实例对象。
    3. 实例对象的原型(proto)会指向其构造函数的prototype属性，Object.proto === Function.prototype,
        Function.proto === Function.prototype, Funtion.prototype === Object.protoype
    4. 当访问一个属性值时，它会沿着原型链向上查找，直到找到或者到Object.prototypr.proto(null)为止。
```
**排序算法有哪些**
```
    排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，
    而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。
    主要是内部排序
    直接插入排序(稳定)：设置标兵，标兵是前n个元素中最大(小)的元素，后面的与之相比较，大(小)则交换。
    希尔排序(不稳定)：减少增量排序，按数组增量分组。例如增量为2[2,3,1,4]分为[2,1][3,4]分别排序，然后合并。
    简单选择排序(不稳定)：每一轮选择第n大的数字与第n个位置交换。(例如最大的数位置和第一个位置交换);
    堆排序(不稳定)：将数组排列成堆，每个元素都与堆顶元素比较，将堆顶元素沉入堆底，重复操作即可。
    冒泡排序(稳定)：相邻元素第一个比第二个元素大(小)就交换，每一对比较，一轮下来最大最小就会在最后。比完即可。
    快速排序(不稳定)：左指针右指针和一个基数，左右指针重合的时候两边分别比基数大和基数小，然后再循环以上步骤即可。
    归并排序(稳定)：分治法，数组对半拆分直到不可分，然后逐渐合并排序，即可。
    桶排序(稳定)：把数组分在各个子区间，然后各个子区间分别排序，最后合并排序，即可。
    基数排序(稳定)：桶排序的扩展，将整数按位数切割排序，不足补0。即可。
```
**position相关**
```
    position属性是指定元素在文档中的定位方式
    通过top,right,bottom,left来确定元素的位置
    定位类型有:static, relative, absolute, fixed ,sticky
        static: 元素默认定位,top,right,left,bottom,z-index属性无效
        relative: 仅仅视觉调整元素位置，而实际位置还在原位，会影响子元素的布局方式(absolute),table相关属性无效。
        absolute: 不为元素预留空间，相对于最近的非static的祖先元素定位，可以设置外边距不和其他static边距重合。
        fixed: 不为元素预留空间，通过屏幕视口(viewport)来指定元素位置,会创建新的层叠上下文,
               当元素的祖先为transform非none时，容器由该视口改为该祖先。
        sticky: 根据正常的static元素布局，相对于(BFC)和最近块元素祖先元素定位。当被粘性定位时，仍按照b未定位的位置定位。
```
**跨域相关**
```
    浏览器安全机制同源政策，协议，端口，域名都相同才称为同源，否则需要跨域。
    1. script标签请求数据,只能get请求，且无法访问服务器响应文本(单向请求)。
    2. jsonp通过script的开发策略得到其他网页的json数据，只能get，不知道是否失败，安全性无法保证。
    3. CORS跨域资源共享，通过HTTP请求头和修改后端服务器的响应头配置即可。
    4. 反向代理(例如nginx),原理：本地浏览器->本地服务器->异地服务器->本地浏览器
    5. WebSocket，浏览器与服务器的全双工协议，允许跨域通信。
    6. document.domain跨子域,前提是域名协议，端口都相同。只能跨子域。
    7. img跨域，img也能跨域，不过也是单向请求了，不能得到服务器响应的文本。
```
**jsonp的原理**
```
    1.有src属性的标签都能跨域(img,script,iframe)等
    2.所以利用script来实现跨域，因为script只能请求js相关文件，所以需将远程服务器的数据装入js中，供客户端调用。
    3.于是json被发现了，它可以简单的描述复杂数据，还被js原生支持。客户端也可以很轻易的处理这种数据。
    4.所以客户端像调用脚本一样的，来调用跨域服务器上的js格式文件(json)。
    5.这种方式逐渐成为了一种非正式的传输协议，称之为jsonp，主要的特点就是用户需要提交一个callback，然后服务器
       返回数据的时候就会通过这个callback包裹住，这样客户端就可以随心所欲的处理返回的数据。
```
**前端性能优化**
```
    1. 减少Http请求（图片绘制成一张，然后客户端拆分）
    2. 使用CDN
    3. 添加Expires头,缓存组件
    4. 压缩组件，gzip什么的
    5. 样式表放在头部(避免白屏)
    6. 脚本放在底部（避免阻塞）
    7. 使用外部js和css，因为浏览器可能会缓存它们
    8. 避免css表达式
    9. 精简js和css代码
    10. 减少iframe的个数
    11. 预加载，延迟加载的合理应用。
```
**首屏加载优化**
```
    1. 除了首屏的图片，其他的图片都采用懒加载。
    2. 其他的和上面前端优化差不多
    3. 其实我也听说过一种叫做服务端渲染的技术，SSR？
```
**ES6异步编程**
```
    1. 回调函数callback,容易产生回调地狱。
    2. Promise, 通过then方法加载回调函数，catch捕捉错误，但是then太多就会导致代码混乱。
    3. 协程，我没用过不知道，反正可以解决！
    4. Gennerator函数,yield, 可以暂停执行和恢复执行，所以能够解决异步。
```
### 总结
第二期的内容就是这些啦，继续加油。