---
title: 手写方法
date: 2018-09-18 18:17:24
tags: 前端
keywords: 前端
categories: "备战系列"
---
### 手写代码
整理我面试时手写的代码。
<!--more-->
### 手写promise
这个考的是真的多！小米要不是电话面，又要写一次。
```
    function Promise(callback){
        let self = this;
        self.status = 'PENDING';
        self.data = undefined;
        self.onResolvedCallback = [];
        self.onRejectedCallback = [];
        callback(resolve, reject);

        function resolve(value){
            if(self.status == 'PENDING'){
                self.status == 'FULFILLED';
                self.data = value;
                for(let i=0; i<self.onResolvedCallback.length; i++){
                    self.onResolvedCallback[i](value);
                }
            }
        }
        function reject(error){
            if(self.status == 'PENDING'){
                self.status = 'REJECTED';
                self.data = 'error';
                for(let i=0; i<self.onRejectedCallback.length; i++){
                    self.onRejectedCallback[i](error)
                }
            }
        }
    }

    // 一般不会写这个， 只会说说思路，毕竟还要判断3状态，代码挺多的。 
    Promise.prototype.then = function(onResolved, onRejected){
        let self = this;
        let promise;
        // 参数必须为函数 
        onResolved = typeof onResolved === 'function' ? onResolved: function(v){
            return v;
        }
        onRejected = typeof onRejected === 'function' ? onRejected: function(r){
            throw r;
        }

        if(self.status === 'resolved'){
            return promise = new Promise(function(resolve, reject){
                setTimeout(function (){
                    try{
                        let x = onResolved(self.data);
                        resolvePromise(promise, x, resolve, reject);
                    }catch(reason){
                        reject(reason);
                    }
                })
            })
        }

        //其他两个状态差不多
    }

    Promise.prototype.catch = function(onRejected){
        return this.then(null, onRejected);
    }

    // 百度一面，这里被难倒过。现在发现，挺简单的。。。。
    Promise.prototype.finally = function(callback){
        let self = this;
        return this.then(
            value => self.resolve(callback()).then(()=>value),
            error => self.resolve(callback()).then(()=> {throw error})
        );
    };
```
### 对象深拷贝
这个问题真的。问的频率高，写的频率更高！  
对于原型和循环引用还未能处理。
```
    function deepClone(obj){
        // 函数
        if(Object.prototype.toString.call(obj)==="[object Function]"){
            let str=obj.toString();
            /^function\s*\w*\s*\(\s*\)\s*\{(.*)/.test(str);
            let str1=RegExp.$1.slice(0,-1);
            return new Function(str1);
        }
        // 日期
        if(Object.prototype.toString.call(obj) === '[object Date]'){
            return new Date(obj);
        }
        // 正则
        if(Object.prototype.toString.call(obj) === '[object RegExp]'){
            return new RegExp(obj);
        }
        // 数组和对象
        let cloneObj = Array.isArray(obj)? []: {};
        for(let i in obj){
            if(obj.hasOwnProperty(i)){
                cloneObj[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i];
            }
        }
        return cloneobj;
    }
```
### 实现监听器
实现一个简易版的监听器
```
class EventEmitter{

    constructor() {
        this.messageBox = {};
    }
    
    on(eventName, func){
        const callbacks = this.messageBox[eventName] || [];
        callbacks.push(func);
        this.messageBox[eventName] = callbacks;
    }

    emit(eventName, ...args){
        const callbacks = this.messageBox[eventName];
        if(callbacks.length > 0){
            callbacks.forEach((callback) =>{
                callback(...args);
            })
        }
    }

    off(eventName, func){
        const callbacks = this.messageBox[eventName];
        const index = callbacks.indexOf(func);
        if(index != -1){
            callbacks.splice(index, 1);
        }
    }
}
```
### 手写Ajax
使用原生的方式写ajax方法
```
    (function (window){
    let ajax = function (url, options){
        let xmlHttp = null;
        if(window.XMLHttpRequest){
            xmlHttp = new XMLHttpRequest();
        }else{
            xmlHttp = new ActiveXObject();
        }

        if(xmlHttp != null){
            xmlHttp.onreadystatechange = handler; 
            xmlHttp.open(options.method, url, true);
            if(options.method == 'GET'){
                xmlHttp.send(null);
            }else{
                for(let k in options.header){
                    xmlHttp.setRequestHeader(k, options.header[k]);
                }
                xmlHttp.send(options.data);
            }
        }
        
        function handler(){
            if(xmlHttp.readyState == 4 && xmlHttp.status == 200){
                document.body.XX.innerHTML = xmlHttp.responseText;
            }
        }
        window.ajax = ajax;
    }
})(window);
```
### 手写jsonp
实现一个jsonp的方法
```
    (function (window, document){
        let jsonp = function (url, data, callback){

            // 1.将data数据解析到url后面
            let dataString = url.indexOf('?') == -1 ? '?': '&';
            for(let key in data){
                dataString += key + '=' + data[key] + '&';
            }

            // 2.注册回调函数
            let cb = 'cb' + Math.random().toString().replace('.', '');
            dataString += 'callback=' + cb;

            // 3.创建script标签
            let scriptEle = document.createElement('script');
            scriptEle.src = url + dataString;

            // 4.挂载回调函数
            window[cb] = function (data){
                callback(data);
                document.body.removeChild('scriptEle');
            }

            // 5.添加script标签
            document.body.appendChild(scriptEle);
        };

        window.$jsonp = jsonp;
    })(window, document);
```
### 手写indexOf
不借助正则表达式，字符相关的函数，实现indexOf
```
    Array.prototype.indexOf = function (searchEle, fromIndex){
        let len = this.length;

        //判断是否有fromIndex且是否合法
        if(fromIndex == null){
            fromIndex = 0;
        }
        if(fromIndex < 0){
            fromIndex = len - 1;
        }

        // 循环判断searchEle是否和数组元素相同
        for(let i=fromIndex; i<len; i++){
            if(searchEle === this[i]){
                return i;
            }
        }
        
        return -1;
    }
```
### 遍历dom
遍历某个节点下的所有节点
```
function traversal(node){
    if(node && nodeType === 1){
        console.log(node.tagName);
    }
    let childNodes = node.childNodes, item;
    let len = childNodes.length;
    for(let i=0; i< len; i++){
            item = childNodes[i];
            if(item.nodeType === 1){
                traversal(item);
            }
    }
}
```
### 实现一个bind方法
```
Function.prototype.bind = function (){
    let self = this;
    let context = [].shift.call(arguments); 
    let args = [].slice.call(arguments);
    return function (){
        return self.apply(context, [].concat.call(args, [].slice.call(arguments)));
        // return self.apply(context, arguments);
    }
}
```
### promise计时器
```
(function (window){

    let promise = function createPromise(time){
        for(let i=1; i<=time; i++){
            new Promise(function(resolve, reject){
                setTimeout(()=>{
                    resolve(i);
                }, 1000*i);
            }).then((i)=>{
                console.log(i);
            })
        }
    };
    window.$promise = promise;
})(window);

//调用方式 
// $promise(5);
```
### generator实现计时器
```
(function (window){
    let sleep = function (time){
        function* Generator(time){
            for(let i=1; i<=time; i++){
                console.log(i);
                yield hanlder(1000);
            }
        }

        function hanlder(){
            setTimeout(()=>{
                gen.next();
            })
        }

        let gen = Generator(time);
        gen.next();
    }
    window.$sleep = sleep;
})(window);

// 调用方式
// $sleep(5)
```
### async实现计时器
```
(function (window){
    let asyncTime = function (time){
        async function asyncFunction(){
            for(let i=1; i <= time; i++){
                await sleep(i);
            }
        };

        function sleep(i){
            return new Promise((resolve)=>{
                setTimeout(()=>{
                    console.log(i);
                    resolve();
                }, 1000)
            })
        }
        asyncFunction();
    }
    window.$async = asyncTime;
})(window);
// 调用方式
$async(5);
```