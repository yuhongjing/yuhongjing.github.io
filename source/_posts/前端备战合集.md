---
title: 前端备战合集
date: 2018-08-11 11:28:44
tags: 前端
keywords: 前端
categories: "备战系列"
---
### 前言
加油，为了更好的明天，前端备战！！！！！
<!--more-->
# 知识点
下面的资料是所有前端资料的整合
## HTML相关
**事件捕获,事件冒泡,事件委托**
```
    事件捕获是从父元素一层一层的向下捕获直到点击的元素。
    事件冒泡是从点击的元素一层一层的向父元素冒泡。
    事件委托基于事件冒泡的机制，例如原本在li上点击的事件，可以委托在ul上,委托父级元素执行事件。
```
**h5的存储方式有哪些**
```
    cookie 4kb 
    localstorage 键值匹配 永久存储 5M
    sessionstorage 和localstorage差不多，不过（浏览器）关闭就清除了
    application cache（离线缓存） 配置mainfest
    indexedDB（索引数据库）
```
 **xmlHttpRequest原理，跨域，带cookie**
 ```
    原理
        XMLHTTPRequest对象向服务器发送请求和解析服务器响应提供了流畅的接口，
        能够以异步方式从服务器府区区获取更多信息而不必刷新页面。
    跨域
        如果是get方式，就用jsonp，
        否则就是CORS，需要在服务器设置响应头Access-Control-Allow-Origin
     携带cookie
        一般是无法携带的，不过可以通过CORS的方式实现
        前端请求
          xhrFields: {
              withCredentials: true
           }
         后端响应
         Access-Control-Allow-Credentials", "true"
 ```
## CSS相关
**移动端适配方案有哪些**
```
    @media媒体查询
    rem
    vw vh
```
**vw vh 1vw等于多少**
```
    vw是视窗宽度
    vh是视窗高度
    1vw是视窗宽度的1%;
```
**rem是什么**
```
   rem是根据html的font-size大小来变化，
   一种是可以通过js来调整HTML的字号 
   一种是通过媒体查询
```
 **transition和animation有什么区别**
 ```
    transition是过渡动画, 只能指定   起始状态和结束状态，需要由动作(hover)来触发执行， 作用就是平滑的改变css值
    animation是动画，有多个关键帧设置，可以自己执行，
 ```
 **两边宽度固定，中间自适应的布局**
```
    圣杯布局和双飞燕布局都是两边栏固定，中间自适应的布局，还有flex也是可以解决的。
    /*圣杯布局*/
    *********************CSS********************* 
        .container {
            padding: 0 300px 0 200px;
        }
        .left, .main, .right {
            position: relative;
            min-height: 130px;
            float: left;
        }
        .left {
            left: -200px;
            margin-left: -100%;
            background: green;
            width: 200px;
        }
        .right {
            right: -300px;
            margin-left: -300px;
            background-color: red;
            width: 300px;
        }
        .main {
            background-color: blue;
            width: 100%;
        }
    *************HTML*******************
    <div class="container"> 
    　　<div class="main">main</div> 
    　　<div class="left">left</div> 
    　　<div class="right">right</div> 
    </div>
    可以看到圣杯布局主要是通过相对定位,float浮动和margin为负完成的.
    /*双飞燕布局*/
    *****************************CSS*********************
    .left, .main, .right {
        float: left;
        min-height: 130px;
        text-align: center;
    }
    .left {
        margin-left: -100%;
        background: green;
        width: 200px;
    }

    .right {
        margin-left: -300px;
        background-color: red;
        width: 300px;
    }
    .main {
        background-color: blue;
        width: 100%;
    }
    .content{
        margin: 0 300px 0 200px;
    }
    ***************HTML****************
    <div class="container"> 
　　<div class="main">
    　　<div class="content">main</div> 
    </div>
　　<div class="left">left</div> 
　　<div class="right">right</div> 
    </div>
    通过多一个div,就可以不用相对定位等css属性了，算是一种简化版
    /*Flex布局*/
    *****************CSS**********************
    .container{
        display: flex;
        min-height: 130px;
    }
    .main{
        flex-grow: 1;
        background-color: blue;
    }
    .left{
        order: -1;
        flex-basis: 200px;
        background-color: green;
    }
    .right{
        flex-basis: 300px;
        background-color: red;
    }
    *****************HTML*****************
    <div class="container"> 
　　<div class="main">main</div> 
　　<div class="left">left</div> 
　　<div class="right">right</div> 
    </div>
    Flex弹性布局，就很轻松了
```
 **box-sizing是什么**
 ```
    改变盒子模型，例如怪异模型和标准模型，改变盒子的计算尺寸方式。
 ```
 **rem与em了解吗？分别是相对于谁来计算的？**
```
    rem相对于html的font-size计算的
    em是相对于父元素的font-size计算的
```
**了解移动端的适配吗？请问什么是rem布局？在移动端的1px问题该如何解决。**
```
    rem布局是通过js来计算rem的值，来适配不同的移动端
    移动端的1px问题主要是逻辑像素和物理像素需要1对1 
    通过meta标签的viewport的属性设置能够完成
```
**对于css3的transform有了解吗？**
```
    关于元素的形变元素，有旋转，放大，缩小等
```
**对于css3的动画有了解吗？必填属性有哪些？**
```
    animation属性，@keyframes
```
**在实现一个div移动的动画，使用translate、top（代指定位）、margin之间有什么性能上的不同？**
```
    渲染相关吧，margin会重新渲染dom
```
**如何清除浮动？ 什么是css样式初始化？为什么要这么做？**
```
    清楚浮动可以通过伪类选择器，div clear , overflow等
    css样式就是把一些基本的标签的的margin,padding等重设，因为每个浏览器的标准可能不同
```
**css选择器的权重都是什么？什么是伪类与伪元素？**
```
    id>class = 伪类 > 标签 = 伪元素 > 通配符
```
**什么是盒子模型**
```
    一般分为标准盒子模型和怪异盒子模型
    标准盒子模型的width = 元素content
    怪异盒子模型的width = 元素content + （padding + border） * 2
```
**什么的BFC,什么元素会生成BFC,BFC的布局规则是什么**
```
    BFC(块级格式化上下文)是一个独立的布局环境,其元素是不受外界影响的。
    只要是float值不为none，position不为static和relative的。
    display不是inline-block, table-cell, flex, table-caption,inline-flex的
    overflow值不为visible的都会生成BFC元素
    在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列
```
**width与height设置的百分比是相对于谁计算，padding和margin呢**
```
    width和height的百分比是相对于父容器计算
    padding和margin是相对于父元素的宽度计算的
```
**如何设置一个元素垂直居中**
```
    flex方式
        父元素 display: flex 子元素 margin: auto
    绝对定位
        父元素 position: absolute;top: 0; bottom: 0; 子元素 margin: auto;
```
**CSS响应式布局**
```
    响应式网站是指一个网站能兼容多个终端！
    1.@media的方式进行响应式布局
    2.flex流式布局也是可以的
```
**display:none和visibilty:hidden的区别**   
```
    display：none属性：
        1. 不为对象保留物理空间
        2. 对象从页面彻底的消失
        3. 浏览器也不会解析此元素
        4. 切换显示时页面会产生回流
    visible：hidden属性
        1. 仅仅使元素不可见
        2. 但其物理空间依旧存在类似于透明度为0
        3. 切换显示时不产生回流
        4. 性能较display会更好
```
**相对布局和绝对布局,position: relative和absoulte**   
```
    position: absoulte绝对布局
        1. 元素脱离文档流
        2. 会找寻父元素是否有position: relative属性，如果没有会逐级向上找，直到找到body。
        3. 元素是相对于找到的父元素(position: relative 否则 body)定位。
    position: relative相对定位
        1. 元素未脱离文档流
        2. 会对文档流中其他元素的结构产生影响，例如子元素是绝对定位
        3. 元素的原本位置依旧保留，视觉空间偏移
```
**flex布局**  
```
    flex是专门为页面布局而产生的属性，针对于以前使用div+float+postion的布局方式。
    flex无疑是简单的很多很多。
    flex常用的属性:
    display: flex;  flex-wrap;  flex-direction; flex-flow等
```
**block,inline-block,inline的区别**  
```
    block块元素
        1. 独占一行，宽度自动填满父元素的宽度
        2. 可以设置宽度高度，即使设置了宽度仍是独占一行
        3. 可以设置padding和margin
    inline内联元素
        1. 不独占一行，宽度随内容变化
        2. width和height无效
        3. padding和margin只有水平方向有效果，垂直方向没有效果
    inline-block
        1. 是inline和block的结合体
        2. 显示为inline，但是可以设置width,height,padding,margin等block的属性
```
**position相关**
```
    position属性是指定元素在文档中的定位方式
    通过top,right,bottom,left来确定元素的位置
    定位类型有:static, relative, absolute, fixed ,sticky
        static: 元素默认定位,top,right,left,bottom,z-index属性无效
        relative: 仅仅视觉调整元素位置，而实际位置还在原位，会影响子元素的布局方式(absolute),table相关属性无效。
        absolute: 不为元素预留空间，相对于最近的非static的祖先元素定位，可以设置外边距不和其他static边距重合。
        fixed: 不为元素预留空间，通过屏幕视口(viewport)来指定元素位置,会创建新的层叠上下文,
               当元素的祖先为transform非none时，容器由该视口改为该祖先。
        sticky: 根据正常的static元素布局，相对于(BFC)和最近块元素祖先元素定位。当被粘性定位时，仍按照b未定位的位置定位。
```
## JS相关
**es6的类中 静态属性和构造函数谁先加载 为什么**
```
    静态属性先加载，因为构造函数需要等待类的实例生成时才能触发，
    而静态属性是加载时便已经存在了。
```
**静态属性和方法是类的还是实例的**
```
    静态属性和方法是属于类的。
```
**怎么在外部调用静态属性**
```
    类名.属性名
```
 **函数rest参数可以用其他名字替换吗**
```
    rest是获取多余的参数和argument获取全部参数不同
    当然可以,
    只要形式为...变量名。就可以了
    例如 function add(a, ...values)
```
**准确的判断js数据类型**
```
    Object.prototype.toString.call(obj)
```
**new生成一个对象的过程**
```
    创建了一个原生对象 例如obj = new Object();
    获得对象的构造函数的prototype对象,并赋值给obj的prototype。
    call构造函数的内部方法，把其中的this赋值为新创建的对象，并传入参数
    执行构造函数,返回创建的对象   return this
```
**es6了解什么**
```
    1. 箭头操作符
    2. 类的支持class
    3. 对象字面量不用写function 什么的了
    4. 字符串模板``这个符号
    5. 解构
    6. 默认参数值
    7. let与const关键字
    8. for of值遍历
    9. 模块export和import
    10. Map和Set
    11. Promises异步处理
```
**setTimeout什么时候执行**
```
    其他非延迟函数都执行完毕后，就执行setTimeout
```
**async和await是什么**
```
    async 函数是什么？一句话，它就是 Generator 函数的语法糖。《ECMAScript 6 入门》
    async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。
    async函数返回一个Promise对象，可以使用then方法添加回调函数，当函数执行的时候，一旦遇到await就会先返回，
    等到异步操作完成，再接着执行函数体内后面的语句。 这样就可以以同步的方式书写异步的程序了。
    
    await命令
    await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。
    await相当于暂停，并执行之后等待的函数，在执行await的函数
```
**事件循环**
```
主线程读取js代码, 形成相应的堆和执行栈, 执行同步任务
当主线程遇到异步任务,，指定给异步进程处理, 同时继续执行同步任务
当异步进程处理完毕后， 将相应的异步任务推入到任务队列首部
主线程任务处理完毕后,，查询任务队列，则取出一个任务队列推入到主线程的执行栈
重复执行第2、3、4步，这就称为事件循环
```
**js数组有哪些方法**
```
    join(),push(),pop(),shift(),unshift(),reverse(),sort()
    concat(),slice(),splice()等
```
**哪些方法会改变原数组，哪些不改变原数组**
```
    改变的方法有
    pop(),push(),reverse(),shift(),sort(),splice().unshift()
    不改变的方法有
    concat(),join(),slice(),toString(),valueOf()
```
**every和some的区别**
```
    every会测试所有元素是否都通过的函数的检测(&&与运算，所有元素通过才为true)
    some会测试某些元素是否通过函数的检测(||或运算，一个通过及为true)
```
**promise相关**
```
    Promise是一种异步编程的解决方案，比传统的回调函数更合理。es提供了原生的Promise对象。
    Promise是一个容器，保存着未来才会结束的事件(通常是异步)。
    有三种状态,pending(进行中),fulfilled(已经成功),rejected(已经失败)
    只有异步操作才能决定当前是哪一种状态。
    Promise的构造函数提供了两个参数resolve和reject，
    resolve是讲Promise对象的状态从未完成变成完成，reject是将状态从未完成变成失败.
    Promise实例生成后会用then方法分别指定resolved状态和rejected状态的回调函数
```
**如何实现闭包**
```
    函数里面返回函数即可。
```
**call和apply的作用和区别**
```
    call和apply用来调用函数，并用指定对象（第一个参数）替换函数的 this 值.改变this的指向。
    call的参数是一个一个的，而apply是一整个数组。
```
**ES6新增的set()和map()有什么区别**
```
    set一种类似于数组的数据结构，成员都是唯一的没有重复的值。
    可以接受的参数是一个数组或者类似数组的对象。
    Map是一种"键-值"的Hash结构，键可以由字符串，各种对象构成。
```
**js深拷贝**
```
    如果没有循环引用的话。
    JSON.parse(JSON.stringify(obj))
```
**如何改变this的指向**
```
    call,apply,bind
    区别就是call和apply可以看做某个对象的方法，可以通过调用方法的方式来调用此函数
    call传一个一个的参数，apply传数组
    而bind是将某个函数绑定到某个对象上
```
**js文件加载阻塞**  
```
    原因
        JavaScript是单线程，所以在运行时其他事情不能被浏览器处理。
    而大多数浏览器都是单线程来处理这些业务，所以同一时间，只能执行一个任务。  
    这就导致了执行js时，其他页面无法工作。
    解决
        1. 老办法，将js放在</body>前，确定dom已经渲染了，才引入js。
            然而这样还是会阻塞。
        2.  defer和async属性，只针对外联js。
            使用defer的<script>标签是按照他们排列的顺序执行
            而使用async的<script>标签是不按他们在HTML中的排列顺序执行
            这样就解析js时就不会产生阻塞了。
```
**js基本对象类型和引用对象类型的区别**  
```
    基本类型有: string number boolean null undefined
    引用类型有: Funtion Array Object
    
    访问方式
        基本类型，直接操作和访问变量实际的值
        引用类型，值保存在内存中，js不允许直接访问内存，操作的时候时通过对象的引用
    存储的位置
        基本类型，保存在栈中
        引用类型，引用存放在栈中，实际对象在堆中 
```
**变量提升、函数名提升问题，哪些情况会有变量、函数名的提升？**
```
    函数声明是函数的声明和实现都被提升了。
    函数表达式和变量表达式只是其声明被提升了。
    函数名和变量名重复时，优先提升函数名.
```
**什么是IIFE立即执行函数？如何实现？**
```   
    声明的同时立即调用这个函数
    (function foo(){
    var a = 10;
    console.log(a);
    })();
    在函数声明后添加一个().
    IIFE的目的是为了隔离作用域，防止污染全局命名空间。
```
**null和undefined的区别**
```
    null的typeof是object, undefined的typeof就是undefined
    null是一个空对象指针，undefined是声明了但是没有初始化
    javascript权威指南说，undefined是系统级的值空缺,而null是程序级的值空缺
```
**如何判断一个变量是否是数组**
```
    1. instanceof
    2. constructor
    3. toString()   Object.prototype.toString.call(arr) === '[object Array]'
```
**js的哪些操作会实现隐式转换**
```
    1. 递增递减
    2. 逻辑操作符
    3. 关系操作符
    4. 相等操作符   
```
**es6的symbol**
```
    symbol是一种新的基础类型，
    symbol的存储方式是键值相对，每一个symblo都是独一无二的。
    为了避免程序重复的变量而开发出来的。
```
**js如何实现继承？ES6 class如何实现的继承？与ES5的区别是什么？**
```
    js是通过原型链实现继承的
    es6 通过关键字 extends 实现继承的，实际还是通过原型链只不过是封装了。
    es5是通过原型和构造函数，es6是通过封装的关键字
```
**jsonp的原理**
```
    1.有src属性的标签都能跨域(img,script,iframe)等
    2.所以利用script来实现跨域，因为script只能请求js相关文件，所以需将远程服务器的数据装入js中，供客户端调用。
    3.于是json被发现了，它可以简单的描述复杂数据，还被js原生支持。客户端也可以很轻易的处理这种数据。
    4.所以客户端像调用脚本一样的，来调用跨域服务器上的js格式文件(json)。
    5.这种方式逐渐成为了一种非正式的传输协议，称之为jsonp，主要的特点就是用户需要提交一个callback，然后服务器
       返回数据的时候就会通过这个callback包裹住，这样客户端就可以随心所欲的处理返回的数据。
```
**Object和Function的关系**
```
    1. Object和Function都是构造函数,所有的构造函数都是Function的实例，所以Object是Function的实例。
    2. Function.prototype是Object的实例对象。
    3. 实例对象的原型(proto)会指向其构造函数的prototype属性，Object.proto === Function.prototype,
        Function.proto === Function.prototype, Funtion.prototype === Object.protoype
    4. 当访问一个属性值时，它会沿着原型链向上查找，直到找到或者到Object.prototypr.proto(null)为止。
```
**ES6异步编程**
```
    1. 回调函数callback,容易产生回调地狱。
    2. Promise, 通过then方法加载回调函数，catch捕捉错误，但是then太多就会导致代码混乱。
    3. 协程，我没用过不知道，反正可以解决！
    4. Gennerator函数,yield, 可以暂停执行和恢复执行，所以能够解决异步。
```
**说一下原型链**
```
    js对象是基于原型链的。有原型和原型链的概念。
    原型很简单，就是你继承于谁。
    js的对象只有__proto__属性，而函数有prototype和__proto__属性。
    因为对象和函数都是通过Funtion的构造函数生成的。所以对象的__proto__ 是继承于Funtion的构造函数(prototype)的。
    而函数的prototype就是他自己的构造函数(prototype)。函数的__proto__是继承于Object的构造函数(prototype)因为一切都继承于Object
    但是Object的__proto__为Null
```
**闭包的原理**
```
    闭包的实现和以下几个原理有关:
    变量作用域: 全局变量，全局都能使用，函数内部定义的变量，仅能在函数内部使用。
    函数作用域: 在函数内声明的变量，在函数体内始终是可见的。
    作用域链: 作用域链式一个对象，它定义了该作用域内的变量，保证作用域的变量函数的访问。
    作用域链的创建: 定义一个函数时会保存一个作用域链，调用一个函数时，会创建一个新的对象来存储器局部变量，并添加进保存的作用域链上。
                    每次调用函数，都会创建新的作用域链，虽然内部代码相同，但是作用域链是不同的。
    垃圾回收机制: js有自动回收垃圾的机制，会定期把不再使用的变量销毁，释放内存。（只会销毁局部变量，全局变量是关闭浏览器时才销毁）
    闭包的原理就是： 函数的执行依赖于函数定义的时候的作用域链，所以函数执行的时候用的作用域链是定义时候创建的，但当执行的函数的作用域
                    域链和定义的作用域链不同时，就会出现问题！即一个函数嵌套一个函数并返回函数时就会产生闭包的情况。
                    当外部函数把嵌套函数作为返回值返回时，其执行结果仍然是局部变量的值，而不是全局变量的值。
                    这就是因为函数执行时用到的作用域链，其实是函数定义时创建的。不管该函数在何时何地执行，它通过作用域链最先找到的变量就是相同外部函数中定义的变量
                    而闭包正是利用这种特性实现的：闭包可以捕捉到局部变量或参数，并一直保存下来，使其不会被当成垃圾回收。
    注意： 如果闭包使用不得当，会导致大量的局部变量没有回收，导致内存泄露！所以看看那些大框架是怎么使用闭包的吧！
```
**js深浅复制**
```
    浅拷贝：仅仅复制对象的引用，而不是对象本身
    深拷贝：把复制的对象所引用的全部对象都复制一遍
```
 **原型链继承**
```
    对象.prototype = new 要继承的对象()
```
**箭头函数**
```
    可以简化代码.
    但是不绑定this,和arguments
```
## JQ相关
**为什么Jquery只需要$即可生成Jquery对象**
 ```
    Jquery3.X的源码文件，能够解释一切。
    if ( !noGlobal ) {
    	window.jQuery = window.$ = jQuery;
    }
    return jQuery;
    } );
    所以$() === jQuery()
    还是通过构造函数生成的。
 ```
 **既然是构造函数,为什么不用new呢**
 ```
    Jquery3.X的源码能说明一切
    jQuery = function( selector, context ) {
    		return new jQuery.fn.init( selector, context );
    	},
    执行Jquery后，return一个new的Jquery并且初始化.
    没毛病，还是正常的new class。只是巧妙的封装了。
 ```
 **jQuery ready原理、window.onload区别**
 ```
    ready: DOM结构加载完毕,就可执行,可多次执行
    onload: 网页必须全部加载完,才能执行,只能执行一次
 ```
## Vue相关
**vue的特点**
```
    1.MVVM框架，数据双向绑定
    2.轻量级的渐进式框架
    3.组件单向流通
    4.有自己的指令
    5.大型单页式的网站
```
**vue组件之间的通信**
```
   vue是单向数据通信
   父传子 props
   子传父 $on, $emit
   非父子，可以通过使用一个空的Vue实例作为中央事件总线
```
**vue双向数据绑定的原理**
```
   vue是基于object.defneProperty()属性拦截器实现的
```
**vue的生命周期以及每个周期用来干什么的**
```
    beforeCreate 实例创建前,此时无法读取data、 methods
    created 实例创建后，这是已经有了data,属性和方法的运算，watch/event事件等，但是mount还未挂载,数据还未渲染。
    beforeMount 挂载开始前，相关的render调用
    mounted el的dom节点被vm.$el替换，实例数据在dom上渲染
    beforeUpdate 数据更新是调用，不进行dom重新渲染， 在数据更新前可以进行状态处理
    updated: 数据更新并且dom渲染，这时dom已经更新，每次数据更新都会执行updated
    beforeDestory 实例销毁前调用
    destroyed vue实例销毁后调用，vue所有的东西都会被解绑，所有的子实例也会销毁
    应用场景
    created 异步数据请求，初始化数据
    mounted 挂载元素内的dom节点获取
    nextTick 针对单一事件更新数据后立即操作dom
    updated 任何数据的更新，做同一的业务逻辑处理
    watch: 监听数据变化，做出相应的处理
```
**vuex包括什么？对action理解的怎么样**
```
    Vuex是各个组件的状态管理器，也成为前端数据库吧。
    state: 状态的数据结构
    actions: 从服务端获取数据，（异步）调用commit来改变状态
    mutations: 唯一能改变状态的地方
    getters: 组件获取状态器的数据，需通过这里。
    modules: 一个store可以拆分为多个，每个都有自己的state,actions等
    actions我一般用来获取服务器的数据，更新，因为mutations是同步的，不行，而actions是异步的。
```
#### 浏览器相关
**什么算跨域,如何解决跨域**
```
    域名，协议，端口有一样不同，都算是跨域
    解决方式，jsonp，cors，window.domain, 反向代理
```
**localstorage概念,原理**
 ```
    H5新增本地存储的API，有5M的内存大小，是一个本地的小仓库。
    在本地创建了一个文件夹，是永久保存的，
 ```
**跨域相关**
```
    浏览器安全机制同源政策，协议，端口，域名都相同才称为同源，否则需要跨域。
    1. script标签请求数据,只能get请求，且无法访问服务器响应文本(单向请求)。
    2. jsonp通过script的开发策略得到其他网页的json数据，只能get，不知道是否失败，安全性无法保证。
    3. CORS跨域资源共享，通过HTTP请求头和修改后端服务器的响应头配置即可。
    4. 反向代理(例如nginx),原理：本地浏览器->本地服务器->异地服务器->本地浏览器
    5. WebSocket，浏览器与服务器的全双工协议，允许跨域通信。
    6. document.domain跨子域,前提是域名协议，端口都相同。只能跨子域。
    7. img跨域，img也能跨域，不过也是单向请求了，不能得到服务器响应的文本。
```
**cookie与localStorage的区别**   
```
    cookie为了辨别用户身份而存储在本地终端的数据
        1.  存放大小4kb
        2. 一般由服务器生成，可设置失效时间，如果浏览器默认生成，则浏览器关闭即失效
        3. 一般用于记住密码，标识身份等
    localStorage用于浏览器端缓存数据
        1. 一般为5MB
        2. 除非被清除，否则永久保存
        3. 一般保存比较大的数据
```
## 网络原理相关
**http和https的区别**
```
    HTTP：超文本传输协议，明文传输，连接端口是80。    
    HTTPS：加密传输，是Http+ssl(安全套接字)协议构建的，端口是443，需要申请ca证书。
```
**浏览器输入网址到页面渲染全过程**  
```
    其实原理挺复杂的，各方各面都有涉及，就写简约一点。
        1. 浏览器把输入的域名进行dns解析，得到ip地址。
        2. 通过ip和arp地址找到目标服务器地址。
        3. 进行tcp连接。
        4. 浏览器发送请求，等待响应。
        5. 服务器处理请求，开始响应。
        6. 浏览器收到响应，得到html代码。
        7. 渲染页面。
```
**TCP和UDP的区别**
```
    TCP是面向连接的传输方式(三次握手),UDP是非连接的传输方式
    TCP的数据按序到达，不错误，不丢失，不重复，UDP尽最大努力交付，不保证可靠。
    TCP面向字节流，UDP面向报文
    TCP是点对点，UDP支持一对一，一对多，多对一，多对多 
    TCP是全双工的可靠信道，UDP是不可靠信道
    TCP首部开销20字节，UDP首部开销8字节
```
 **CDN是什么**
 ```
    内容分发系统,会实时根据网络状态，负载节点等各种情况，找到用户最优的节点。
    提高用户访问的响应速度。
 ```
 **工作在各个层的协议**
```
    物理层: RJ45 CLOCK IEEE802.3(中继器, 集线器, 网关)
    链路层: PPP FR HDLC VLAN MAC(网桥, 交换机)
    网络层: IP ICMP ARP RARP OSPF IPX RIP IGRP(路由器)
    传输层: TCP(三次握手可靠传输) UDP(非连接传输) SPX
    会话层: NFS SQL NETBIOS RPC
    表示层: JPEG MPEG ASII
    应用层: FTP DNS TELNET SMTP HTTP WWW NFS
```

## 其他
**首屏加载优化**
```
    1. 除了首屏的图片，其他的图片都采用懒加载。
    2. 其他的和上面前端优化差不多
    3. 其实我也听说过一种叫做服务端渲染的技术，SSR？
```
**排序算法有哪些**
```
    排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，
    而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。
    主要是内部排序
    直接插入排序(稳定)：设置标兵，标兵是前n个元素中最大(小)的元素，后面的与之相比较，大(小)则交换。
    希尔排序(不稳定)：减少增量排序，按数组增量分组。例如增量为2[2,3,1,4]分为[2,1][3,4]分别排序，然后合并。
    简单选择排序(不稳定)：每一轮选择第n大的数字与第n个位置交换。(例如最大的数位置和第一个位置交换);
    堆排序(不稳定)：将数组排列成堆，每个元素都与堆顶元素比较，将堆顶元素沉入堆底，重复操作即可。
    冒泡排序(稳定)：相邻元素第一个比第二个元素大(小)就交换，每一对比较，一轮下来最大最小就会在最后。比完即可。
    快速排序(不稳定)：左指针右指针和一个基数，左右指针重合的时候两边分别比基数大和基数小，然后再循环以上步骤即可。
    归并排序(稳定)：分治法，数组对半拆分直到不可分，然后逐渐合并排序，即可。
    桶排序(稳定)：把数组分在各个子区间，然后各个子区间分别排序，最后合并排序，即可。
    基数排序(稳定)：桶排序的扩展，将整数按位数切割排序，不足补0。即可。
```
**前端性能优化**
```
    1. 减少Http请求（图片绘制成一张，然后客户端拆分）
    2. 使用CDN
    3. 添加Expires头,缓存组件
    4. 压缩组件，gzip什么的
    5. 样式表放在头部(避免白屏)
    6. 脚本放在底部（避免阻塞）
    7. 使用外部js和css，因为浏览器可能会缓存它们
    8. 避免css表达式
    9. 精简js和css代码
    10. 减少iframe的个数
    11. 预加载，延迟加载的合理应用。
```
**MVVM和MVC的区别**  
```
    MVVM是将"数据模型数据双向绑定"的思想作为核心，因此View和Model没有联系，通过ViewModel进行交互。  
    因此试图变化的数据会修改数据源，而数据源的变化也会反应到视图上。
    MVC还是传统的方式，只是逻辑分离了。用户操作视图(view0，反应到控制器(业务逻辑)，控制器调用模型(数据持久化)，最后反馈到视图。
```
**对象和类的区别，具一个例子**
```
    类是对象的抽象概念，对象是类的具体表达。《PHP核心技术与最佳实践》
    类是抽象的，不具体的，一些东西可以归为一类，不占空间的。
    对象是具体的，是一个类的具体表达，占空间的。
    例如动物是一类，猫，狗就是对象。猫狗是具体存在的，而动物是抽象的。
```
**你理解的面向对象**
```
    面向对象编程需要抽象的思维，把一些直观的东西需要抽象，但是代码量会大一些。
    例如我之前写过一个象棋项目，他就分了很多类，棋子类，棋盘类，规则类等。
    如果是面向过程，就不分这么多，直接就写很多函数，完成就OK，但是不好扩展。
    面向对象的优势是，扩展性强，复用性好，维护简单。
```
**垃圾回收机制的理解**
```
    垃圾回收机制是一种自动释放变量的机制。以免变量一直占用内存。
    js的垃圾回收机制是，当js检测到一个变量之后不会再使用的时候，就会把它释放。
    js的垃圾回收的两种方式，标记清除和引用计数
    1. 标记清除
        这是js最常用的回收方式，当变量进入执行环境时，就标记为“进入环境”，
        进入执行环境的变量不能释放，因为他们可能随时用到，当变量离开环境的时候，
        则将其标记为“离开环境”，然后去掉环境中的变量和标记，然后垃圾收集器来搜集。
        例如进入函数，函数里面的标记就变为进入环境，当离开环境后，局部变量就会被回收。
    2. 引用计数
        不太常见的回收策略，跟踪每个值被引用的次数，当一个变量已经没有引用类型引用的时候，
        就会把他回收。
        例如a=3，现在a引用的是3，但当a=4的时候，这里的3仍在，并不是被替换。
        而是a引用到4了，此时3已经没有任何变量引用它，它就会被回收了！
```
**问==和===的区别,`typeof null`是什么**
```
    ==是判断值是否相同，如果类型不同，会自动转化类型，再对比值
    ===是判断类型和值是否都相同
    typeof null的值为object， 一个既是对象，又不是对象的东西
```
**AMD和commonjs是怎么使用，怎么配置，有什么好处**
```
    两者都是为了实现模块化编程的，
    Commonjs是服务端的，比如Node,是同步加载不同模块文件，
    ADM是异步模块定义，是适用于浏览器端的模块加载方式，是异步加载的方式，例如ajax
    所以浏览器时无法使用Commonjs的模式(除非有四个node环境的变量)
    好处就是，有了模块，我们可以更方便的使用别人的代码，想要什么功能，就加载什么模块。
    怎么配置？目前还没研究啊!
```
### 总结
前途漫漫，耐心等待。