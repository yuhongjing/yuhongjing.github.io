<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-cn">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="前端" />










<meta name="description" content="前言加油，为了更好的明天，前端备战！！！！！">
<meta name="keywords" content="前端">
<meta property="og:type" content="article">
<meta property="og:title" content="前端备战合集">
<meta property="og:url" content="https://yuhongjing.github.io/2018/08/11/前端备战合集/index.html">
<meta property="og:site_name" content="余鸿靖博客">
<meta property="og:description" content="前言加油，为了更好的明天，前端备战！！！！！">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2018-09-04T13:09:14.185Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端备战合集">
<meta name="twitter:description" content="前言加油，为了更好的明天，前端备战！！！！！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yuhongjing.github.io/2018/08/11/前端备战合集/"/>





  <title>前端备战合集 | 余鸿靖博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-cn">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余鸿靖博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一个菜鸟程序员的小空间</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuhongjing.github.io/2018/08/11/前端备战合集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余鸿靖">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余鸿靖博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端备战合集</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-11T11:28:44+08:00">
                2018-08-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/备战系列/" itemprop="url" rel="index">
                    <span itemprop="name">备战系列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/11/前端备战合集/#SOHUCS" itemprop="discussionUrl">
                  <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2018/08/11/前端备战合集/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11,146 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  43 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>加油，为了更好的明天，前端备战！！！！！<br><a id="more"></a></p>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>下面的资料是所有前端资料的整合</p>
<h2 id="浏览器H5相关"><a href="#浏览器H5相关" class="headerlink" title="浏览器H5相关"></a><span style="color:red">浏览器H5相关</span></h2><p><strong>浏览器内核，html css js的加载原理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webkit, trident, blink等</span><br><span class="line">html 根据Docytype来触发盒子的模型，是否怪异</span><br><span class="line">css 会生成dom树和css树合并后 渲染</span><br><span class="line">js 有一个js的引擎来解释和执行js代码</span><br></pre></td></tr></table></figure></p>
<p><strong>HTML语义化</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标签 header section footer nav等等</span><br><span class="line">好处就是方便SEO，方便爬虫趴取。</span><br></pre></td></tr></table></figure></p>
<p><strong>window.onload和image.onload那个先执行</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">image.onload先执行</span><br><span class="line">因为window.onload是dom，页面所有的资源都加载完毕了才会执行。</span><br></pre></td></tr></table></figure></p>
<p><strong>xmlHttpRequest原理，跨域，带cookie</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">原理</span><br><span class="line">    XMLHTTPRequest对象向服务器发送请求和解析服务器响应提供了流畅的接口，</span><br><span class="line">    能够以异步方式从服务器去获取更多信息而不必刷新页面。</span><br><span class="line">跨域</span><br><span class="line">    如果是get方式，就用jsonp，</span><br><span class="line">    否则就是CORS，需要在服务器设置响应头Access-Control-Allow-Origin</span><br><span class="line"> 携带cookie</span><br><span class="line">    一般是无法携带的，不过可以通过CORS的方式实现</span><br><span class="line">    前端请求</span><br><span class="line">      xhrFields: &#123;</span><br><span class="line">          withCredentials: true</span><br><span class="line">       &#125;</span><br><span class="line">     后端响应</span><br><span class="line">     Access-Control-Allow-Credentials&quot;, &quot;true&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>什么算跨域,如何解决跨域</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">域名，协议，端口有一样不同，都算是跨域</span><br><span class="line">解决方式，jsonp，cors，window.domain, 反向代理</span><br></pre></td></tr></table></figure></p>
<p><strong>localstorage概念,原理</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H5新增本地存储的API，有5M的内存大小，是一个本地的小仓库。</span><br><span class="line">在本地创建了一个文件夹，是永久保存的，</span><br></pre></td></tr></table></figure></p>
<p> <strong>h5的存储方式有哪些</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cookie 4kb </span><br><span class="line">localstorage 键值匹配 永久存储 5M</span><br><span class="line">sessionstorage 和localstorage差不多，不过（浏览器）关闭就清除了</span><br><span class="line">application cache（离线缓存） 配置mainfest</span><br><span class="line">indexedDB（索引数据库）</span><br></pre></td></tr></table></figure></p>
<p><strong>强缓存和协商缓存</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">强缓存不用请求服务器，直接使用。</span><br><span class="line">利用http头部返回的Expires或者Cache-Control来控制</span><br><span class="line">协商缓存需请求服务器，告知能否使用缓存。</span><br><span class="line">如果两个都没有命中，服务器就回发回资源。</span><br></pre></td></tr></table></figure></p>
<p><strong>跨域相关</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">浏览器安全机制同源政策，协议，端口，域名都相同才称为同源，否则需要跨域。</span><br><span class="line">1. script标签请求数据,只能get请求，且无法访问服务器响应文本(单向请求)。</span><br><span class="line">2. jsonp通过script的开发策略得到其他网页的json数据，只能get，不知道是否失败，安全性无法保证。</span><br><span class="line">3. CORS跨域资源共享，通过HTTP请求头和修改后端服务器的响应头配置即可。</span><br><span class="line">4. 反向代理(例如nginx),原理：本地浏览器-&gt;本地服务器-&gt;异地服务器-&gt;本地浏览器</span><br><span class="line">5. WebSocket，浏览器与服务器的全双工协议，允许跨域通信。</span><br><span class="line">6. document.domain跨子域,前提是域名协议，端口都相同。只能跨子域。</span><br><span class="line">7. img跨域，img也能跨域，不过也是单向请求了，不能得到服务器响应的文本。</span><br></pre></td></tr></table></figure></p>
<p><strong>cookie与localStorage的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cookie为了辨别用户身份而存储在本地终端的数据</span><br><span class="line">    1.  存放大小4kb</span><br><span class="line">    2. 一般由服务器生成，可设置失效时间，如果浏览器默认生成，则浏览器关闭即失效</span><br><span class="line">    3. 一般用于记住密码，标识身份等</span><br><span class="line">localStorage用于浏览器端缓存数据</span><br><span class="line">    1. 一般为5MB</span><br><span class="line">    2. 除非被清除，否则永久保存</span><br><span class="line">    3. 一般保存比较大的数据</span><br></pre></td></tr></table></figure></p>
<h2 id="CSS相关"><a href="#CSS相关" class="headerlink" title="CSS相关"></a><span style="color:red">CSS相关</span></h2><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a><span style="color:blue">布局</span></h3><p><strong>两边宽度固定，中间自适应的布局</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">圣杯布局和双飞燕布局都是两边栏固定，中间自适应的布局，还有flex也是可以解决的</span><br></pre></td></tr></table></figure></p>
<h3 id="移动端适应"><a href="#移动端适应" class="headerlink" title="移动端适应"></a><span style="color:blue">移动端适应</span></h3><p><strong>移动端适配方案有哪些</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media媒体查询</span><br><span class="line">rem</span><br><span class="line">vw vh</span><br></pre></td></tr></table></figure></p>
<p><strong>了解移动端的适配吗？请问什么是rem布局？在移动端的1px问题该如何解决。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rem布局是通过js来计算rem的值，来适配不同的移动端</span><br><span class="line">移动端的1px问题主要是逻辑像素和物理像素需要1对1 </span><br><span class="line">通过meta标签的viewport的属性设置能够完成</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>CSS响应式布局</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">响应式网站是指一个网站能兼容多个终端！</span><br><span class="line">1.@media的方式进行响应式布局</span><br><span class="line">2.flex流式布局也是可以的</span><br></pre></td></tr></table></figure></p>
<p><strong>移动端300延迟</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">禁止缩放</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot;&gt; 或者</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1&quot;&gt;</span><br><span class="line">设置 viewport 的 device-width</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=3&quot;&gt;</span><br><span class="line">使用指针事件</span><br><span class="line">a, button, .myelements &#123;</span><br><span class="line">    -ms-touch-action: manipulation; /* IE10  */</span><br><span class="line">    touch-action: manipulation;     /* IE11+ */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a><span style="color:blue">动画</span></h3><p><strong>transition和animation有什么区别</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transition是过渡动画, 只能指定   起始状态和结束状态，需要由动作(hover)来触发执行， 作用就是平滑的改变css值</span><br><span class="line">animation是动画，有多个关键帧设置，可以自己执行，</span><br></pre></td></tr></table></figure></p>
<p><strong>对于css3的transform有了解吗？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关于元素的形变元素，有旋转(rotate)，缩放(scale),移动(translate)等</span><br></pre></td></tr></table></figure></p>
<p><strong>对于css3的动画有了解吗？必填属性有哪些？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animation属性，@keyframes </span><br><span class="line">必填属性animation-name animation-duration</span><br></pre></td></tr></table></figure></p>
<p><strong>在实现一个div移动的动画，使用translate、top（代指定位）、margin之间有什么性能上的不同？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">translate 页面不会回流,margin会回流</span><br></pre></td></tr></table></figure></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><span style="color:blue">基本概念</span></h3><p><strong>CSS3新属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">border-raduis 边框</span><br><span class="line">box-shadow 阴影</span><br><span class="line">background-size 背景图片尺寸</span><br><span class="line">background-origin 背景图片位置</span><br><span class="line">transition 过渡动画</span><br><span class="line">animation 动画</span><br><span class="line">column-count 多列</span><br><span class="line">box-sizing 盒子模型</span><br><span class="line">resize 元素尺寸</span><br></pre></td></tr></table></figure></p>
<p><strong>flex基本属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">关于容器的</span><br><span class="line">flex-direction 容器的主轴方向</span><br><span class="line">flex-wrap 换行</span><br><span class="line">justify-content 主轴对齐方式</span><br><span class="line">align-items 交叉轴的对齐方式</span><br><span class="line">align-content 多根轴线的对齐方式</span><br><span class="line">关于项目的</span><br><span class="line">order 项目的排列顺序</span><br><span class="line">flex-grow 放大比例 存在剩余空间放大 默认0</span><br><span class="line">flex-shrink 缩小比例 默认1</span><br><span class="line">flex-basis 固定大小。 默认auto</span><br><span class="line">align-self 对齐方式</span><br></pre></td></tr></table></figure></p>
<p><strong>transform的主要属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主要是元素的改变形状的属性</span><br><span class="line">常用的属性有</span><br><span class="line">rotate(x deg) 旋转</span><br><span class="line">translate(x px, y px) 移动</span><br><span class="line">scale(x, y) 缩放</span><br><span class="line">skew(x deg, y deg) 扭曲</span><br><span class="line">matrix(number)  矩阵</span><br></pre></td></tr></table></figure></p>
<p><strong>Canvas的api</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context.fillRect 绘画矩形</span><br><span class="line">context.arc     绘画圆弧</span><br><span class="line">context.moveTo 绘画线段</span><br><span class="line">context.beginPath 绘画路径</span><br><span class="line">context.drawImage 绘制图像</span><br><span class="line">图片模糊，按照原本图片的两倍大小绘制，然后缩小50%即可</span><br></pre></td></tr></table></figure></p>
<p><strong>重绘重排的优化</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">offsetTop、offsetLeft、offsetWidth、offsetHeight</span><br><span class="line">clientTop、clientLeft、clientWidth、clientHeight</span><br><span class="line">scrollTop、scrollLeft、scrollWidth、scrollHeight</span><br></pre></td></tr></table></figure></p>
<p><strong>translate 和 position的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、当元素原来已经有position:absolute的时候，这时候你想相对于本身移动，可以使用translate</span><br><span class="line">2、做动画的时候translate更适合，不会引起页面的重排和重绘重绘</span><br><span class="line">3、关于transform类的，可以使用GPU加速，提高浏览器的性能</span><br><span class="line">总之：transform更适用于动画</span><br></pre></td></tr></table></figure></p>
<p><strong>vw vh 1vw等于多少</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vw是视窗宽度</span><br><span class="line">vh是视窗高度</span><br><span class="line">1vw是视窗宽度的1%;</span><br></pre></td></tr></table></figure></p>
<p><strong>rem是什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rem是根据html的font-size大小来变化，</span><br><span class="line">一种是可以通过js来调整HTML的字号 </span><br><span class="line">一种是通过媒体查询</span><br></pre></td></tr></table></figure></p>
<p><strong>box-sizing是什么</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">改变盒子模型，例如怪异模型和标准模型，改变盒子的计算尺寸方式。</span><br><span class="line">属性值有: content-box border-box inherit</span><br></pre></td></tr></table></figure></p>
<p> <strong>rem与em了解吗？分别是相对于谁来计算的？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rem相对于html的font-size计算的</span><br><span class="line">em是相对于父元素的font-size计算的</span><br></pre></td></tr></table></figure></p>
<p><strong>如何清除浮动？ 什么是css样式初始化？为什么要这么做？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">清楚浮动可以通过伪类元素，div clear , overflow等</span><br><span class="line">css样式就是把一些基本的标签的的margin,padding等重设，因为每个浏览器的标准可能不同</span><br></pre></td></tr></table></figure></p>
<p><strong>css选择器的权重都是什么？什么是伪类与伪元素？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&gt;class = 伪类 &gt; 标签 = 伪元素 &gt; 通配符</span><br></pre></td></tr></table></figure></p>
<p><strong>内容超出容器时的默认情况，解决方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内容会依旧显示，不会换行也不会省略。</span><br><span class="line">设置省略overflow，等。</span><br></pre></td></tr></table></figure></p>
<p><strong>line-height带单位和不带单位的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当父元素为150%,1.5em这样时  </span><br><span class="line">会根据父元素的字体大小计算出行高值，再让子元素基础</span><br><span class="line">当父元素为1.5时，没有单位时。</span><br><span class="line">会先根据子元素的字体大小动态计算行高，让子元素继承。</span><br></pre></td></tr></table></figure></p>
<p><strong>什么是盒子模型</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一般分为标准盒子模型和怪异盒子模型</span><br><span class="line">标准盒子模型的width = 元素content</span><br><span class="line">怪异盒子模型的width = 元素content + （padding + border） * 2</span><br></pre></td></tr></table></figure></p>
<p><strong>什么的BFC,什么元素会生成BFC,BFC的布局规则是什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BFC(块级格式化上下文)是一个独立的布局环境,其元素是不受外界影响的。</span><br><span class="line">只要是float值不为none，position不为static和relative的。</span><br><span class="line">display不是inline-block, table-cell, flex, table-caption,inline-flex的</span><br><span class="line">overflow值不为visible的都会生成BFC元素</span><br><span class="line">在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列</span><br></pre></td></tr></table></figure></p>
<p><strong>width与height设置的百分比是相对于谁计算，padding和margin呢</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width和height的百分比是相对于父容器计算</span><br><span class="line">padding和margin是相对于父元素的宽度计算的</span><br></pre></td></tr></table></figure></p>
<p><strong>如何设置一个元素垂直居中</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flex方式</span><br><span class="line">    display: flex justify-content:center; align-items: center;</span><br><span class="line">绝对定位</span><br><span class="line">    父元素 position: absolute;top: 0; bottom: 0; 子元素 margin: auto;</span><br></pre></td></tr></table></figure></p>
<p><strong>display:none和visibilty:hidden的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">display：none属性：</span><br><span class="line">    1. 不为对象保留物理空间</span><br><span class="line">    2. 对象从页面彻底的消失</span><br><span class="line">    3. 浏览器也不会解析此元素</span><br><span class="line">    4. 切换显示时页面会产生回流</span><br><span class="line">visible：hidden属性</span><br><span class="line">    1. 仅仅使元素不可见</span><br><span class="line">    2. 但其物理空间依旧存在类似于透明度为0</span><br><span class="line">    3. 切换显示时不产生回流</span><br><span class="line">    4. 性能较display会更好</span><br></pre></td></tr></table></figure></p>
<p><strong>相对布局和绝对布局,position: relative和absoulte</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">position: absoulte绝对布局</span><br><span class="line">    1. 元素脱离文档流</span><br><span class="line">    2. 会找寻父元素是否有position: relative属性，如果没有会逐级向上找，直到找到body。</span><br><span class="line">    3. 元素是相对于找到的父元素(position: relative 否则 body)定位。</span><br><span class="line">position: relative相对定位</span><br><span class="line">    1. 元素未脱离文档流</span><br><span class="line">    2. 会对文档流中其他元素的结构产生影响，例如子元素是绝对定位</span><br><span class="line">    3. 元素的原本位置依旧保留，视觉空间偏移</span><br></pre></td></tr></table></figure></p>
<p><strong>flex布局</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flex是专门为页面布局而产生的属性，针对于以前使用div+float+postion的布局方式。</span><br><span class="line">flex无疑是简单的很多很多。</span><br><span class="line">flex常用的属性:</span><br><span class="line">display: flex;  flex-wrap;  flex-direction; flex-flow等</span><br></pre></td></tr></table></figure></p>
<p><strong>block,inline-block,inline的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">block块元素</span><br><span class="line">    1. 独占一行，宽度自动填满父元素的宽度</span><br><span class="line">    2. 可以设置宽度高度，即使设置了宽度仍是独占一行</span><br><span class="line">    3. 可以设置padding和margin</span><br><span class="line">inline内联元素</span><br><span class="line">    1. 不独占一行，宽度随内容变化</span><br><span class="line">    2. width和height无效</span><br><span class="line">    3. padding和margin只有水平方向有效果，垂直方向没有效果</span><br><span class="line">inline-block</span><br><span class="line">    1. 是inline和block的结合体</span><br><span class="line">    2. 显示为inline，但是可以设置width,height,padding,margin等block的属性</span><br></pre></td></tr></table></figure></p>
<p><strong>position相关</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">position属性是指定元素在文档中的定位方式</span><br><span class="line">通过top,right,bottom,left来确定元素的位置</span><br><span class="line">定位类型有:static, relative, absolute, fixed ,sticky</span><br><span class="line">    static: 元素默认定位,top,right,left,bottom,z-index属性无效</span><br><span class="line">    relative: 仅仅视觉调整元素位置，而实际位置还在原位，会影响子元素的布局方式(absolute),table相关属性无效。</span><br><span class="line">    absolute: 不为元素预留空间，相对于最近的非static的祖先元素定位，可以设置外边距不和其他static边距重合。</span><br><span class="line">    fixed: 不为元素预留空间，通过屏幕视口(viewport)来指定元素位置,会创建新的层叠上下文,</span><br><span class="line">           当元素的祖先为transform非none时，容器由该视口改为该祖先。</span><br><span class="line">    sticky: 根据正常的static元素布局，相对于(BFC)和最近块元素祖先元素定位。当被粘性定位时，仍按照b未定位的位置定位。</span><br></pre></td></tr></table></figure></p>
<h2 id="JS相关"><a href="#JS相关" class="headerlink" title="JS相关"></a><span style="color:red">JS相关</span></h2><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a><span style="color:blue">跨域</span></h3><p><strong>jsonp的原理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.有src属性的标签都能跨域(img,script,iframe)等</span><br><span class="line">2.所以利用script来实现跨域，因为script只能请求js相关文件，所以需将远程服务器的数据装入js中，供客户端调用。</span><br><span class="line">3.于是json被发现了，它可以简单的描述复杂数据，还被js原生支持。客户端也可以很轻易的处理这种数据。</span><br><span class="line">4.所以客户端像调用脚本一样的，来调用跨域服务器上的js格式文件(json)。</span><br><span class="line">5.这种方式逐渐成为了一种非正式的传输协议，称之为jsonp，主要的特点就是用户需要提交一个callback，然后服务器</span><br><span class="line">   返回数据的时候就会通过这个callback包裹住，这样客户端就可以随心所欲的处理返回的数据。</span><br></pre></td></tr></table></figure></p>
<h3 id="es6相关"><a href="#es6相关" class="headerlink" title="es6相关"></a><span style="color:blue">es6相关</span></h3><p><strong>函数rest参数可以用其他名字替换吗</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rest是获取多余的参数和argument获取全部参数不同</span><br><span class="line">当然可以,</span><br><span class="line">只要形式为...变量名。就可以了</span><br><span class="line">例如 function add(a, ...values)</span><br></pre></td></tr></table></figure></p>
<p><strong>es6了解什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 箭头操作符</span><br><span class="line">2. 类的支持class</span><br><span class="line">3. 对象字面量不用写function 什么的了</span><br><span class="line">4. 字符串模板``这个符号</span><br><span class="line">5. 解构</span><br><span class="line">6. 默认参数值</span><br><span class="line">7. let与const关键字</span><br><span class="line">8. for of值遍历</span><br><span class="line">9. 模块export和import</span><br><span class="line">10. Map和Set</span><br><span class="line">11. Promises异步处理</span><br></pre></td></tr></table></figure></p>
<p><strong>every和some的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">every会测试所有元素是否都通过的函数的检测(&amp;&amp;与运算，所有元素通过才为true)</span><br><span class="line">some会测试某些元素是否通过函数的检测(||或运算，一个通过及为true)</span><br></pre></td></tr></table></figure></p>
<p><strong>call和apply的作用和区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call和apply用来调用函数，并用指定对象（第一个参数）替换函数的 this 值.改变this的指向。</span><br><span class="line">call的参数是一个一个的，而apply是一整个数组。</span><br></pre></td></tr></table></figure></p>
<p><strong>ES6新增的set()和map()有什么区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set一种类似于数组的数据结构，成员都是唯一的没有重复的值。</span><br><span class="line">可以接受的参数是一个数组或者类似数组的对象。</span><br><span class="line">Map是一种&quot;键-值&quot;的Hash结构，键可以由字符串，各种对象构成。</span><br></pre></td></tr></table></figure></p>
<p><strong>es6的symbol</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">symbol是一种新的基础类型，</span><br><span class="line">symbol的存储方式是键值相对，每一个symblo都是独一无二的。</span><br><span class="line">为了避免程序重复的变量而开发出来的。</span><br></pre></td></tr></table></figure></p>
<h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a><span style="color:blue">异步处理</span></h3><p><strong>setTimeout什么时候执行</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout是一个宏任务，所以需要等其他宏任务以及他们的微任务执行完毕了。</span><br><span class="line">才执行setTimeout</span><br></pre></td></tr></table></figure></p>
<p><strong>事件循环</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">事件循环是为了处理异步任务而出现的。</span><br><span class="line">函数执行时的出栈入栈就称为事件循环。</span><br></pre></td></tr></table></figure></p>
<p><strong>ajax和fetch的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ajax是通过XMLHttpRequest实现的。</span><br><span class="line">fetch是window的方法,通过Promise来处理结果</span><br></pre></td></tr></table></figure></p>
<p><strong>ES6异步编程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 回调函数callback,容易产生回调地狱。</span><br><span class="line">2. Promise, 通过then方法加载回调函数，catch捕捉错误，但是then太多就会导致代码混乱。</span><br><span class="line">3. 协程，我没用过不知道，反正可以解决！</span><br><span class="line">4. Gennerator函数,yield, 可以暂停执行和恢复执行，所以能够解决异步。</span><br><span class="line">5. async和await</span><br></pre></td></tr></table></figure></p>
<p><strong>async和await是什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async 函数是什么？一句话，它就是 Generator 函数的语法糖。《ECMAScript 6 入门》</span><br><span class="line">async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</span><br><span class="line">async函数返回一个Promise对象，可以使用then方法添加回调函数，当函数执行的时候，一旦遇到await就会先返回，</span><br><span class="line">等到异步操作完成，再接着执行函数体内后面的语句。 这样就可以以同步的方式书写异步的程序了。</span><br><span class="line"></span><br><span class="line">await命令</span><br><span class="line">await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。</span><br><span class="line">await相当于暂停，并执行之后等待的函数，在执行await的函数</span><br></pre></td></tr></table></figure></p>
<p><strong>promise相关</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise是一种异步编程的解决方案，比传统的回调函数更合理。es提供了原生的Promise对象。</span><br><span class="line">Promise是一个容器，保存着未来才会结束的事件(通常是异步)。</span><br><span class="line">有三种状态,pending(进行中),fulfilled(已经成功),rejected(已经失败)</span><br><span class="line">只有异步操作才能决定当前是哪一种状态。</span><br><span class="line">Promise的构造函数提供了两个参数resolve和reject，</span><br><span class="line">resolve是讲Promise对象的状态从未完成变成完成，reject是将状态从未完成变成失败.</span><br><span class="line">Promise实例生成后会用then方法分别指定resolved状态和rejected状态的回调函数</span><br></pre></td></tr></table></figure></p>
<h3 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a><span style="color:blue">对象和类</span></h3><p><strong>js创建对象的几种方式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字面量</span><br><span class="line">工厂模式</span><br><span class="line">构造函数</span><br><span class="line">原型模式</span><br><span class="line">组合模式</span><br></pre></td></tr></table></figure></p>
<p><strong>继承的几种方式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原型链继承</span><br><span class="line">子类.prototype = new 父类()</span><br><span class="line"></span><br><span class="line">构造函数继承</span><br><span class="line">父类.call(this)</span><br><span class="line"></span><br><span class="line">组合继承</span><br><span class="line">父类.call(this)</span><br><span class="line"></span><br><span class="line">子类.prototype = new 父类()</span><br><span class="line">子类.prototype.constructor = 父类</span><br></pre></td></tr></table></figure></p>
<p><strong>es6的类中 静态属性和构造函数谁先加载 为什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">静态属性先加载，因为构造函数需要等待类的实例生成时才能触发，</span><br><span class="line">而静态属性是加载时便已经存在了。</span><br></pre></td></tr></table></figure></p>
<p><strong>静态属性和方法是类的还是实例的</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态属性和方法是属于类的。</span><br></pre></td></tr></table></figure></p>
<p><strong>怎么在外部调用静态属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.属性名</span><br></pre></td></tr></table></figure></p>
<p><strong>new生成一个对象的过程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建了一个原生对象 例如obj = new Object();</span><br><span class="line">获得对象的构造函数的prototype对象,并赋值给obj的prototype。</span><br><span class="line">call构造函数的内部方法，把其中的this赋值为新创建的对象，并传入参数</span><br><span class="line">执行构造函数,返回创建的对象   return this</span><br></pre></td></tr></table></figure></p>
<p><strong>js基本对象类型和引用对象类型的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基本类型有: string number boolean null undefined</span><br><span class="line">引用类型有: Funtion Array Object</span><br><span class="line"></span><br><span class="line">访问方式</span><br><span class="line">    基本类型，直接操作和访问变量实际的值</span><br><span class="line">    引用类型，值保存在内存中，js不允许直接访问内存，操作的时候时通过对象的引用</span><br><span class="line">存储的位置</span><br><span class="line">    基本类型，保存在栈中</span><br><span class="line">    引用类型，引用存放在栈中，实际对象在堆中</span><br></pre></td></tr></table></figure></p>
<p><strong>js如何实现继承？ES6 class如何实现的继承？与ES5的区别是什么？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js是通过原型链实现继承的</span><br><span class="line">es6 通过关键字 extends 实现继承的，实际还是通过原型链只不过是封装了。</span><br><span class="line">es5是通过原型和构造函数，es6是通过封装的关键字</span><br></pre></td></tr></table></figure></p>
<p><strong>Object和Function的关系</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Object和Function都是构造函数,所有的构造函数都是Function的实例，所以Object是Function的实例。</span><br><span class="line">2. Function.prototype是Object的实例对象。</span><br><span class="line">3. 实例对象的原型(proto)会指向其构造函数的prototype属性，Object.proto === Function.prototype,</span><br><span class="line">    Function.proto === Function.prototype, Funtion.prototype === Object.protoype</span><br><span class="line">4. 当访问一个属性值时，它会沿着原型链向上查找，直到找到或者到Object.prototypr.proto(null)为止。</span><br></pre></td></tr></table></figure></p>
<p><strong>说一下原型链</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js对象是基于原型链的。有原型和原型链的概念。</span><br><span class="line">原型很简单，就是你继承于谁。</span><br><span class="line">js的对象只有__proto__属性，而函数有prototype和__proto__属性。</span><br><span class="line">因为对象和函数都是通过Funtion的构造函数生成的。所以对象的__proto__ 是继承于Funtion的构造函数(prototype)的。</span><br><span class="line">而函数的prototype就是他自己的构造函数(prototype)。函数的__proto__是继承于Object的构造函数(prototype)因为一切都继承于Object</span><br><span class="line">但是Object的__proto__为Null</span><br></pre></td></tr></table></figure></p>
<p><strong>对象和类的区别，具一个例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类是对象的抽象概念，对象是类的具体表达。《PHP核心技术与最佳实践》</span><br><span class="line">类是抽象的，不具体的，一些东西可以归为一类，不占空间的。</span><br><span class="line">对象是具体的，是一个类的具体表达，占空间的。</span><br><span class="line">例如动物是一类，猫，狗就是对象。猫狗是具体存在的，而动物是抽象的。</span><br></pre></td></tr></table></figure></p>
<p><strong>你理解的面向对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">面向对象编程需要抽象的思维，把一些直观的东西需要抽象，但是代码量会大一些。</span><br><span class="line">例如我之前写过一个象棋项目，他就分了很多类，棋子类，棋盘类，规则类等。</span><br><span class="line">如果是面向过程，就不分这么多，直接就写很多函数，完成就OK，但是不好扩展。</span><br><span class="line">面向对象的优势是，扩展性强，复用性好，维护简单。</span><br></pre></td></tr></table></figure></p>
<p><strong>加new和不加的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加new返回构造函数的实例，不加new 如果没有return对象  就是undefined</span><br></pre></td></tr></table></figure></p>
<p><strong>原型链继承</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.prototype = new 要继承的对象()</span><br></pre></td></tr></table></figure></p>
<p><strong>es6 extends</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），</span><br><span class="line">然后再用子类的构造函数修改this。</span><br></pre></td></tr></table></figure></p>
<h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a><span style="color:blue">基本概念</span></h3><p><strong>script标签里面的defer和async</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">都是防止js加载阻塞而出现的。</span><br><span class="line">区别是defer会等dom加载完毕后，按顺序依次执行。</span><br><span class="line">async不会等dom加载完毕后执行，并且加载顺序是谁先加载完毕就执行。</span><br><span class="line">它们和放在&lt;/body&gt;之前的区别就是，它们在外面已经加载好了。 节约了一些时间。</span><br></pre></td></tr></table></figure></p>
<p><strong>web worker</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在Javascript单线程执行的基础上，开启一个子线程，进行程序处理，而不影响主线程的执行，当子线程执行完毕之后再回到主线程上，</span><br><span class="line">在这个过程中并不影响主线程的执行过程。</span><br></pre></td></tr></table></figure></p>
<p><strong>attachEvent和addEventListener的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">兼容不同。</span><br><span class="line">attachEvent支持IE7 IE8</span><br><span class="line">addEventListener支持主流浏览器。</span><br></pre></td></tr></table></figure></p>
<p><strong>匿名函数的作用域</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匿名函数具有全局性，所有通常指向window.</span><br></pre></td></tr></table></figure></p>
<p><strong>事件捕获,事件冒泡,事件委托</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事件的捕获和冒泡都属于事件流</span><br><span class="line">事件捕获是从父元素一层一层的向下捕获直到点击的元素。</span><br><span class="line">事件冒泡是从点击的元素一层一层的向父元素冒泡。</span><br><span class="line">事件委托基于事件冒泡的机制，例如原本在li上点击的事件，可以委托在ul上,委托父级元素执行事件。</span><br></pre></td></tr></table></figure></p>
<p><strong>循环绑定事件问题</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多个作用域绑定同一个闭包，导致变量共享</span><br><span class="line">闭包解决即可。</span><br></pre></td></tr></table></figure></p>
<p><strong>准确的判断js数据类型</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(obj)</span><br></pre></td></tr></table></figure></p>
<p><strong>setInterval与setTimeout的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setInterval会不停的调用函数，从调用开始就周期性的执行</span><br><span class="line">setTimeout只执行一次,是延迟函数</span><br></pre></td></tr></table></figure></p>
<p><strong>js数组有哪些方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">join(),push(),pop(),shift(),unshift(),reverse(),sort()</span><br><span class="line">concat(),slice(),splice()等</span><br></pre></td></tr></table></figure></p>
<p><strong>哪些方法会改变原数组，哪些不改变原数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">改变的方法有</span><br><span class="line">pop(),push(),reverse(),shift(),sort(),splice().unshift()</span><br><span class="line">不改变的方法有</span><br><span class="line">concat(),join(),slice(),toString(),valueOf()</span><br></pre></td></tr></table></figure></p>
<p><strong>数组遍历的方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foreach for in for of ruduce map</span><br></pre></td></tr></table></figure></p>
<p><strong>如何实现闭包</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数里面返回函数即可。</span><br></pre></td></tr></table></figure></p>
<p><strong>js深拷贝和浅拷贝</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果没有循环引用,没有函数。JSON.parse(JSON.stringify(obj))</span><br><span class="line">否则递归，判断当前是否为object。</span><br><span class="line">浅拷贝 Object.assign</span><br></pre></td></tr></table></figure></p>
<p><strong>如何改变this的指向</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call,apply,bind</span><br><span class="line">区别就是call和apply可以看做某个对象的方法，可以通过调用方法的方式来调用此函数</span><br><span class="line">call传一个一个的参数，apply传数组</span><br><span class="line">而bind是将某个函数绑定到某个对象上</span><br></pre></td></tr></table></figure></p>
<p><strong>js文件加载阻塞</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原因</span><br><span class="line">    JavaScript是单线程，所以在运行时其他事情不能被浏览器处理。</span><br><span class="line">而大多数浏览器都是单线程来处理这些业务，所以同一时间，只能执行一个任务。  </span><br><span class="line">这就导致了执行js时，其他页面无法工作。</span><br><span class="line">解决</span><br><span class="line">    1. 老办法，将js放在&lt;/body&gt;前，确定dom已经渲染了，才引入js。</span><br><span class="line">        然而这样还是会阻塞。</span><br><span class="line">    2.  defer和async属性，只针对外联js。</span><br><span class="line">        使用defer的&lt;script&gt;标签是按照他们排列的顺序执行</span><br><span class="line">        而使用async的&lt;script&gt;标签是不按他们在HTML中的排列顺序执行</span><br><span class="line">        这样就解析js时就不会产生阻塞了。</span><br></pre></td></tr></table></figure></p>
<p><strong>问==和===的区别,<code>typeof null</code>是什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==是判断值是否相同，如果类型不同，会自动转化类型，再对比值</span><br><span class="line">===是判断类型和值是否都相同</span><br><span class="line">typeof null的值为object， 一个既是对象，又不是对象的东西</span><br></pre></td></tr></table></figure></p>
<p><strong>变量提升、函数名提升问题，哪些情况会有变量、函数名的提升？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数声明是函数的声明和实现都被提升了。</span><br><span class="line">函数表达式和变量表达式只是其声明被提升了。</span><br><span class="line">函数名和变量名重复时，优先提升函数名.</span><br></pre></td></tr></table></figure></p>
<p><strong>什么是IIFE立即执行函数？如何实现？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">声明的同时立即调用这个函数</span><br><span class="line">(function foo()&#123;</span><br><span class="line">var a = 10;</span><br><span class="line">console.log(a);</span><br><span class="line">&#125;)();</span><br><span class="line">在函数声明后添加一个().</span><br><span class="line">IIFE的目的是为了隔离作用域，防止污染全局命名空间。</span><br></pre></td></tr></table></figure></p>
<p><strong>null和undefined的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null的typeof是object, undefined的typeof就是undefined</span><br><span class="line">null是一个空对象指针，undefined是声明了但是没有初始化</span><br><span class="line">javascript权威指南说，undefined是系统级的值空缺,而null是程序级的值空缺</span><br></pre></td></tr></table></figure></p>
<p><strong>函数柯里化</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一种高阶函数，把参数变为一个一个的传。</span><br><span class="line">直到收到所有参数后才执行。</span><br><span class="line">需要闭包和递归。 应用场景为延迟背景等.</span><br></pre></td></tr></table></figure></p>
<p><strong>服务端渲染</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. seo</span><br><span class="line">2. 首屏加载</span><br></pre></td></tr></table></figure></p>
<p><strong>typeof返回值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number, string, boolean, object, function, undefined, symbol</span><br></pre></td></tr></table></figure></p>
<p><strong>es6用了哪些提高工作效率的特性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">默认参数</span><br><span class="line">模板文本</span><br><span class="line">解构</span><br><span class="line">箭头函数</span><br><span class="line">promises</span><br><span class="line">let const 块作用域</span><br><span class="line">class </span><br><span class="line">modules</span><br></pre></td></tr></table></figure></p>
<p><strong>如何判断一个变量是否是数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. instanceof</span><br><span class="line">2. constructor</span><br><span class="line">3. toString()   Object.prototype.toString.call(arr) === &apos;[object Array]&apos;</span><br></pre></td></tr></table></figure></p>
<p><strong>js的哪些操作会实现隐式转换</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 递增递减</span><br><span class="line">2. 逻辑操作符</span><br><span class="line">3. 关系操作符</span><br><span class="line">4. 相等操作符</span><br></pre></td></tr></table></figure></p>
<p><strong>闭包的原理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">闭包的实现和以下几个原理有关:</span><br><span class="line">变量作用域: 全局变量，全局都能使用，函数内部定义的变量，仅能在函数内部使用。</span><br><span class="line">函数作用域: 在函数内声明的变量，在函数体内始终是可见的。</span><br><span class="line">作用域链: 作用域链式一个对象，它定义了该作用域内的变量，保证作用域的变量函数的访问。</span><br><span class="line">作用域链的创建: 定义一个函数时会保存一个作用域链，调用一个函数时，会创建一个新的对象来存储器局部变量，并添加进保存的作用域链上。</span><br><span class="line">                每次调用函数，都会创建新的作用域链，虽然内部代码相同，但是作用域链是不同的。</span><br><span class="line">垃圾回收机制: js有自动回收垃圾的机制，会定期把不再使用的变量销毁，释放内存。（只会销毁局部变量，全局变量是关闭浏览器时才销毁）</span><br><span class="line">闭包的原理就是： 函数的执行依赖于函数定义的时候的作用域链，所以函数执行的时候用的作用域链是定义时候创建的，但当执行的函数的作用域</span><br><span class="line">                域链和定义的作用域链不同时，就会出现问题！即一个函数嵌套一个函数并返回函数时就会产生闭包的情况。</span><br><span class="line">                当外部函数把嵌套函数作为返回值返回时，其执行结果仍然是局部变量的值，而不是全局变量的值。</span><br><span class="line">                这就是因为函数执行时用到的作用域链，其实是函数定义时创建的。不管该函数在何时何地执行，它通过作用域链最先找到的变量就是相同外部函数中定义的变量</span><br><span class="line">                而闭包正是利用这种特性实现的：闭包可以捕捉到局部变量或参数，并一直保存下来，使其不会被当成垃圾回收。</span><br><span class="line">注意： 如果闭包使用不得当，会导致大量的局部变量没有回收，导致内存泄露！所以看看那些大框架是怎么使用闭包的吧！</span><br></pre></td></tr></table></figure></p>
<p><strong>箭头函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以简化代码.</span><br><span class="line">但是不绑定this,和arguments</span><br></pre></td></tr></table></figure></p>
<p><strong>垃圾回收机制的理解</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">垃圾回收机制是一种自动释放变量的机制。以免变量一直占用内存。</span><br><span class="line">js的垃圾回收机制是，当js检测到一个变量之后不会再使用的时候，就会把它释放。</span><br><span class="line">js的垃圾回收的两种方式，标记清除和引用计数</span><br><span class="line">1. 标记清除</span><br><span class="line">    这是js最常用的回收方式，当变量进入执行环境时，就标记为“进入环境”，</span><br><span class="line">    进入执行环境的变量不能释放，因为他们可能随时用到，当变量离开环境的时候，</span><br><span class="line">    则将其标记为“离开环境”，然后去掉环境中的变量和标记，然后垃圾收集器来搜集。</span><br><span class="line">    例如进入函数，函数里面的标记就变为进入环境，当离开环境后，局部变量就会被回收。</span><br><span class="line">2. 引用计数</span><br><span class="line">    不太常见的回收策略，跟踪每个值被引用的次数，当一个变量已经没有引用类型引用的时候，</span><br><span class="line">    就会把他回收。</span><br><span class="line">    例如a=3，现在a引用的是3，但当a=4的时候，这里的3仍在，并不是被替换。</span><br><span class="line">    而是a引用到4了，此时3已经没有任何变量引用它，它就会被回收了！</span><br></pre></td></tr></table></figure></p>
<p><strong>AMD和commonjs是怎么使用，怎么配置，有什么好处</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两者都是为了实现模块化编程的，</span><br><span class="line">Commonjs是服务端的，比如Node,是同步加载不同模块文件，</span><br><span class="line">ADM是异步模块定义，是适用于浏览器端的模块加载方式，是异步加载的方式，例如ajax</span><br><span class="line">所以浏览器时无法使用Commonjs的模式(除非有四个node环境的变量)</span><br><span class="line">好处就是，有了模块，我们可以更方便的使用别人的代码，想要什么功能，就加载什么模块。</span><br><span class="line">怎么配置？目前还没研究啊!</span><br></pre></td></tr></table></figure></p>
<p><strong>var let const区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var 变量提升，除非在function内，</span><br><span class="line">let 块变量，没有变量提升，未定义前，不能使用</span><br><span class="line">const 块常量， 不能更改值</span><br></pre></td></tr></table></figure></p>
<p><strong>伪数组如何转为数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 遍历</span><br><span class="line">2. Object.prototype.slice.call(array)</span><br><span class="line">3. from</span><br></pre></td></tr></table></figure></p>
<p><strong>foreach和map</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">都不会改变数组，</span><br><span class="line">foreach 只返回callback的参数</span><br><span class="line">map 会创建一个新数组</span><br></pre></td></tr></table></figure></p>
<h2 id="JQ相关"><a href="#JQ相关" class="headerlink" title="JQ相关"></a><span style="color:red">JQ相关</span></h2><p><strong>为什么Jquery只需要$即可生成Jquery对象</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Jquery3.X的源码文件，能够解释一切。</span><br><span class="line">if ( !noGlobal ) &#123;</span><br><span class="line">	window.jQuery = window.$ = jQuery;</span><br><span class="line">&#125;</span><br><span class="line">return jQuery;</span><br><span class="line">&#125; );</span><br><span class="line">所以$() === jQuery()</span><br><span class="line">还是通过构造函数生成的。</span><br></pre></td></tr></table></figure></p>
<p> <strong>既然是构造函数,为什么不用new呢</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Jquery3.X的源码能说明一切</span><br><span class="line">jQuery = function( selector, context ) &#123;</span><br><span class="line">		return new jQuery.fn.init( selector, context );</span><br><span class="line">	&#125;,</span><br><span class="line">执行Jquery后，return一个new的Jquery并且初始化.</span><br><span class="line">没毛病，还是正常的new class。只是巧妙的封装了。</span><br></pre></td></tr></table></figure></p>
<p> <strong>JQ中 $(selector)用原生JavaScript哪个能实现</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">querySelector 选择一个元素</span><br><span class="line">querySelectorAll 选择多个元素</span><br></pre></td></tr></table></figure></p>
<p> <strong>如何元素实现$.on方法</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">元素原型添加一个on方法</span><br><span class="line">Element.prototype.on = function(type,fn)&#123;</span><br><span class="line">    window.addEventListener ? this.addEventListener(type,fn) : this.attachEvent(&apos;on&apos; + type,fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.querySelector(&apos;.aon&apos;).on(&apos;click&apos;,function()&#123;</span><br><span class="line">    alert(this.innerHTML);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p> <strong>jQuery ready原理、window.onload区别</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ready: DOM结构加载完毕,就可执行,可多次执行</span><br><span class="line">onload: 网页必须全部加载完,才能执行,只能执行一次</span><br></pre></td></tr></table></figure></p>
<p> <strong>documnent.ready window.onload谁先执行</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.ready 是dom加载完毕就执行</span><br><span class="line">window.onload 是页面所有资源加载完毕才开始执行</span><br></pre></td></tr></table></figure></p>
<h2 id="VUE相关"><a href="#VUE相关" class="headerlink" title="VUE相关"></a><span style="color:red">VUE相关</span></h2><p><strong>vue的特点</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.MVVM框架，数据双向绑定</span><br><span class="line">2.轻量级的渐进式框架</span><br><span class="line">3.组件单向流通</span><br><span class="line">4.有自己的指令</span><br><span class="line">5.大型单页式的网站</span><br></pre></td></tr></table></figure></p>
<p><strong>vue组件之间的通信</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vue是单向数据通信</span><br><span class="line">父传子 props</span><br><span class="line">子传父 $on, $emit</span><br><span class="line">非父子，可以通过使用一个空的Vue实例作为中央事件总线</span><br></pre></td></tr></table></figure></p>
<p><strong>vue-router 对应的组件状态存在哪儿</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage</span><br></pre></td></tr></table></figure></p>
<p><strong>vue双向数据绑定的原理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue是基于object.defneProperty()属性拦截器实现的</span><br></pre></td></tr></table></figure></p>
<p><strong>vue key的作用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提高列表的渲染速度</span><br><span class="line">标识元素的独立性。</span><br></pre></td></tr></table></figure></p>
<p><strong>vue的生命周期以及每个周期用来干什么的</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate 实例创建前,此时无法读取data、 methods</span><br><span class="line">created 实例创建后，这是已经有了data,属性和方法的运算，watch/event事件等，但是mount还未挂载,数据还未渲染。</span><br><span class="line">beforeMount 挂载开始前，相关的render调用</span><br><span class="line">mounted el的dom节点被vm.$el替换，实例数据在dom上渲染</span><br><span class="line">beforeUpdate 数据更新是调用，不进行dom重新渲染， 在数据更新前可以进行状态处理</span><br><span class="line">updated: 数据更新并且dom渲染，这时dom已经更新，每次数据更新都会执行updated</span><br><span class="line">beforeDestory 实例销毁前调用</span><br><span class="line">destroyed vue实例销毁后调用，vue所有的东西都会被解绑，所有的子实例也会销毁</span><br><span class="line">应用场景</span><br><span class="line">created 异步数据请求，初始化数据</span><br><span class="line">mounted 挂载元素内的dom节点获取</span><br><span class="line">nextTick 针对单一事件更新数据后立即操作dom</span><br><span class="line">updated 任何数据的更新，做同一的业务逻辑处理</span><br><span class="line">watch: 监听数据变化，做出相应的处理</span><br></pre></td></tr></table></figure></p>
<p><strong>vuex包括什么？对action理解的怎么样</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vuex是各个组件的状态管理器，也成为前端数据库吧。</span><br><span class="line">state: 状态的数据结构</span><br><span class="line">actions: 从服务端获取数据，（异步）调用commit来改变状态</span><br><span class="line">mutations: 唯一能改变状态的地方</span><br><span class="line">getters: 组件获取状态器的数据，需通过这里。</span><br><span class="line">modules: 一个store可以拆分为多个，每个都有自己的state,actions等</span><br><span class="line">actions我一般用来获取服务器的数据，更新，因为mutations是同步的，不行，而actions是异步的。</span><br></pre></td></tr></table></figure></p>
<p><strong>axios的原理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios是基于Promise的HTTP库</span><br><span class="line">请求还是通过XMLHttpRequest对象实现的</span><br></pre></td></tr></table></figure></p>
<p><strong>vuex解决的问题是什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.多个组件共享状态时，单向数据流的简洁性很容易被破坏：</span><br><span class="line">2.多个视图依赖于同一状态。</span><br><span class="line">3.来自不同视图的行为需要变更同一状态。</span><br></pre></td></tr></table></figure></p>
<h2 id="网络原理相关"><a href="#网络原理相关" class="headerlink" title="网络原理相关"></a><span style="color:red">网络原理相关</span></h2><p><strong>http和https的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP：超文本传输协议，明文传输，连接端口是80。    </span><br><span class="line">HTTPS：加密传输，是Http+ssl(安全套接字)协议构建的，端口是443，需要申请ca证书。</span><br></pre></td></tr></table></figure></p>
<p><strong>浏览器输入网址到页面渲染全过程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">其实原理挺复杂的，各方各面都有涉及，就写简约一点。</span><br><span class="line">    1. 浏览器把输入的域名进行dns解析，得到ip地址。</span><br><span class="line">    2. 通过ip和arp地址找到目标服务器地址。</span><br><span class="line">    3. 进行tcp连接。</span><br><span class="line">    4. 浏览器发送请求，等待响应。</span><br><span class="line">    5. 服务器处理请求，开始响应。</span><br><span class="line">    6. 浏览器收到响应，得到html代码。</span><br><span class="line">    7. 渲染页面。</span><br></pre></td></tr></table></figure></p>
<p><strong>HTTP头部</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">accept 客户端可以接受的MIME类型</span><br><span class="line">Cache-Control 缓存 </span><br><span class="line">content-type 请求中的媒体类型 </span><br><span class="line">referer 告诉服务器url的地址 </span><br><span class="line">cookie</span><br><span class="line">Connection 连接</span><br></pre></td></tr></table></figure></p>
<p><strong>HTTP1.0 HTTP1.1 HTTP2.0的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Http1.0和1.1的区别主要是长连接，HOST虚拟站点</span><br><span class="line">Http1.1和2.0的区别主要是服务器推送,加密传输,二进制格式,多路复用</span><br></pre></td></tr></table></figure></p>
<p><strong>HTTP常见状态码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">200 请求成功</span><br><span class="line">301 资源已经转移了</span><br><span class="line">302 请求的网页被重定向到新的地址</span><br><span class="line">304 请求成功，但是文档并没有改变</span><br><span class="line">401 用户验证</span><br><span class="line">403 服务器接受请求，但是拒绝处理</span><br><span class="line">404 找不到资源</span><br><span class="line">500 服务器内部错误</span><br></pre></td></tr></table></figure></p>
<p><strong>HTTP 参数放在header和body的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header一般放cookie等信息</span><br><span class="line">body是放post的数据</span><br><span class="line">header不够安全</span><br></pre></td></tr></table></figure></p>
<p><strong>HTTP和SOCKET的区别,为什么SOCKET更快</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP是一个协议, 短链接</span><br><span class="line">Socket是一个套接字接口, 长连接</span><br><span class="line">因为Socket不用反复请求了。</span><br></pre></td></tr></table></figure></p>
<p><strong>状态码304</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，</span><br><span class="line">则服务器应当返回这个304状态码。简单的表达就是：客户端已经执行了GET，但文件未变化。</span><br></pre></td></tr></table></figure></p>
<p><strong>TCP和UDP的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TCP是面向连接的传输方式(三次握手),UDP是非连接的传输方式</span><br><span class="line">TCP的数据按序到达，不错误，不丢失，不重复，UDP尽最大努力交付，不保证可靠。</span><br><span class="line">TCP面向字节流，UDP面向报文</span><br><span class="line">TCP是点对点，UDP支持一对一，一对多，多对一，多对多 </span><br><span class="line">TCP是全双工的可靠信道，UDP是不可靠信道</span><br><span class="line">TCP首部开销20字节，UDP首部开销8字节</span><br></pre></td></tr></table></figure></p>
<p> <strong>CDN是什么</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内容分发系统,会实时根据网络状态，负载节点等各种情况，找到用户最优的节点。</span><br><span class="line">提高用户访问的响应速度。</span><br></pre></td></tr></table></figure></p>
<p> <strong>web socket</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为了解决服务端向客户端发起请求，而出现的（轮询并不好）。</span><br><span class="line">是一种服务器推送技术，客户端和服务器都可以互相发生信息</span><br></pre></td></tr></table></figure></p>
<p> <strong>工作在各个层的协议</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">物理层: RJ45 CLOCK IEEE802.3(中继器, 集线器, 网关)</span><br><span class="line">链路层: PPP FR HDLC VLAN MAC(网桥, 交换机)</span><br><span class="line">网络层: IP ICMP ARP RARP OSPF IPX RIP IGRP(路由器)</span><br><span class="line">传输层: TCP(三次握手可靠传输) UDP(非连接传输) SPX</span><br><span class="line">会话层: NFS SQL NETBIOS RPC</span><br><span class="line">表示层: JPEG MPEG ASII</span><br><span class="line">应用层: FTP DNS TELNET SMTP HTTP WWW NFS</span><br></pre></td></tr></table></figure></p>
<p><strong>四次挥手的time-wait</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了获取到最后一个报文。</span><br></pre></td></tr></table></figure></p>
<p><strong>XSS脚本攻击</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">防御， 不然用户输入javascript，特殊字符转义等。</span><br></pre></td></tr></table></figure></p>
<p><strong>CSRF</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过冒充网站信任的用户，来入侵系统。</span><br><span class="line">加双cookie？</span><br></pre></td></tr></table></figure></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><span style="color:red">其他</span></h2><p><strong>首屏加载优化</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 除了首屏的图片，其他的图片都采用懒加载。</span><br><span class="line">2. 其他的和上面前端优化差不多</span><br><span class="line">3. 其实我也听说过一种叫做服务端渲染的技术，SSR？</span><br></pre></td></tr></table></figure></p>
<p><strong>排序算法有哪些</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，</span><br><span class="line">而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</span><br><span class="line">主要是内部排序</span><br><span class="line">直接插入排序(稳定)：设置标兵，标兵是前n个元素中最大(小)的元素，后面的与之相比较，大(小)则交换。</span><br><span class="line">希尔排序(不稳定)：减少增量排序，按数组增量分组。例如增量为2[2,3,1,4]分为[2,1][3,4]分别排序，然后合并。</span><br><span class="line">简单选择排序(不稳定)：每一轮选择第n大的数字与第n个位置交换。(例如最大的数位置和第一个位置交换);</span><br><span class="line">堆排序(不稳定)：将数组排列成堆，每个元素都与堆顶元素比较，将堆顶元素沉入堆底，重复操作即可。</span><br><span class="line">冒泡排序(稳定)：相邻元素第一个比第二个元素大(小)就交换，每一对比较，一轮下来最大最小就会在最后。比完即可。</span><br><span class="line">快速排序(不稳定)：左指针右指针和一个基数，左右指针重合的时候两边分别比基数大和基数小，然后再循环以上步骤即可。</span><br><span class="line">归并排序(稳定)：分治法，数组对半拆分直到不可分，然后逐渐合并排序，即可。</span><br><span class="line">桶排序(稳定)：把数组分在各个子区间，然后各个子区间分别排序，最后合并排序，即可。</span><br><span class="line">基数排序(稳定)：桶排序的扩展，将整数按位数切割排序，不足补0。即可。</span><br></pre></td></tr></table></figure></p>
<p><strong>MD5 和SHA-1的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">都是MD4发展来的。</span><br><span class="line">SHA的摘要比MD5多32比特.速度比MD5慢。</span><br></pre></td></tr></table></figure></p>
<p><strong>前端性能优化</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 减少Http请求（图片绘制成一张，然后客户端拆分）</span><br><span class="line">2. 使用CDN</span><br><span class="line">3. 添加Expires头,缓存组件</span><br><span class="line">4. 压缩组件，gzip什么的</span><br><span class="line">5. 样式表放在头部(避免白屏)</span><br><span class="line">6. 脚本放在底部（避免阻塞）</span><br><span class="line">7. 使用外部js和css，因为浏览器可能会缓存它们</span><br><span class="line">8. 避免css表达式</span><br><span class="line">9. 精简js和css代码</span><br><span class="line">10. 减少iframe的个数</span><br><span class="line">11. 预加载，延迟加载的合理应用。</span><br></pre></td></tr></table></figure></p>
<p><strong>MVVM和MVC的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MVVM是将&quot;数据模型数据双向绑定&quot;的思想作为核心，因此View和Model没有联系，通过ViewModel进行交互。  </span><br><span class="line">因此试图变化的数据会修改数据源，而数据源的变化也会反应到视图上。</span><br><span class="line">MVC还是传统的方式，只是逻辑分离了。用户操作视图(view0，反应到控制器(业务逻辑)，控制器调用模型(数据持久化)，最后反馈到视图。</span><br></pre></td></tr></table></figure></p>
<p><strong>模块化和组件化的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">组件则包含了 template、style 和 script，而它的 Script 可以由各种模块组成。</span><br><span class="line">组件化就是做一个知乎，把导航栏拆成一个组件，一个一个回答区域拆成一个组件，编辑区是一个组件，页脚是一个组件</span><br><span class="line">包含了html、css、js代码，可以简单理解为页面的一块。 </span><br><span class="line"></span><br><span class="line">Module模式的基本特征：</span><br><span class="line">模块化，可重用</span><br><span class="line">封装了变量和function，和全局的namaspace不接触，松耦合</span><br><span class="line">只暴露可用public的方法，其它私有方法全部隐藏</span><br></pre></td></tr></table></figure></p>
<p><strong>DNS查询过程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hosts静态文件查询</span><br><span class="line">本地(域)服务器查找</span><br><span class="line">顶级域服务器查找</span><br><span class="line">在顶级域服务器向下查找</span><br></pre></td></tr></table></figure></p>
<p><strong>进程和线程的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程是资源分配的基本单位，线程是任务执行的最小单位。</span><br><span class="line">一个线程只能附属于一个进程，一个进程有多个线程。</span><br><span class="line">并发的最小单位是多进程。多线程允许一个进程同一时刻执行多个任务。</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>前途漫漫，耐心等待。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/前端/" rel="tag"># 前端</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/10/TP5源码分析之Db类实现/" rel="next" title="TP5源码分析之Db类实现">
                <i class="fa fa-chevron-left"></i> TP5源码分析之Db类实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/16/阿里巴巴一面面经/" rel="prev" title="阿里巴巴一面面经">
                阿里巴巴一面面经 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  
    <div class="comments" id="comments">
      <div id="SOHUCS"></div>
    </div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="余鸿靖" />
            
              <p class="site-author-name" itemprop="name">余鸿靖</p>
              <p class="site-description motion-element" itemprop="description">个人文章</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">51</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yuhongjing" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#知识点"><span class="nav-number">2.</span> <span class="nav-text">知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器H5相关"><span class="nav-number">2.1.</span> <span class="nav-text">浏览器H5相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS相关"><span class="nav-number">2.2.</span> <span class="nav-text">CSS相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#布局"><span class="nav-number">2.2.1.</span> <span class="nav-text">布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移动端适应"><span class="nav-number">2.2.2.</span> <span class="nav-text">移动端适应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动画"><span class="nav-number">2.2.3.</span> <span class="nav-text">动画</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">2.2.4.</span> <span class="nav-text">基本概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS相关"><span class="nav-number">2.3.</span> <span class="nav-text">JS相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#跨域"><span class="nav-number">2.3.1.</span> <span class="nav-text">跨域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#es6相关"><span class="nav-number">2.3.2.</span> <span class="nav-text">es6相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步处理"><span class="nav-number">2.3.3.</span> <span class="nav-text">异步处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象和类"><span class="nav-number">2.3.4.</span> <span class="nav-text">对象和类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念-1"><span class="nav-number">2.3.5.</span> <span class="nav-text">基本概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JQ相关"><span class="nav-number">2.4.</span> <span class="nav-text">JQ相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VUE相关"><span class="nav-number">2.5.</span> <span class="nav-text">VUE相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络原理相关"><span class="nav-number">2.6.</span> <span class="nav-text">网络原理相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">2.7.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">余鸿靖</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>
  <div>
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  本站总访问量 <span id="busuanzi_value_site_pv"></span> 次&nbsp&nbsp&nbsp
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
  </div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  




  
    <script type="text/javascript">
    (function(){
      var appid = 'cytCyhAyu';
      var conf = '285cc914d652d41d6d42f4df495436f1';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){
        window.changyan.api.config({appid:appid,conf:conf})});
      }
    })();
    </script>
    <script type="text/javascript" src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>
  





  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  



  
  <script type="text/javascript"
  color="0,0,255" opacity='0.5' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
