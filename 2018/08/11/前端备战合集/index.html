<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-cn">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="前端" />










<meta name="description" content="前言加油，为了更好的明天，前端备战！！！！！">
<meta name="keywords" content="前端">
<meta property="og:type" content="article">
<meta property="og:title" content="前端备战合集">
<meta property="og:url" content="https://yuhongjing.github.io/2018/08/11/前端备战合集/index.html">
<meta property="og:site_name" content="余鸿靖博客">
<meta property="og:description" content="前言加油，为了更好的明天，前端备战！！！！！">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2018-08-27T13:44:21.275Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端备战合集">
<meta name="twitter:description" content="前言加油，为了更好的明天，前端备战！！！！！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yuhongjing.github.io/2018/08/11/前端备战合集/"/>





  <title>前端备战合集 | 余鸿靖博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-cn">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余鸿靖博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一个菜鸟程序员的小空间</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yuhongjing.github.io/2018/08/11/前端备战合集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="余鸿靖">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余鸿靖博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端备战合集</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-11T11:28:44+08:00">
                2018-08-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/备战系列/" itemprop="url" rel="index">
                    <span itemprop="name">备战系列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/11/前端备战合集/#SOHUCS" itemprop="discussionUrl">
                  <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2018/08/11/前端备战合集/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,881 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  34 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>加油，为了更好的明天，前端备战！！！！！<br><a id="more"></a></p>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>下面的资料是所有前端资料的整合</p>
<h2 id="HTML相关"><a href="#HTML相关" class="headerlink" title="HTML相关"></a>HTML相关</h2><p><strong>事件捕获,事件冒泡,事件委托</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">事件捕获是从父元素一层一层的向下捕获直到点击的元素。</span><br><span class="line">事件冒泡是从点击的元素一层一层的向父元素冒泡。</span><br><span class="line">事件委托基于事件冒泡的机制，例如原本在li上点击的事件，可以委托在ul上,委托父级元素执行事件。</span><br></pre></td></tr></table></figure></p>
<p><strong>h5的存储方式有哪些</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cookie 4kb </span><br><span class="line">localstorage 键值匹配 永久存储 5M</span><br><span class="line">sessionstorage 和localstorage差不多，不过（浏览器）关闭就清除了</span><br><span class="line">application cache（离线缓存） 配置mainfest</span><br><span class="line">indexedDB（索引数据库）</span><br></pre></td></tr></table></figure></p>
<p> <strong>xmlHttpRequest原理，跨域，带cookie</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">原理</span><br><span class="line">    XMLHTTPRequest对象向服务器发送请求和解析服务器响应提供了流畅的接口，</span><br><span class="line">    能够以异步方式从服务器府区区获取更多信息而不必刷新页面。</span><br><span class="line">跨域</span><br><span class="line">    如果是get方式，就用jsonp，</span><br><span class="line">    否则就是CORS，需要在服务器设置响应头Access-Control-Allow-Origin</span><br><span class="line"> 携带cookie</span><br><span class="line">    一般是无法携带的，不过可以通过CORS的方式实现</span><br><span class="line">    前端请求</span><br><span class="line">      xhrFields: &#123;</span><br><span class="line">          withCredentials: true</span><br><span class="line">       &#125;</span><br><span class="line">     后端响应</span><br><span class="line">     Access-Control-Allow-Credentials&quot;, &quot;true&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="CSS相关"><a href="#CSS相关" class="headerlink" title="CSS相关"></a>CSS相关</h2><p><strong>移动端适配方案有哪些</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media媒体查询</span><br><span class="line">rem</span><br><span class="line">vw vh</span><br></pre></td></tr></table></figure></p>
<p><strong>vw vh 1vw等于多少</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vw是视窗宽度</span><br><span class="line">vh是视窗高度</span><br><span class="line">1vw是视窗宽度的1%;</span><br></pre></td></tr></table></figure></p>
<p><strong>rem是什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rem是根据html的font-size大小来变化，</span><br><span class="line">一种是可以通过js来调整HTML的字号 </span><br><span class="line">一种是通过媒体查询</span><br></pre></td></tr></table></figure></p>
<p> <strong>transition和animation有什么区别</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transition是过渡动画, 只能指定   起始状态和结束状态，需要由动作(hover)来触发执行， 作用就是平滑的改变css值</span><br><span class="line">animation是动画，有多个关键帧设置，可以自己执行，</span><br></pre></td></tr></table></figure></p>
<p> <strong>两边宽度固定，中间自适应的布局</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">圣杯布局和双飞燕布局都是两边栏固定，中间自适应的布局，还有flex也是可以解决的。</span><br><span class="line">/*圣杯布局*/</span><br><span class="line">*********************CSS********************* </span><br><span class="line">    .container &#123;</span><br><span class="line">        padding: 0 300px 0 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .left, .main, .right &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        min-height: 130px;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .left &#123;</span><br><span class="line">        left: -200px;</span><br><span class="line">        margin-left: -100%;</span><br><span class="line">        background: green;</span><br><span class="line">        width: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .right &#123;</span><br><span class="line">        right: -300px;</span><br><span class="line">        margin-left: -300px;</span><br><span class="line">        background-color: red;</span><br><span class="line">        width: 300px;</span><br><span class="line">    &#125;</span><br><span class="line">    .main &#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">        width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">*************HTML*******************</span><br><span class="line">&lt;div class=&quot;container&quot;&gt; </span><br><span class="line">　　&lt;div class=&quot;main&quot;&gt;main&lt;/div&gt; </span><br><span class="line">　　&lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; </span><br><span class="line">　　&lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">可以看到圣杯布局主要是通过相对定位,float浮动和margin为负完成的.</span><br><span class="line">/*双飞燕布局*/</span><br><span class="line">*****************************CSS*********************</span><br><span class="line">.left, .main, .right &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    min-height: 130px;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">    margin-left: -100%;</span><br><span class="line">    background: green;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right &#123;</span><br><span class="line">    margin-left: -300px;</span><br><span class="line">    background-color: red;</span><br><span class="line">    width: 300px;</span><br><span class="line">&#125;</span><br><span class="line">.main &#123;</span><br><span class="line">    background-color: blue;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.content&#123;</span><br><span class="line">    margin: 0 300px 0 200px;</span><br><span class="line">&#125;</span><br><span class="line">***************HTML****************</span><br><span class="line">&lt;div class=&quot;container&quot;&gt; </span><br><span class="line">　　&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">　　&lt;div class=&quot;content&quot;&gt;main&lt;/div&gt; </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">　　&lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; </span><br><span class="line">　　&lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">通过多一个div,就可以不用相对定位等css属性了，算是一种简化版</span><br><span class="line">/*Flex布局*/</span><br><span class="line">*****************CSS**********************</span><br><span class="line">.container&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    min-height: 130px;</span><br><span class="line">&#125;</span><br><span class="line">.main&#123;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">    background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    order: -1;</span><br><span class="line">    flex-basis: 200px;</span><br><span class="line">    background-color: green;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    flex-basis: 300px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">*****************HTML*****************</span><br><span class="line">&lt;div class=&quot;container&quot;&gt; </span><br><span class="line">　　&lt;div class=&quot;main&quot;&gt;main&lt;/div&gt; </span><br><span class="line">　　&lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; </span><br><span class="line">　　&lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">Flex弹性布局，就很轻松了</span><br></pre></td></tr></table></figure></p>
<p> <strong>box-sizing是什么</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">改变盒子模型，例如怪异模型和标准模型，改变盒子的计算尺寸方式。</span><br></pre></td></tr></table></figure></p>
<p> <strong>rem与em了解吗？分别是相对于谁来计算的？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rem相对于html的font-size计算的</span><br><span class="line">em是相对于父元素的font-size计算的</span><br></pre></td></tr></table></figure></p>
<p><strong>了解移动端的适配吗？请问什么是rem布局？在移动端的1px问题该如何解决。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rem布局是通过js来计算rem的值，来适配不同的移动端</span><br><span class="line">移动端的1px问题主要是逻辑像素和物理像素需要1对1 </span><br><span class="line">通过meta标签的viewport的属性设置能够完成</span><br></pre></td></tr></table></figure></p>
<p><strong>对于css3的transform有了解吗？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关于元素的形变元素，有旋转，放大，缩小等</span><br></pre></td></tr></table></figure></p>
<p><strong>对于css3的动画有了解吗？必填属性有哪些？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation属性，@keyframes</span><br></pre></td></tr></table></figure></p>
<p><strong>在实现一个div移动的动画，使用translate、top（代指定位）、margin之间有什么性能上的不同？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">渲染相关吧，margin会重新渲染dom</span><br></pre></td></tr></table></figure></p>
<p><strong>如何清除浮动？ 什么是css样式初始化？为什么要这么做？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">清楚浮动可以通过伪类选择器，div clear , overflow等</span><br><span class="line">css样式就是把一些基本的标签的的margin,padding等重设，因为每个浏览器的标准可能不同</span><br></pre></td></tr></table></figure></p>
<p><strong>css选择器的权重都是什么？什么是伪类与伪元素？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&gt;class = 伪类 &gt; 标签 = 伪元素 &gt; 通配符</span><br></pre></td></tr></table></figure></p>
<p><strong>什么是盒子模型</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一般分为标准盒子模型和怪异盒子模型</span><br><span class="line">标准盒子模型的width = 元素content</span><br><span class="line">怪异盒子模型的width = 元素content + （padding + border） * 2</span><br></pre></td></tr></table></figure></p>
<p><strong>什么的BFC,什么元素会生成BFC,BFC的布局规则是什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BFC(块级格式化上下文)是一个独立的布局环境,其元素是不受外界影响的。</span><br><span class="line">只要是float值不为none，position不为static和relative的。</span><br><span class="line">display不是inline-block, table-cell, flex, table-caption,inline-flex的</span><br><span class="line">overflow值不为visible的都会生成BFC元素</span><br><span class="line">在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列</span><br></pre></td></tr></table></figure></p>
<p><strong>width与height设置的百分比是相对于谁计算，padding和margin呢</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width和height的百分比是相对于父容器计算</span><br><span class="line">padding和margin是相对于父元素的宽度计算的</span><br></pre></td></tr></table></figure></p>
<p><strong>如何设置一个元素垂直居中</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flex方式</span><br><span class="line">    父元素 display: flex 子元素 margin: auto</span><br><span class="line">绝对定位</span><br><span class="line">    父元素 position: absolute;top: 0; bottom: 0; 子元素 margin: auto;</span><br></pre></td></tr></table></figure></p>
<p><strong>CSS响应式布局</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">响应式网站是指一个网站能兼容多个终端！</span><br><span class="line">1.@media的方式进行响应式布局</span><br><span class="line">2.flex流式布局也是可以的</span><br></pre></td></tr></table></figure></p>
<p><strong>display:none和visibilty:hidden的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">display：none属性：</span><br><span class="line">    1. 不为对象保留物理空间</span><br><span class="line">    2. 对象从页面彻底的消失</span><br><span class="line">    3. 浏览器也不会解析此元素</span><br><span class="line">    4. 切换显示时页面会产生回流</span><br><span class="line">visible：hidden属性</span><br><span class="line">    1. 仅仅使元素不可见</span><br><span class="line">    2. 但其物理空间依旧存在类似于透明度为0</span><br><span class="line">    3. 切换显示时不产生回流</span><br><span class="line">    4. 性能较display会更好</span><br></pre></td></tr></table></figure></p>
<p><strong>相对布局和绝对布局,position: relative和absoulte</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">position: absoulte绝对布局</span><br><span class="line">    1. 元素脱离文档流</span><br><span class="line">    2. 会找寻父元素是否有position: relative属性，如果没有会逐级向上找，直到找到body。</span><br><span class="line">    3. 元素是相对于找到的父元素(position: relative 否则 body)定位。</span><br><span class="line">position: relative相对定位</span><br><span class="line">    1. 元素未脱离文档流</span><br><span class="line">    2. 会对文档流中其他元素的结构产生影响，例如子元素是绝对定位</span><br><span class="line">    3. 元素的原本位置依旧保留，视觉空间偏移</span><br></pre></td></tr></table></figure></p>
<p><strong>flex布局</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flex是专门为页面布局而产生的属性，针对于以前使用div+float+postion的布局方式。</span><br><span class="line">flex无疑是简单的很多很多。</span><br><span class="line">flex常用的属性:</span><br><span class="line">display: flex;  flex-wrap;  flex-direction; flex-flow等</span><br></pre></td></tr></table></figure></p>
<p><strong>block,inline-block,inline的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">block块元素</span><br><span class="line">    1. 独占一行，宽度自动填满父元素的宽度</span><br><span class="line">    2. 可以设置宽度高度，即使设置了宽度仍是独占一行</span><br><span class="line">    3. 可以设置padding和margin</span><br><span class="line">inline内联元素</span><br><span class="line">    1. 不独占一行，宽度随内容变化</span><br><span class="line">    2. width和height无效</span><br><span class="line">    3. padding和margin只有水平方向有效果，垂直方向没有效果</span><br><span class="line">inline-block</span><br><span class="line">    1. 是inline和block的结合体</span><br><span class="line">    2. 显示为inline，但是可以设置width,height,padding,margin等block的属性</span><br></pre></td></tr></table></figure></p>
<p><strong>position相关</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">position属性是指定元素在文档中的定位方式</span><br><span class="line">通过top,right,bottom,left来确定元素的位置</span><br><span class="line">定位类型有:static, relative, absolute, fixed ,sticky</span><br><span class="line">    static: 元素默认定位,top,right,left,bottom,z-index属性无效</span><br><span class="line">    relative: 仅仅视觉调整元素位置，而实际位置还在原位，会影响子元素的布局方式(absolute),table相关属性无效。</span><br><span class="line">    absolute: 不为元素预留空间，相对于最近的非static的祖先元素定位，可以设置外边距不和其他static边距重合。</span><br><span class="line">    fixed: 不为元素预留空间，通过屏幕视口(viewport)来指定元素位置,会创建新的层叠上下文,</span><br><span class="line">           当元素的祖先为transform非none时，容器由该视口改为该祖先。</span><br><span class="line">    sticky: 根据正常的static元素布局，相对于(BFC)和最近块元素祖先元素定位。当被粘性定位时，仍按照b未定位的位置定位。</span><br></pre></td></tr></table></figure></p>
<h2 id="JS相关"><a href="#JS相关" class="headerlink" title="JS相关"></a>JS相关</h2><p><strong>es6的类中 静态属性和构造函数谁先加载 为什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">静态属性先加载，因为构造函数需要等待类的实例生成时才能触发，</span><br><span class="line">而静态属性是加载时便已经存在了。</span><br></pre></td></tr></table></figure></p>
<p><strong>静态属性和方法是类的还是实例的</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态属性和方法是属于类的。</span><br></pre></td></tr></table></figure></p>
<p><strong>怎么在外部调用静态属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.属性名</span><br></pre></td></tr></table></figure></p>
<p> <strong>函数rest参数可以用其他名字替换吗</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rest是获取多余的参数和argument获取全部参数不同</span><br><span class="line">当然可以,</span><br><span class="line">只要形式为...变量名。就可以了</span><br><span class="line">例如 function add(a, ...values)</span><br></pre></td></tr></table></figure></p>
<p><strong>准确的判断js数据类型</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(obj)</span><br></pre></td></tr></table></figure></p>
<p><strong>new生成一个对象的过程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建了一个原生对象 例如obj = new Object();</span><br><span class="line">获得对象的构造函数的prototype对象,并赋值给obj的prototype。</span><br><span class="line">call构造函数的内部方法，把其中的this赋值为新创建的对象，并传入参数</span><br><span class="line">执行构造函数,返回创建的对象   return this</span><br></pre></td></tr></table></figure></p>
<p><strong>es6了解什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 箭头操作符</span><br><span class="line">2. 类的支持class</span><br><span class="line">3. 对象字面量不用写function 什么的了</span><br><span class="line">4. 字符串模板``这个符号</span><br><span class="line">5. 解构</span><br><span class="line">6. 默认参数值</span><br><span class="line">7. let与const关键字</span><br><span class="line">8. for of值遍历</span><br><span class="line">9. 模块export和import</span><br><span class="line">10. Map和Set</span><br><span class="line">11. Promises异步处理</span><br></pre></td></tr></table></figure></p>
<p><strong>setTimeout什么时候执行</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其他非延迟函数都执行完毕后，就执行setTimeout</span><br></pre></td></tr></table></figure></p>
<p><strong>async和await是什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async 函数是什么？一句话，它就是 Generator 函数的语法糖。《ECMAScript 6 入门》</span><br><span class="line">async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</span><br><span class="line">async函数返回一个Promise对象，可以使用then方法添加回调函数，当函数执行的时候，一旦遇到await就会先返回，</span><br><span class="line">等到异步操作完成，再接着执行函数体内后面的语句。 这样就可以以同步的方式书写异步的程序了。</span><br><span class="line"></span><br><span class="line">await命令</span><br><span class="line">await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。</span><br><span class="line">await相当于暂停，并执行之后等待的函数，在执行await的函数</span><br></pre></td></tr></table></figure></p>
<p><strong>事件循环</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主线程读取js代码, 形成相应的堆和执行栈, 执行同步任务</span><br><span class="line">当主线程遇到异步任务,，指定给异步进程处理, 同时继续执行同步任务</span><br><span class="line">当异步进程处理完毕后， 将相应的异步任务推入到任务队列首部</span><br><span class="line">主线程任务处理完毕后,，查询任务队列，则取出一个任务队列推入到主线程的执行栈</span><br><span class="line">重复执行第2、3、4步，这就称为事件循环</span><br></pre></td></tr></table></figure></p>
<p><strong>js数组有哪些方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">join(),push(),pop(),shift(),unshift(),reverse(),sort()</span><br><span class="line">concat(),slice(),splice()等</span><br></pre></td></tr></table></figure></p>
<p><strong>哪些方法会改变原数组，哪些不改变原数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">改变的方法有</span><br><span class="line">pop(),push(),reverse(),shift(),sort(),splice().unshift()</span><br><span class="line">不改变的方法有</span><br><span class="line">concat(),join(),slice(),toString(),valueOf()</span><br></pre></td></tr></table></figure></p>
<p><strong>every和some的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">every会测试所有元素是否都通过的函数的检测(&amp;&amp;与运算，所有元素通过才为true)</span><br><span class="line">some会测试某些元素是否通过函数的检测(||或运算，一个通过及为true)</span><br></pre></td></tr></table></figure></p>
<p><strong>promise相关</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise是一种异步编程的解决方案，比传统的回调函数更合理。es提供了原生的Promise对象。</span><br><span class="line">Promise是一个容器，保存着未来才会结束的事件(通常是异步)。</span><br><span class="line">有三种状态,pending(进行中),fulfilled(已经成功),rejected(已经失败)</span><br><span class="line">只有异步操作才能决定当前是哪一种状态。</span><br><span class="line">Promise的构造函数提供了两个参数resolve和reject，</span><br><span class="line">resolve是讲Promise对象的状态从未完成变成完成，reject是将状态从未完成变成失败.</span><br><span class="line">Promise实例生成后会用then方法分别指定resolved状态和rejected状态的回调函数</span><br></pre></td></tr></table></figure></p>
<p><strong>如何实现闭包</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数里面返回函数即可。</span><br></pre></td></tr></table></figure></p>
<p><strong>call和apply的作用和区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call和apply用来调用函数，并用指定对象（第一个参数）替换函数的 this 值.改变this的指向。</span><br><span class="line">call的参数是一个一个的，而apply是一整个数组。</span><br></pre></td></tr></table></figure></p>
<p><strong>ES6新增的set()和map()有什么区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set一种类似于数组的数据结构，成员都是唯一的没有重复的值。</span><br><span class="line">可以接受的参数是一个数组或者类似数组的对象。</span><br><span class="line">Map是一种&quot;键-值&quot;的Hash结构，键可以由字符串，各种对象构成。</span><br></pre></td></tr></table></figure></p>
<p><strong>js深拷贝</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果没有循环引用的话。</span><br><span class="line">JSON.parse(JSON.stringify(obj))</span><br></pre></td></tr></table></figure></p>
<p><strong>如何改变this的指向</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call,apply,bind</span><br><span class="line">区别就是call和apply可以看做某个对象的方法，可以通过调用方法的方式来调用此函数</span><br><span class="line">call传一个一个的参数，apply传数组</span><br><span class="line">而bind是将某个函数绑定到某个对象上</span><br></pre></td></tr></table></figure></p>
<p><strong>js文件加载阻塞</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原因</span><br><span class="line">    JavaScript是单线程，所以在运行时其他事情不能被浏览器处理。</span><br><span class="line">而大多数浏览器都是单线程来处理这些业务，所以同一时间，只能执行一个任务。  </span><br><span class="line">这就导致了执行js时，其他页面无法工作。</span><br><span class="line">解决</span><br><span class="line">    1. 老办法，将js放在&lt;/body&gt;前，确定dom已经渲染了，才引入js。</span><br><span class="line">        然而这样还是会阻塞。</span><br><span class="line">    2.  defer和async属性，只针对外联js。</span><br><span class="line">        使用defer的&lt;script&gt;标签是按照他们排列的顺序执行</span><br><span class="line">        而使用async的&lt;script&gt;标签是不按他们在HTML中的排列顺序执行</span><br><span class="line">        这样就解析js时就不会产生阻塞了。</span><br></pre></td></tr></table></figure></p>
<p><strong>js基本对象类型和引用对象类型的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基本类型有: string number boolean null undefined</span><br><span class="line">引用类型有: Funtion Array Object</span><br><span class="line"></span><br><span class="line">访问方式</span><br><span class="line">    基本类型，直接操作和访问变量实际的值</span><br><span class="line">    引用类型，值保存在内存中，js不允许直接访问内存，操作的时候时通过对象的引用</span><br><span class="line">存储的位置</span><br><span class="line">    基本类型，保存在栈中</span><br><span class="line">    引用类型，引用存放在栈中，实际对象在堆中</span><br></pre></td></tr></table></figure></p>
<p><strong>变量提升、函数名提升问题，哪些情况会有变量、函数名的提升？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数声明是函数的声明和实现都被提升了。</span><br><span class="line">函数表达式和变量表达式只是其声明被提升了。</span><br><span class="line">函数名和变量名重复时，优先提升函数名.</span><br></pre></td></tr></table></figure></p>
<p><strong>什么是IIFE立即执行函数？如何实现？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">声明的同时立即调用这个函数</span><br><span class="line">(function foo()&#123;</span><br><span class="line">var a = 10;</span><br><span class="line">console.log(a);</span><br><span class="line">&#125;)();</span><br><span class="line">在函数声明后添加一个().</span><br><span class="line">IIFE的目的是为了隔离作用域，防止污染全局命名空间。</span><br></pre></td></tr></table></figure></p>
<p><strong>null和undefined的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null的typeof是object, undefined的typeof就是undefined</span><br><span class="line">null是一个空对象指针，undefined是声明了但是没有初始化</span><br><span class="line">javascript权威指南说，undefined是系统级的值空缺,而null是程序级的值空缺</span><br></pre></td></tr></table></figure></p>
<p><strong>如何判断一个变量是否是数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. instanceof</span><br><span class="line">2. constructor</span><br><span class="line">3. toString()   Object.prototype.toString.call(arr) === &apos;[object Array]&apos;</span><br></pre></td></tr></table></figure></p>
<p><strong>js的哪些操作会实现隐式转换</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 递增递减</span><br><span class="line">2. 逻辑操作符</span><br><span class="line">3. 关系操作符</span><br><span class="line">4. 相等操作符</span><br></pre></td></tr></table></figure></p>
<p><strong>es6的symbol</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">symbol是一种新的基础类型，</span><br><span class="line">symbol的存储方式是键值相对，每一个symblo都是独一无二的。</span><br><span class="line">为了避免程序重复的变量而开发出来的。</span><br></pre></td></tr></table></figure></p>
<p><strong>js如何实现继承？ES6 class如何实现的继承？与ES5的区别是什么？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js是通过原型链实现继承的</span><br><span class="line">es6 通过关键字 extends 实现继承的，实际还是通过原型链只不过是封装了。</span><br><span class="line">es5是通过原型和构造函数，es6是通过封装的关键字</span><br></pre></td></tr></table></figure></p>
<p><strong>jsonp的原理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.有src属性的标签都能跨域(img,script,iframe)等</span><br><span class="line">2.所以利用script来实现跨域，因为script只能请求js相关文件，所以需将远程服务器的数据装入js中，供客户端调用。</span><br><span class="line">3.于是json被发现了，它可以简单的描述复杂数据，还被js原生支持。客户端也可以很轻易的处理这种数据。</span><br><span class="line">4.所以客户端像调用脚本一样的，来调用跨域服务器上的js格式文件(json)。</span><br><span class="line">5.这种方式逐渐成为了一种非正式的传输协议，称之为jsonp，主要的特点就是用户需要提交一个callback，然后服务器</span><br><span class="line">   返回数据的时候就会通过这个callback包裹住，这样客户端就可以随心所欲的处理返回的数据。</span><br></pre></td></tr></table></figure></p>
<p><strong>Object和Function的关系</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Object和Function都是构造函数,所有的构造函数都是Function的实例，所以Object是Function的实例。</span><br><span class="line">2. Function.prototype是Object的实例对象。</span><br><span class="line">3. 实例对象的原型(proto)会指向其构造函数的prototype属性，Object.proto === Function.prototype,</span><br><span class="line">    Function.proto === Function.prototype, Funtion.prototype === Object.protoype</span><br><span class="line">4. 当访问一个属性值时，它会沿着原型链向上查找，直到找到或者到Object.prototypr.proto(null)为止。</span><br></pre></td></tr></table></figure></p>
<p><strong>ES6异步编程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 回调函数callback,容易产生回调地狱。</span><br><span class="line">2. Promise, 通过then方法加载回调函数，catch捕捉错误，但是then太多就会导致代码混乱。</span><br><span class="line">3. 协程，我没用过不知道，反正可以解决！</span><br><span class="line">4. Gennerator函数,yield, 可以暂停执行和恢复执行，所以能够解决异步。</span><br></pre></td></tr></table></figure></p>
<p><strong>说一下原型链</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js对象是基于原型链的。有原型和原型链的概念。</span><br><span class="line">原型很简单，就是你继承于谁。</span><br><span class="line">js的对象只有__proto__属性，而函数有prototype和__proto__属性。</span><br><span class="line">因为对象和函数都是通过Funtion的构造函数生成的。所以对象的__proto__ 是继承于Funtion的构造函数(prototype)的。</span><br><span class="line">而函数的prototype就是他自己的构造函数(prototype)。函数的__proto__是继承于Object的构造函数(prototype)因为一切都继承于Object</span><br><span class="line">但是Object的__proto__为Null</span><br></pre></td></tr></table></figure></p>
<p><strong>闭包的原理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">闭包的实现和以下几个原理有关:</span><br><span class="line">变量作用域: 全局变量，全局都能使用，函数内部定义的变量，仅能在函数内部使用。</span><br><span class="line">函数作用域: 在函数内声明的变量，在函数体内始终是可见的。</span><br><span class="line">作用域链: 作用域链式一个对象，它定义了该作用域内的变量，保证作用域的变量函数的访问。</span><br><span class="line">作用域链的创建: 定义一个函数时会保存一个作用域链，调用一个函数时，会创建一个新的对象来存储器局部变量，并添加进保存的作用域链上。</span><br><span class="line">                每次调用函数，都会创建新的作用域链，虽然内部代码相同，但是作用域链是不同的。</span><br><span class="line">垃圾回收机制: js有自动回收垃圾的机制，会定期把不再使用的变量销毁，释放内存。（只会销毁局部变量，全局变量是关闭浏览器时才销毁）</span><br><span class="line">闭包的原理就是： 函数的执行依赖于函数定义的时候的作用域链，所以函数执行的时候用的作用域链是定义时候创建的，但当执行的函数的作用域</span><br><span class="line">                域链和定义的作用域链不同时，就会出现问题！即一个函数嵌套一个函数并返回函数时就会产生闭包的情况。</span><br><span class="line">                当外部函数把嵌套函数作为返回值返回时，其执行结果仍然是局部变量的值，而不是全局变量的值。</span><br><span class="line">                这就是因为函数执行时用到的作用域链，其实是函数定义时创建的。不管该函数在何时何地执行，它通过作用域链最先找到的变量就是相同外部函数中定义的变量</span><br><span class="line">                而闭包正是利用这种特性实现的：闭包可以捕捉到局部变量或参数，并一直保存下来，使其不会被当成垃圾回收。</span><br><span class="line">注意： 如果闭包使用不得当，会导致大量的局部变量没有回收，导致内存泄露！所以看看那些大框架是怎么使用闭包的吧！</span><br></pre></td></tr></table></figure></p>
<p><strong>js深浅复制</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浅拷贝：仅仅复制对象的引用，而不是对象本身</span><br><span class="line">深拷贝：把复制的对象所引用的全部对象都复制一遍</span><br></pre></td></tr></table></figure></p>
<p> <strong>原型链继承</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.prototype = new 要继承的对象()</span><br></pre></td></tr></table></figure></p>
<p><strong>箭头函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以简化代码.</span><br><span class="line">但是不绑定this,和arguments</span><br></pre></td></tr></table></figure></p>
<h2 id="JQ相关"><a href="#JQ相关" class="headerlink" title="JQ相关"></a>JQ相关</h2><p><strong>为什么Jquery只需要$即可生成Jquery对象</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Jquery3.X的源码文件，能够解释一切。</span><br><span class="line">if ( !noGlobal ) &#123;</span><br><span class="line">	window.jQuery = window.$ = jQuery;</span><br><span class="line">&#125;</span><br><span class="line">return jQuery;</span><br><span class="line">&#125; );</span><br><span class="line">所以$() === jQuery()</span><br><span class="line">还是通过构造函数生成的。</span><br></pre></td></tr></table></figure></p>
<p> <strong>既然是构造函数,为什么不用new呢</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Jquery3.X的源码能说明一切</span><br><span class="line">jQuery = function( selector, context ) &#123;</span><br><span class="line">		return new jQuery.fn.init( selector, context );</span><br><span class="line">	&#125;,</span><br><span class="line">执行Jquery后，return一个new的Jquery并且初始化.</span><br><span class="line">没毛病，还是正常的new class。只是巧妙的封装了。</span><br></pre></td></tr></table></figure></p>
<p> <strong>jQuery ready原理、window.onload区别</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ready: DOM结构加载完毕,就可执行,可多次执行</span><br><span class="line">onload: 网页必须全部加载完,才能执行,只能执行一次</span><br></pre></td></tr></table></figure></p>
<h2 id="Vue相关"><a href="#Vue相关" class="headerlink" title="Vue相关"></a>Vue相关</h2><p><strong>vue的特点</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.MVVM框架，数据双向绑定</span><br><span class="line">2.轻量级的渐进式框架</span><br><span class="line">3.组件单向流通</span><br><span class="line">4.有自己的指令</span><br><span class="line">5.大型单页式的网站</span><br></pre></td></tr></table></figure></p>
<p><strong>vue组件之间的通信</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vue是单向数据通信</span><br><span class="line">父传子 props</span><br><span class="line">子传父 $on, $emit</span><br><span class="line">非父子，可以通过使用一个空的Vue实例作为中央事件总线</span><br></pre></td></tr></table></figure></p>
<p><strong>vue双向数据绑定的原理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue是基于object.defneProperty()属性拦截器实现的</span><br></pre></td></tr></table></figure></p>
<p><strong>vue的生命周期以及每个周期用来干什么的</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate 实例创建前,此时无法读取data、 methods</span><br><span class="line">created 实例创建后，这是已经有了data,属性和方法的运算，watch/event事件等，但是mount还未挂载,数据还未渲染。</span><br><span class="line">beforeMount 挂载开始前，相关的render调用</span><br><span class="line">mounted el的dom节点被vm.$el替换，实例数据在dom上渲染</span><br><span class="line">beforeUpdate 数据更新是调用，不进行dom重新渲染， 在数据更新前可以进行状态处理</span><br><span class="line">updated: 数据更新并且dom渲染，这时dom已经更新，每次数据更新都会执行updated</span><br><span class="line">beforeDestory 实例销毁前调用</span><br><span class="line">destroyed vue实例销毁后调用，vue所有的东西都会被解绑，所有的子实例也会销毁</span><br><span class="line">应用场景</span><br><span class="line">created 异步数据请求，初始化数据</span><br><span class="line">mounted 挂载元素内的dom节点获取</span><br><span class="line">nextTick 针对单一事件更新数据后立即操作dom</span><br><span class="line">updated 任何数据的更新，做同一的业务逻辑处理</span><br><span class="line">watch: 监听数据变化，做出相应的处理</span><br></pre></td></tr></table></figure></p>
<p><strong>vuex包括什么？对action理解的怎么样</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vuex是各个组件的状态管理器，也成为前端数据库吧。</span><br><span class="line">state: 状态的数据结构</span><br><span class="line">actions: 从服务端获取数据，（异步）调用commit来改变状态</span><br><span class="line">mutations: 唯一能改变状态的地方</span><br><span class="line">getters: 组件获取状态器的数据，需通过这里。</span><br><span class="line">modules: 一个store可以拆分为多个，每个都有自己的state,actions等</span><br><span class="line">actions我一般用来获取服务器的数据，更新，因为mutations是同步的，不行，而actions是异步的。</span><br></pre></td></tr></table></figure></p>
<h2 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h2><p><strong>什么算跨域,如何解决跨域</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">域名，协议，端口有一样不同，都算是跨域</span><br><span class="line">解决方式，jsonp，cors，window.domain, 反向代理</span><br></pre></td></tr></table></figure></p>
<p><strong>localstorage概念,原理</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H5新增本地存储的API，有5M的内存大小，是一个本地的小仓库。</span><br><span class="line">在本地创建了一个文件夹，是永久保存的，</span><br></pre></td></tr></table></figure></p>
<p><strong>跨域相关</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">浏览器安全机制同源政策，协议，端口，域名都相同才称为同源，否则需要跨域。</span><br><span class="line">1. script标签请求数据,只能get请求，且无法访问服务器响应文本(单向请求)。</span><br><span class="line">2. jsonp通过script的开发策略得到其他网页的json数据，只能get，不知道是否失败，安全性无法保证。</span><br><span class="line">3. CORS跨域资源共享，通过HTTP请求头和修改后端服务器的响应头配置即可。</span><br><span class="line">4. 反向代理(例如nginx),原理：本地浏览器-&gt;本地服务器-&gt;异地服务器-&gt;本地浏览器</span><br><span class="line">5. WebSocket，浏览器与服务器的全双工协议，允许跨域通信。</span><br><span class="line">6. document.domain跨子域,前提是域名协议，端口都相同。只能跨子域。</span><br><span class="line">7. img跨域，img也能跨域，不过也是单向请求了，不能得到服务器响应的文本。</span><br></pre></td></tr></table></figure></p>
<p><strong>cookie与localStorage的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cookie为了辨别用户身份而存储在本地终端的数据</span><br><span class="line">    1.  存放大小4kb</span><br><span class="line">    2. 一般由服务器生成，可设置失效时间，如果浏览器默认生成，则浏览器关闭即失效</span><br><span class="line">    3. 一般用于记住密码，标识身份等</span><br><span class="line">localStorage用于浏览器端缓存数据</span><br><span class="line">    1. 一般为5MB</span><br><span class="line">    2. 除非被清除，否则永久保存</span><br><span class="line">    3. 一般保存比较大的数据</span><br></pre></td></tr></table></figure></p>
<h2 id="网络原理相关"><a href="#网络原理相关" class="headerlink" title="网络原理相关"></a>网络原理相关</h2><p><strong>http和https的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP：超文本传输协议，明文传输，连接端口是80。    </span><br><span class="line">HTTPS：加密传输，是Http+ssl(安全套接字)协议构建的，端口是443，需要申请ca证书。</span><br></pre></td></tr></table></figure></p>
<p><strong>浏览器输入网址到页面渲染全过程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">其实原理挺复杂的，各方各面都有涉及，就写简约一点。</span><br><span class="line">    1. 浏览器把输入的域名进行dns解析，得到ip地址。</span><br><span class="line">    2. 通过ip和arp地址找到目标服务器地址。</span><br><span class="line">    3. 进行tcp连接。</span><br><span class="line">    4. 浏览器发送请求，等待响应。</span><br><span class="line">    5. 服务器处理请求，开始响应。</span><br><span class="line">    6. 浏览器收到响应，得到html代码。</span><br><span class="line">    7. 渲染页面。</span><br></pre></td></tr></table></figure></p>
<p><strong>TCP和UDP的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TCP是面向连接的传输方式(三次握手),UDP是非连接的传输方式</span><br><span class="line">TCP的数据按序到达，不错误，不丢失，不重复，UDP尽最大努力交付，不保证可靠。</span><br><span class="line">TCP面向字节流，UDP面向报文</span><br><span class="line">TCP是点对点，UDP支持一对一，一对多，多对一，多对多 </span><br><span class="line">TCP是全双工的可靠信道，UDP是不可靠信道</span><br><span class="line">TCP首部开销20字节，UDP首部开销8字节</span><br></pre></td></tr></table></figure></p>
<p> <strong>CDN是什么</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内容分发系统,会实时根据网络状态，负载节点等各种情况，找到用户最优的节点。</span><br><span class="line">提高用户访问的响应速度。</span><br></pre></td></tr></table></figure></p>
<p> <strong>工作在各个层的协议</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">物理层: RJ45 CLOCK IEEE802.3(中继器, 集线器, 网关)</span><br><span class="line">链路层: PPP FR HDLC VLAN MAC(网桥, 交换机)</span><br><span class="line">网络层: IP ICMP ARP RARP OSPF IPX RIP IGRP(路由器)</span><br><span class="line">传输层: TCP(三次握手可靠传输) UDP(非连接传输) SPX</span><br><span class="line">会话层: NFS SQL NETBIOS RPC</span><br><span class="line">表示层: JPEG MPEG ASII</span><br><span class="line">应用层: FTP DNS TELNET SMTP HTTP WWW NFS</span><br></pre></td></tr></table></figure></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>首屏加载优化</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 除了首屏的图片，其他的图片都采用懒加载。</span><br><span class="line">2. 其他的和上面前端优化差不多</span><br><span class="line">3. 其实我也听说过一种叫做服务端渲染的技术，SSR？</span><br></pre></td></tr></table></figure></p>
<p><strong>排序算法有哪些</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，</span><br><span class="line">而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</span><br><span class="line">主要是内部排序</span><br><span class="line">直接插入排序(稳定)：设置标兵，标兵是前n个元素中最大(小)的元素，后面的与之相比较，大(小)则交换。</span><br><span class="line">希尔排序(不稳定)：减少增量排序，按数组增量分组。例如增量为2[2,3,1,4]分为[2,1][3,4]分别排序，然后合并。</span><br><span class="line">简单选择排序(不稳定)：每一轮选择第n大的数字与第n个位置交换。(例如最大的数位置和第一个位置交换);</span><br><span class="line">堆排序(不稳定)：将数组排列成堆，每个元素都与堆顶元素比较，将堆顶元素沉入堆底，重复操作即可。</span><br><span class="line">冒泡排序(稳定)：相邻元素第一个比第二个元素大(小)就交换，每一对比较，一轮下来最大最小就会在最后。比完即可。</span><br><span class="line">快速排序(不稳定)：左指针右指针和一个基数，左右指针重合的时候两边分别比基数大和基数小，然后再循环以上步骤即可。</span><br><span class="line">归并排序(稳定)：分治法，数组对半拆分直到不可分，然后逐渐合并排序，即可。</span><br><span class="line">桶排序(稳定)：把数组分在各个子区间，然后各个子区间分别排序，最后合并排序，即可。</span><br><span class="line">基数排序(稳定)：桶排序的扩展，将整数按位数切割排序，不足补0。即可。</span><br></pre></td></tr></table></figure></p>
<p><strong>前端性能优化</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 减少Http请求（图片绘制成一张，然后客户端拆分）</span><br><span class="line">2. 使用CDN</span><br><span class="line">3. 添加Expires头,缓存组件</span><br><span class="line">4. 压缩组件，gzip什么的</span><br><span class="line">5. 样式表放在头部(避免白屏)</span><br><span class="line">6. 脚本放在底部（避免阻塞）</span><br><span class="line">7. 使用外部js和css，因为浏览器可能会缓存它们</span><br><span class="line">8. 避免css表达式</span><br><span class="line">9. 精简js和css代码</span><br><span class="line">10. 减少iframe的个数</span><br><span class="line">11. 预加载，延迟加载的合理应用。</span><br></pre></td></tr></table></figure></p>
<p><strong>MVVM和MVC的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MVVM是将&quot;数据模型数据双向绑定&quot;的思想作为核心，因此View和Model没有联系，通过ViewModel进行交互。  </span><br><span class="line">因此试图变化的数据会修改数据源，而数据源的变化也会反应到视图上。</span><br><span class="line">MVC还是传统的方式，只是逻辑分离了。用户操作视图(view0，反应到控制器(业务逻辑)，控制器调用模型(数据持久化)，最后反馈到视图。</span><br></pre></td></tr></table></figure></p>
<p><strong>对象和类的区别，具一个例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类是对象的抽象概念，对象是类的具体表达。《PHP核心技术与最佳实践》</span><br><span class="line">类是抽象的，不具体的，一些东西可以归为一类，不占空间的。</span><br><span class="line">对象是具体的，是一个类的具体表达，占空间的。</span><br><span class="line">例如动物是一类，猫，狗就是对象。猫狗是具体存在的，而动物是抽象的。</span><br></pre></td></tr></table></figure></p>
<p><strong>你理解的面向对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">面向对象编程需要抽象的思维，把一些直观的东西需要抽象，但是代码量会大一些。</span><br><span class="line">例如我之前写过一个象棋项目，他就分了很多类，棋子类，棋盘类，规则类等。</span><br><span class="line">如果是面向过程，就不分这么多，直接就写很多函数，完成就OK，但是不好扩展。</span><br><span class="line">面向对象的优势是，扩展性强，复用性好，维护简单。</span><br></pre></td></tr></table></figure></p>
<p><strong>垃圾回收机制的理解</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">垃圾回收机制是一种自动释放变量的机制。以免变量一直占用内存。</span><br><span class="line">js的垃圾回收机制是，当js检测到一个变量之后不会再使用的时候，就会把它释放。</span><br><span class="line">js的垃圾回收的两种方式，标记清除和引用计数</span><br><span class="line">1. 标记清除</span><br><span class="line">    这是js最常用的回收方式，当变量进入执行环境时，就标记为“进入环境”，</span><br><span class="line">    进入执行环境的变量不能释放，因为他们可能随时用到，当变量离开环境的时候，</span><br><span class="line">    则将其标记为“离开环境”，然后去掉环境中的变量和标记，然后垃圾收集器来搜集。</span><br><span class="line">    例如进入函数，函数里面的标记就变为进入环境，当离开环境后，局部变量就会被回收。</span><br><span class="line">2. 引用计数</span><br><span class="line">    不太常见的回收策略，跟踪每个值被引用的次数，当一个变量已经没有引用类型引用的时候，</span><br><span class="line">    就会把他回收。</span><br><span class="line">    例如a=3，现在a引用的是3，但当a=4的时候，这里的3仍在，并不是被替换。</span><br><span class="line">    而是a引用到4了，此时3已经没有任何变量引用它，它就会被回收了！</span><br></pre></td></tr></table></figure></p>
<p><strong>问==和===的区别,<code>typeof null</code>是什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==是判断值是否相同，如果类型不同，会自动转化类型，再对比值</span><br><span class="line">===是判断类型和值是否都相同</span><br><span class="line">typeof null的值为object， 一个既是对象，又不是对象的东西</span><br></pre></td></tr></table></figure></p>
<p><strong>AMD和commonjs是怎么使用，怎么配置，有什么好处</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两者都是为了实现模块化编程的，</span><br><span class="line">Commonjs是服务端的，比如Node,是同步加载不同模块文件，</span><br><span class="line">ADM是异步模块定义，是适用于浏览器端的模块加载方式，是异步加载的方式，例如ajax</span><br><span class="line">所以浏览器时无法使用Commonjs的模式(除非有四个node环境的变量)</span><br><span class="line">好处就是，有了模块，我们可以更方便的使用别人的代码，想要什么功能，就加载什么模块。</span><br><span class="line">怎么配置？目前还没研究啊!</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>前途漫漫，耐心等待。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/前端/" rel="tag"># 前端</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/10/TP5源码分析之Db类实现/" rel="next" title="TP5源码分析之Db类实现">
                <i class="fa fa-chevron-left"></i> TP5源码分析之Db类实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/16/阿里巴巴一面面经/" rel="prev" title="阿里巴巴一面面经">
                阿里巴巴一面面经 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  
    <div class="comments" id="comments">
      <div id="SOHUCS"></div>
    </div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="余鸿靖" />
            
              <p class="site-author-name" itemprop="name">余鸿靖</p>
              <p class="site-description motion-element" itemprop="description">个人文章</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yuhongjing" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#知识点"><span class="nav-number">2.</span> <span class="nav-text">知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML相关"><span class="nav-number">2.1.</span> <span class="nav-text">HTML相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS相关"><span class="nav-number">2.2.</span> <span class="nav-text">CSS相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS相关"><span class="nav-number">2.3.</span> <span class="nav-text">JS相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JQ相关"><span class="nav-number">2.4.</span> <span class="nav-text">JQ相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue相关"><span class="nav-number">2.5.</span> <span class="nav-text">Vue相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器相关"><span class="nav-number">2.6.</span> <span class="nav-text">浏览器相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络原理相关"><span class="nav-number">2.7.</span> <span class="nav-text">网络原理相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">2.8.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">余鸿靖</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>
  <div>
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  本站总访问量 <span id="busuanzi_value_site_pv"></span> 次&nbsp&nbsp&nbsp
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
  </div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  




  
    <script type="text/javascript">
    (function(){
      var appid = 'cytCyhAyu';
      var conf = '285cc914d652d41d6d42f4df495436f1';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){
        window.changyan.api.config({appid:appid,conf:conf})});
      }
    })();
    </script>
    <script type="text/javascript" src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>
  





  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  



  
  <script type="text/javascript"
  color="0,0,255" opacity='0.5' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
