<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>蘑菇街二面面经</title>
      <link href="/2018/09/07/%E8%98%91%E8%8F%87%E8%A1%97%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
      <url>/2018/09/07/%E8%98%91%E8%8F%87%E8%A1%97%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
      <content type="html"><![CDATA[<h3 id="紧张的视频面试"><a href="#紧张的视频面试" class="headerlink" title="紧张的视频面试"></a>紧张的视频面试</h3><p>第一次参加视频面试，会手写代码，非常慌！<br><a id="more"></a></p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol><li>自我介绍+项目介绍</li><li>手写质因数</li><li>学习的过程</li><li>看的书</li><li>聊人生<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>没问技术，总感觉有点凉了。唉。<br>没有什么自己的项目点，很烦。   </li></ol>]]></content>
      
      <categories>
          
          <category> 校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蘑菇街 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>蘑菇街一面面经</title>
      <link href="/2018/09/03/%E8%98%91%E8%8F%87%E8%A1%97%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
      <url>/2018/09/03/%E8%98%91%E8%8F%87%E8%A1%97%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上个星期，突然就给我打电话了预约面试，因为需要上班的缘故。<br>原本约定晚上7点左右，没想到他们说晚上没有空，可能是因为不加班的缘故？？<br>于是专门请假，来好好准备面试。<br><a id="more"></a></p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol><li>自我介绍+项目</li><li>前端存储方式</li><li>vue的hash路由实现</li><li>json对象删除一个键对</li><li>vue的生命周期</li><li>vue的实现原理</li><li>HTML5的模板</li><li>各种终端的适配</li><li>垂直居中</li><li>restful的风格</li><li>如何学习前端的</li><li>删除页面的某一类节点</li><li>sessionStrong和localStrong的区别</li><li>闭包的原理  </li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面试小哥和我一样有一点腼腆，不过很直爽，给人的感觉很不错。<br>而且特别忙，听到我说，对我的评价，就很慌！O(∩_∩)O哈哈~。<br>总的来说，问题都很基础，真的很基础，一次比较好的面试体验吧。加油！  </p>]]></content>
      
      <categories>
          
          <category> 校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蘑菇街 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js实现八大排序</title>
      <link href="/2018/08/29/js%E5%AE%9E%E7%8E%B0%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/08/29/js%E5%AE%9E%E7%8E%B0%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>现在的面试啊，唉动不动就是手写算法。不容易啊，不容易。<br>笔试一遍一遍的跪。哎。<br><a id="more"></a></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序解析:<br>比较相邻的两个数,若前面的比后面的元素大(小),就交换<br>第一轮比较完毕，最大的数字肯定在最后。<br>比较n-1轮即可，因为最后一个数字不需要比较了。<br><strong>代码如下</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   function sort(arr) &#123;</span><br><span class="line">if(arr.length &lt;= 1) &#123; return arr; &#125;</span><br><span class="line"></span><br><span class="line">       let len = arr.length;</span><br><span class="line">for(let i=0; i&lt;len-1; i++)&#123;</span><br><span class="line">for(let j=0; j&lt;len-1-i; j++)&#123;</span><br><span class="line">if(arr[j] &gt; arr[j+1]) &#123;</span><br><span class="line">[arr[j], arr[j+1]] = [arr[j+1], arr[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>选择排序解析:<br>每一轮,选择第n小的数，放在第n个位置。<br>例如第一轮选择最小的数放在第一个位置。<br><strong>代码如下</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   function sort(arr) &#123;</span><br><span class="line">if(arr.length &lt;= 1) &#123; return arr; &#125;</span><br><span class="line"></span><br><span class="line">       let len = arr.length;</span><br><span class="line">for(let i=0; i&lt;len-1; i++)&#123;</span><br><span class="line">let min = arr[i];</span><br><span class="line">let pos = i;</span><br><span class="line">for(let j=i+1; j&lt;len; j++)&#123;</span><br><span class="line">if(min &gt; arr[j]) &#123;</span><br><span class="line">min = arr[j];</span><br><span class="line">pos = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">[arr[i], arr[pos]] = [min, arr[i]];</span><br><span class="line">&#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序解析:<br>选出一个基准值(一般是中间)<br>遍历数组，小的放基准值左边，大的放基准值右边<br>递归(两边都快速排序)<br><strong>代码如下</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr)&#123;</span><br><span class="line">    if(arr.length&lt;=1)&#123; return arr; &#125;</span><br><span class="line"></span><br><span class="line">    let pivotIndex=Math.floor(arr.length/2);</span><br><span class="line">    let pivot=arr.splice(pivotIndex,1)[0];</span><br><span class="line">    let left=[];</span><br><span class="line">    let right=[];</span><br><span class="line"></span><br><span class="line">    let len = arr.length;</span><br><span class="line">    for(let i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(arr[i]&lt;=pivot)&#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return quickSort(left).concat([pivot],quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>直接插入排序解析:<br>每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去。<br>直到插完所有元素为止。<br><strong>代码如下</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   function sort(arr) &#123;</span><br><span class="line">if(arr.length &lt;= 1) &#123; return arr; &#125;</span><br><span class="line"></span><br><span class="line">let len = arr.length;</span><br><span class="line">for(let i=1; i&lt;len; i++) &#123;</span><br><span class="line">let key = arr[i];</span><br><span class="line">let pos = i-1;</span><br><span class="line">while(pos&gt;=0 &amp;&amp; arr[pos] &gt; key) &#123;</span><br><span class="line">arr[pos+1] = arr[pos];</span><br><span class="line">pos--;</span><br><span class="line">&#125;</span><br><span class="line">arr[pos+1] = key;</span><br><span class="line">&#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序解析:<br>将数组分为若干个子序列分别插入排序。<br>然后合一次插入所有的序列。<br><strong>代码如下</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   function shellsort(arr) &#123;</span><br><span class="line">if(arr.length &lt;=1) &#123; return arr; &#125;</span><br><span class="line"></span><br><span class="line">let len = arr.length;</span><br><span class="line">let temp;</span><br><span class="line">let count = 0;</span><br><span class="line">let increment = len;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">increment = Math.floor(increment / 3) + 1;</span><br><span class="line">for(var i = increment; i&lt;len; i++) &#123;</span><br><span class="line">if(arr[i] &lt; arr[i - increment]) &#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line">for(var j=i-increment; j&gt;=0 &amp;&amp; temp &lt; arr[j]; j-=increment) &#123;</span><br><span class="line">arr[j+increment] = arr[j];</span><br><span class="line">&#125;</span><br><span class="line">arr[j + increment] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while (increment &gt; 1);</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>剩下的慢慢补全，努力吧。秋招伤人心。唉。唉。唉。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美团一面面经</title>
      <link href="/2018/08/25/%E7%BE%8E%E5%9B%A2%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
      <url>/2018/08/25/%E7%BE%8E%E5%9B%A2%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
      <content type="html"><![CDATA[<h3 id="美团第一感觉"><a href="#美团第一感觉" class="headerlink" title="美团第一感觉"></a>美团第一感觉</h3><p>约定了7点钟面试，一开始接到电话，是一个小姐姐的声音。<br>我还误以为是客户小姐姐，帮我转接电话。<br>结果，一脸懵逼。。。。<br><a id="more"></a></p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol><li>说一下项目经历</li><li>Vue的数据绑定原理 (Object.defineProperty)</li><li>给数组添加一个拷贝数组的方法，例如<code>a=[1,2,3]</code>变为<code>a=[1,2,3,1,2,3]</code> (原型注册方法，concat自己)</li><li>http请求头 (请求行,accept, content-type , referer, cookie)</li><li>viewport的作用 (针对移动端的虚拟窗口)</li><li>移动端适应   (@media, rem, vw)</li><li>前缀表达式   (递归，判断子树是否为空)</li><li>深拷贝和浅拷贝 (深拷贝，拷贝所有属性，json.parse(JSON.stringify(obj))如果有函数就得递归,浅拷贝只拷贝引用)</li><li>rem是如何计算px的 (根据HTML元素的字体大小计算，1rem就是html的字体大小)</li><li>scroll滚动页面卡    (节流)</li><li>vue的hash路由 (window.localtion.hash能够获取，其实是单页网页)</li><li>青蛙跳台阶一次只能跳一步或两步，问有多少种方式 (斐波拉契递归)</li><li><code>loop event</code> (事件循环，针对于异步处理的)</li><li>箭头操作符  (本身没有this和构造函数，继承于外围的this)</li><li>类的继承方式 (原型链继承,extends, 构造函数继承, 组合继承)</li><li>keep-alive (避免建立或重新连接，设置http头， connection：keep-alive)</li><li><code>cookie session localStrong sessionStrong</code> (cookie是客户端,session是服务端的)</li><li><code>call apply bind</code>  (前两个是调用函数，bind是返回函数)</li><li>ul下的li,第一个和最后一个节点交换 (insertBefore, appendChild)</li><li>http状态码 (20X,成功 , 30x,重定向 , 40X客户端, 50X服务端)</li><li>跨域 (Jsonp, cors, 反向代理, window.domain)</li><li>http是如何连接的 (通过tcp连接)</li><li>网页上输入一个url,是如何执行的。 (解析，请求，返回，渲染)</li><li>git的相关命令 (add commit push pull merge checkout branch log)</li><li>重绘与重排 (重绘 样式改变颜色等，重排， 重新渲染节点。 重排一定会引起重绘)</li><li>防抖与节流 (防抖，用户输入完毕再执行， 节流，浏览器窗口大小缩放，滚动条)</li><li>如何判断数据的类型 (typeof    Object.prototype.toString.call(Obj))</li><li>meta标签内的width设置为多少   (device-width)</li></ol><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>小姐姐的声音真的很好听。思路老是被声音带走。<br>不过，小姐姐人很好，最后我问问题的时候还回答了我。<br>继续加油吧。   </p>]]></content>
      
      <categories>
          
          <category> 校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美团 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阿里巴巴一面面经</title>
      <link href="/2018/08/16/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
      <url>/2018/08/16/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
      <content type="html"><![CDATA[<h3 id="人生第一次电话面试"><a href="#人生第一次电话面试" class="headerlink" title="人生第一次电话面试"></a>人生第一次电话面试</h3><p>刚开始写了几分钟苏宁的测试题，<br>就迎来了人生的第一场电话面试，居然就是阿里巴巴的。<br>紧张的手脚颤抖，阿里小哥人真的好温柔！可惜我太菜了。多半凉凉。<br><a id="more"></a></p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol><li>简单说一下你目前做的项目。</li><li>Vue的生命钩子函数。 (beforeCreate, created, beforeMount, mount, beforeDestory, destory)</li><li>Vue的公共模块。(在main.js 引入全局注入即可)</li><li>Vue是如何获取路由的hash值。(获取当前路由#之后的,就是hash值,window.location.hash)</li><li>Vue为什么能全局获取Vuex的值的。(因为在main.js内全局注入了)</li><li>如何计算一个组件的渲染时间。(目前还不知道)</li><li>对象{a: {b: {c: “5”}, d: “3”}},对象的下面还是对象，例如a.b.c 但是如果没有c就会报错，如何传两个参数例如a, a.b.c时，不报错（空就返回null，有值就返回值）, (根据点，逐层遍历，先判断a下是否有b,如果有就在遍历b下是否有c)</li><li>callback,Promise,async的使用方法。(callback是将函数作为参数带过去,Promoise是通过then执行队列式的异步操作,async是可以同步方式的编写异步操作，通过await。)</li><li>Generators和async的区别 (阮一峰说async是Generators的语法糖,将Generators(*)替换成async,yield替换成await)</li><li>开发一个测试工具 ,检测网页的所有红色文字。 (深层遍历网页所有dom点，判断css样式是否为红色)</li></ol><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>让我哭一次，好多东西我都知道的，第一次面试脑袋一片空白懵逼了。<br>不要放弃，感谢阿里给我的这一次机会。</p>]]></content>
      
      <categories>
          
          <category> 校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里巴巴 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端备战合集</title>
      <link href="/2018/08/11/%E5%89%8D%E7%AB%AF%E5%A4%87%E6%88%98%E5%90%88%E9%9B%86/"/>
      <url>/2018/08/11/%E5%89%8D%E7%AB%AF%E5%A4%87%E6%88%98%E5%90%88%E9%9B%86/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>加油，为了更好的明天，前端备战！！！！！<br><a id="more"></a></p><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>下面的资料是所有前端资料的整合</p><h2 id="浏览器H5相关"><a href="#浏览器H5相关" class="headerlink" title="浏览器H5相关"></a><span style="color:red">浏览器H5相关</span></h2><p><strong>浏览器内核，html css js的加载原理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webkit, trident, blink等</span><br><span class="line">html 根据Docytype来触发盒子的模型，是否怪异</span><br><span class="line">css 会生成dom树和css树合并后 渲染</span><br><span class="line">js 有一个js的引擎来解释和执行js代码</span><br></pre></td></tr></table></figure></p><p><strong>HTML语义化</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标签 header section footer nav等等</span><br><span class="line">好处就是方便SEO，方便爬虫趴取。</span><br></pre></td></tr></table></figure></p><p><strong>window.onload和image.onload那个先执行</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">image.onload先执行</span><br><span class="line">因为window.onload是dom，页面所有的资源都加载完毕了才会执行。</span><br></pre></td></tr></table></figure></p><p><strong>xmlHttpRequest原理，跨域，带cookie</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">原理</span><br><span class="line">    XMLHTTPRequest对象向服务器发送请求和解析服务器响应提供了流畅的接口，</span><br><span class="line">    能够以异步方式从服务器去获取更多信息而不必刷新页面。</span><br><span class="line">跨域</span><br><span class="line">    如果是get方式，就用jsonp，</span><br><span class="line">    否则就是CORS，需要在服务器设置响应头Access-Control-Allow-Origin</span><br><span class="line"> 携带cookie</span><br><span class="line">    一般是无法携带的，不过可以通过CORS的方式实现</span><br><span class="line">    前端请求</span><br><span class="line">      xhrFields: &#123;</span><br><span class="line">          withCredentials: true</span><br><span class="line">       &#125;</span><br><span class="line">     后端响应</span><br><span class="line">     Access-Control-Allow-Credentials&quot;, &quot;true&quot;</span><br></pre></td></tr></table></figure></p><p><strong>什么算跨域,如何解决跨域</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">域名，协议，端口有一样不同，都算是跨域</span><br><span class="line">解决方式，jsonp，cors，window.domain, 反向代理</span><br></pre></td></tr></table></figure></p><p><strong>localstorage概念,原理</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H5新增本地存储的API，有5M的内存大小，是一个本地的小仓库。</span><br><span class="line">在本地创建了一个文件夹，是永久保存的，</span><br></pre></td></tr></table></figure></p><p> <strong>h5的存储方式有哪些</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cookie 4kb </span><br><span class="line">localstorage 键值匹配 永久存储 5M</span><br><span class="line">sessionstorage 和localstorage差不多，不过（浏览器）关闭就清除了</span><br><span class="line">application cache（离线缓存） 配置mainfest</span><br><span class="line">indexedDB（索引数据库）</span><br></pre></td></tr></table></figure></p><p><strong>强缓存和协商缓存</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">强缓存不用请求服务器，直接使用。</span><br><span class="line">利用http头部返回的Expires或者Cache-Control来控制</span><br><span class="line">协商缓存需请求服务器，告知能否使用缓存。</span><br><span class="line">如果两个都没有命中，服务器就回发回资源。</span><br></pre></td></tr></table></figure></p><p><strong>跨域相关</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">浏览器安全机制同源政策，协议，端口，域名都相同才称为同源，否则需要跨域。</span><br><span class="line">1. script标签请求数据,只能get请求，且无法访问服务器响应文本(单向请求)。</span><br><span class="line">2. jsonp通过script的开发策略得到其他网页的json数据，只能get，不知道是否失败，安全性无法保证。</span><br><span class="line">3. CORS跨域资源共享，通过HTTP请求头和修改后端服务器的响应头配置即可。</span><br><span class="line">4. 反向代理(例如nginx),原理：本地浏览器-&gt;本地服务器-&gt;异地服务器-&gt;本地浏览器</span><br><span class="line">5. WebSocket，浏览器与服务器的全双工协议，允许跨域通信。</span><br><span class="line">6. document.domain跨子域,前提是域名协议，端口都相同。只能跨子域。</span><br><span class="line">7. img跨域，img也能跨域，不过也是单向请求了，不能得到服务器响应的文本。</span><br></pre></td></tr></table></figure></p><p><strong>cookie与localStorage的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cookie为了辨别用户身份而存储在本地终端的数据</span><br><span class="line">    1.  存放大小4kb</span><br><span class="line">    2. 一般由服务器生成，可设置失效时间，如果浏览器默认生成，则浏览器关闭即失效</span><br><span class="line">    3. 一般用于记住密码，标识身份等</span><br><span class="line">localStorage用于浏览器端缓存数据</span><br><span class="line">    1. 一般为5MB</span><br><span class="line">    2. 除非被清除，否则永久保存</span><br><span class="line">    3. 一般保存比较大的数据</span><br></pre></td></tr></table></figure></p><h2 id="CSS相关"><a href="#CSS相关" class="headerlink" title="CSS相关"></a><span style="color:red">CSS相关</span></h2><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a><span style="color:blue">布局</span></h3><p><strong>两边宽度固定，中间自适应的布局</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">圣杯布局和双飞燕布局都是两边栏固定，中间自适应的布局，还有flex也是可以解决的</span><br></pre></td></tr></table></figure></p><h3 id="移动端适应"><a href="#移动端适应" class="headerlink" title="移动端适应"></a><span style="color:blue">移动端适应</span></h3><p><strong>移动端适配方案有哪些</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media媒体查询</span><br><span class="line">rem</span><br><span class="line">vw vh</span><br></pre></td></tr></table></figure></p><p><strong>了解移动端的适配吗？请问什么是rem布局？在移动端的1px问题该如何解决。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rem布局是通过js来计算rem的值，来适配不同的移动端</span><br><span class="line">移动端的1px问题主要是逻辑像素和物理像素需要1对1 </span><br><span class="line">通过meta标签的viewport的属性设置能够完成</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p><strong>CSS响应式布局</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">响应式网站是指一个网站能兼容多个终端！</span><br><span class="line">1.@media的方式进行响应式布局</span><br><span class="line">2.flex流式布局也是可以的</span><br></pre></td></tr></table></figure></p><p><strong>移动端300延迟</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">禁止缩放</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot;&gt; 或者</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1&quot;&gt;</span><br><span class="line">设置 viewport 的 device-width</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=3&quot;&gt;</span><br><span class="line">使用指针事件</span><br><span class="line">a, button, .myelements &#123;</span><br><span class="line">    -ms-touch-action: manipulation; /* IE10  */</span><br><span class="line">    touch-action: manipulation;     /* IE11+ */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a><span style="color:blue">动画</span></h3><p><strong>transition和animation有什么区别</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transition是过渡动画, 只能指定   起始状态和结束状态，需要由动作(hover)来触发执行， 作用就是平滑的改变css值</span><br><span class="line">animation是动画，有多个关键帧设置，可以自己执行，</span><br></pre></td></tr></table></figure></p><p><strong>对于css3的transform有了解吗？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关于元素的形变元素，有旋转(rotate)，缩放(scale),移动(translate)等</span><br></pre></td></tr></table></figure></p><p><strong>对于css3的动画有了解吗？必填属性有哪些？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animation属性，@keyframes </span><br><span class="line">必填属性animation-name animation-duration</span><br></pre></td></tr></table></figure></p><p><strong>在实现一个div移动的动画，使用translate、top（代指定位）、margin之间有什么性能上的不同？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">translate 页面不会回流,margin会回流</span><br></pre></td></tr></table></figure></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><span style="color:blue">基本概念</span></h3><p><strong>CSS3新属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">border-raduis 边框</span><br><span class="line">box-shadow 阴影</span><br><span class="line">background-size 背景图片尺寸</span><br><span class="line">background-origin 背景图片位置</span><br><span class="line">transition 过渡动画</span><br><span class="line">animation 动画</span><br><span class="line">column-count 多列</span><br><span class="line">box-sizing 盒子模型</span><br><span class="line">resize 元素尺寸</span><br></pre></td></tr></table></figure></p><p><strong>flex基本属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">关于容器的</span><br><span class="line">flex-direction 容器的主轴方向</span><br><span class="line">flex-wrap 换行</span><br><span class="line">justify-content 主轴对齐方式</span><br><span class="line">align-items 交叉轴的对齐方式</span><br><span class="line">align-content 多根轴线的对齐方式</span><br><span class="line">关于项目的</span><br><span class="line">order 项目的排列顺序</span><br><span class="line">flex-grow 放大比例 存在剩余空间放大 默认0</span><br><span class="line">flex-shrink 缩小比例 默认1</span><br><span class="line">flex-basis 固定大小。 默认auto</span><br><span class="line">align-self 对齐方式</span><br></pre></td></tr></table></figure></p><p><strong>transform的主要属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主要是元素的改变形状的属性</span><br><span class="line">常用的属性有</span><br><span class="line">rotate(x deg) 旋转</span><br><span class="line">translate(x px, y px) 移动</span><br><span class="line">scale(x, y) 缩放</span><br><span class="line">skew(x deg, y deg) 扭曲</span><br><span class="line">matrix(number)  矩阵</span><br></pre></td></tr></table></figure></p><p><strong>Canvas的api</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context.fillRect 绘画矩形</span><br><span class="line">context.arc     绘画圆弧</span><br><span class="line">context.moveTo 绘画线段</span><br><span class="line">context.beginPath 绘画路径</span><br><span class="line">context.drawImage 绘制图像</span><br><span class="line">图片模糊，按照原本图片的两倍大小绘制，然后缩小50%即可</span><br></pre></td></tr></table></figure></p><p><strong>重绘重排的优化</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">offsetTop、offsetLeft、offsetWidth、offsetHeight</span><br><span class="line">clientTop、clientLeft、clientWidth、clientHeight</span><br><span class="line">scrollTop、scrollLeft、scrollWidth、scrollHeight</span><br></pre></td></tr></table></figure></p><p><strong>translate 和 position的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、当元素原来已经有position:absolute的时候，这时候你想相对于本身移动，可以使用translate</span><br><span class="line">2、做动画的时候translate更适合，不会引起页面的重排和重绘重绘</span><br><span class="line">3、关于transform类的，可以使用GPU加速，提高浏览器的性能</span><br><span class="line">总之：transform更适用于动画</span><br></pre></td></tr></table></figure></p><p><strong>vw vh 1vw等于多少</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vw是视窗宽度</span><br><span class="line">vh是视窗高度</span><br><span class="line">1vw是视窗宽度的1%;</span><br></pre></td></tr></table></figure></p><p><strong>rem是什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rem是根据html的font-size大小来变化，</span><br><span class="line">一种是可以通过js来调整HTML的字号 </span><br><span class="line">一种是通过媒体查询</span><br></pre></td></tr></table></figure></p><p><strong>box-sizing是什么</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">改变盒子模型，例如怪异模型和标准模型，改变盒子的计算尺寸方式。</span><br><span class="line">属性值有: content-box border-box inherit</span><br></pre></td></tr></table></figure></p><p> <strong>rem与em了解吗？分别是相对于谁来计算的？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rem相对于html的font-size计算的</span><br><span class="line">em是相对于父元素的font-size计算的</span><br></pre></td></tr></table></figure></p><p><strong>如何清除浮动？ 什么是css样式初始化？为什么要这么做？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">清楚浮动可以通过伪类元素，div clear , overflow等</span><br><span class="line">css样式就是把一些基本的标签的的margin,padding等重设，因为每个浏览器的标准可能不同</span><br></pre></td></tr></table></figure></p><p><strong>css选择器的权重都是什么？什么是伪类与伪元素？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&gt;class = 伪类 &gt; 标签 = 伪元素 &gt; 通配符</span><br></pre></td></tr></table></figure></p><p><strong>内容超出容器时的默认情况，解决方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内容会依旧显示，不会换行也不会省略。</span><br><span class="line">设置省略overflow，等。</span><br></pre></td></tr></table></figure></p><p><strong>line-height带单位和不带单位的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当父元素为150%,1.5em这样时  </span><br><span class="line">会根据父元素的字体大小计算出行高值，再让子元素基础</span><br><span class="line">当父元素为1.5时，没有单位时。</span><br><span class="line">会先根据子元素的字体大小动态计算行高，让子元素继承。</span><br></pre></td></tr></table></figure></p><p><strong>什么是盒子模型</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一般分为标准盒子模型和怪异盒子模型</span><br><span class="line">标准盒子模型的width = 元素content</span><br><span class="line">怪异盒子模型的width = 元素content + （padding + border） * 2</span><br></pre></td></tr></table></figure></p><p><strong>什么的BFC,什么元素会生成BFC,BFC的布局规则是什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BFC(块级格式化上下文)是一个独立的布局环境,其元素是不受外界影响的。</span><br><span class="line">只要是float值不为none，position不为static和relative的。</span><br><span class="line">display不是inline-block, table-cell, flex, table-caption,inline-flex的</span><br><span class="line">overflow值不为visible的都会生成BFC元素</span><br><span class="line">在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列</span><br></pre></td></tr></table></figure></p><p><strong>width与height设置的百分比是相对于谁计算，padding和margin呢</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width和height的百分比是相对于父容器计算</span><br><span class="line">padding和margin是相对于父元素的宽度计算的</span><br></pre></td></tr></table></figure></p><p><strong>如何设置一个元素垂直居中</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flex方式</span><br><span class="line">    display: flex justify-content:center; align-items: center;</span><br><span class="line">绝对定位</span><br><span class="line">    父元素 position: absolute;top: 0; bottom: 0; 子元素 margin: auto;</span><br></pre></td></tr></table></figure></p><p><strong>display:none和visibilty:hidden的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">display：none属性：</span><br><span class="line">    1. 不为对象保留物理空间</span><br><span class="line">    2. 对象从页面彻底的消失</span><br><span class="line">    3. 浏览器也不会解析此元素</span><br><span class="line">    4. 切换显示时页面会产生回流</span><br><span class="line">visible：hidden属性</span><br><span class="line">    1. 仅仅使元素不可见</span><br><span class="line">    2. 但其物理空间依旧存在类似于透明度为0</span><br><span class="line">    3. 切换显示时不产生回流</span><br><span class="line">    4. 性能较display会更好</span><br></pre></td></tr></table></figure></p><p><strong>相对布局和绝对布局,position: relative和absoulte</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">position: absoulte绝对布局</span><br><span class="line">    1. 元素脱离文档流</span><br><span class="line">    2. 会找寻父元素是否有position: relative属性，如果没有会逐级向上找，直到找到body。</span><br><span class="line">    3. 元素是相对于找到的父元素(position: relative 否则 body)定位。</span><br><span class="line">position: relative相对定位</span><br><span class="line">    1. 元素未脱离文档流</span><br><span class="line">    2. 会对文档流中其他元素的结构产生影响，例如子元素是绝对定位</span><br><span class="line">    3. 元素的原本位置依旧保留，视觉空间偏移</span><br></pre></td></tr></table></figure></p><p><strong>flex布局</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flex是专门为页面布局而产生的属性，针对于以前使用div+float+postion的布局方式。</span><br><span class="line">flex无疑是简单的很多很多。</span><br><span class="line">flex常用的属性:</span><br><span class="line">display: flex;  flex-wrap;  flex-direction; flex-flow等</span><br></pre></td></tr></table></figure></p><p><strong>block,inline-block,inline的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">block块元素</span><br><span class="line">    1. 独占一行，宽度自动填满父元素的宽度</span><br><span class="line">    2. 可以设置宽度高度，即使设置了宽度仍是独占一行</span><br><span class="line">    3. 可以设置padding和margin</span><br><span class="line">inline内联元素</span><br><span class="line">    1. 不独占一行，宽度随内容变化</span><br><span class="line">    2. width和height无效</span><br><span class="line">    3. padding和margin只有水平方向有效果，垂直方向没有效果</span><br><span class="line">inline-block</span><br><span class="line">    1. 是inline和block的结合体</span><br><span class="line">    2. 显示为inline，但是可以设置width,height,padding,margin等block的属性</span><br></pre></td></tr></table></figure></p><p><strong>position相关</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">position属性是指定元素在文档中的定位方式</span><br><span class="line">通过top,right,bottom,left来确定元素的位置</span><br><span class="line">定位类型有:static, relative, absolute, fixed ,sticky</span><br><span class="line">    static: 元素默认定位,top,right,left,bottom,z-index属性无效</span><br><span class="line">    relative: 仅仅视觉调整元素位置，而实际位置还在原位，会影响子元素的布局方式(absolute),table相关属性无效。</span><br><span class="line">    absolute: 不为元素预留空间，相对于最近的非static的祖先元素定位，可以设置外边距不和其他static边距重合。</span><br><span class="line">    fixed: 不为元素预留空间，通过屏幕视口(viewport)来指定元素位置,会创建新的层叠上下文,</span><br><span class="line">           当元素的祖先为transform非none时，容器由该视口改为该祖先。</span><br><span class="line">    sticky: 根据正常的static元素布局，相对于(BFC)和最近块元素祖先元素定位。当被粘性定位时，仍按照b未定位的位置定位。</span><br></pre></td></tr></table></figure></p><h2 id="JS相关"><a href="#JS相关" class="headerlink" title="JS相关"></a><span style="color:red">JS相关</span></h2><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a><span style="color:blue">跨域</span></h3><p><strong>jsonp的原理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.有src属性的标签都能跨域(img,script,iframe)等</span><br><span class="line">2.所以利用script来实现跨域，因为script只能请求js相关文件，所以需将远程服务器的数据装入js中，供客户端调用。</span><br><span class="line">3.于是json被发现了，它可以简单的描述复杂数据，还被js原生支持。客户端也可以很轻易的处理这种数据。</span><br><span class="line">4.所以客户端像调用脚本一样的，来调用跨域服务器上的js格式文件(json)。</span><br><span class="line">5.这种方式逐渐成为了一种非正式的传输协议，称之为jsonp，主要的特点就是用户需要提交一个callback，然后服务器</span><br><span class="line">   返回数据的时候就会通过这个callback包裹住，这样客户端就可以随心所欲的处理返回的数据。</span><br></pre></td></tr></table></figure></p><h3 id="es6相关"><a href="#es6相关" class="headerlink" title="es6相关"></a><span style="color:blue">es6相关</span></h3><p><strong>函数rest参数可以用其他名字替换吗</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rest是获取多余的参数和argument获取全部参数不同</span><br><span class="line">当然可以,</span><br><span class="line">只要形式为...变量名。就可以了</span><br><span class="line">例如 function add(a, ...values)</span><br></pre></td></tr></table></figure></p><p><strong>es6了解什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 箭头操作符</span><br><span class="line">2. 类的支持class</span><br><span class="line">3. 对象字面量不用写function 什么的了</span><br><span class="line">4. 字符串模板``这个符号</span><br><span class="line">5. 解构</span><br><span class="line">6. 默认参数值</span><br><span class="line">7. let与const关键字</span><br><span class="line">8. for of值遍历</span><br><span class="line">9. 模块export和import</span><br><span class="line">10. Map和Set</span><br><span class="line">11. Promises异步处理</span><br></pre></td></tr></table></figure></p><p><strong>every和some的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">every会测试所有元素是否都通过的函数的检测(&amp;&amp;与运算，所有元素通过才为true)</span><br><span class="line">some会测试某些元素是否通过函数的检测(||或运算，一个通过及为true)</span><br></pre></td></tr></table></figure></p><p><strong>call和apply的作用和区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call和apply用来调用函数，并用指定对象（第一个参数）替换函数的 this 值.改变this的指向。</span><br><span class="line">call的参数是一个一个的，而apply是一整个数组。</span><br></pre></td></tr></table></figure></p><p><strong>ES6新增的set()和map()有什么区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set一种类似于数组的数据结构，成员都是唯一的没有重复的值。</span><br><span class="line">可以接受的参数是一个数组或者类似数组的对象。</span><br><span class="line">Map是一种&quot;键-值&quot;的Hash结构，键可以由字符串，各种对象构成。</span><br></pre></td></tr></table></figure></p><p><strong>es6的symbol</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">symbol是一种新的基础类型，</span><br><span class="line">symbol的存储方式是键值相对，每一个symblo都是独一无二的。</span><br><span class="line">为了避免程序重复的变量而开发出来的。</span><br></pre></td></tr></table></figure></p><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a><span style="color:blue">异步处理</span></h3><p><strong>setTimeout什么时候执行</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout是一个宏任务，所以需要等其他宏任务以及他们的微任务执行完毕了。</span><br><span class="line">才执行setTimeout</span><br></pre></td></tr></table></figure></p><p><strong>事件循环</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">事件循环是为了处理异步任务而出现的。</span><br><span class="line">函数执行时的出栈入栈就称为事件循环。</span><br></pre></td></tr></table></figure></p><p><strong>ajax和fetch的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ajax是通过XMLHttpRequest实现的。</span><br><span class="line">fetch是window的方法,通过Promise来处理结果</span><br></pre></td></tr></table></figure></p><p><strong>ES6异步编程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 回调函数callback,容易产生回调地狱。</span><br><span class="line">2. Promise, 通过then方法加载回调函数，catch捕捉错误，但是then太多就会导致代码混乱。</span><br><span class="line">3. 协程，我没用过不知道，反正可以解决！</span><br><span class="line">4. Gennerator函数,yield, 可以暂停执行和恢复执行，所以能够解决异步。</span><br><span class="line">5. async和await</span><br></pre></td></tr></table></figure></p><p><strong>async和await是什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async 函数是什么？一句话，它就是 Generator 函数的语法糖。《ECMAScript 6 入门》</span><br><span class="line">async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</span><br><span class="line">async函数返回一个Promise对象，可以使用then方法添加回调函数，当函数执行的时候，一旦遇到await就会先返回，</span><br><span class="line">等到异步操作完成，再接着执行函数体内后面的语句。 这样就可以以同步的方式书写异步的程序了。</span><br><span class="line"></span><br><span class="line">await命令</span><br><span class="line">await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。</span><br><span class="line">await相当于暂停，并执行之后等待的函数，在执行await的函数</span><br></pre></td></tr></table></figure></p><p><strong>promise相关</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise是一种异步编程的解决方案，比传统的回调函数更合理。es提供了原生的Promise对象。</span><br><span class="line">Promise是一个容器，保存着未来才会结束的事件(通常是异步)。</span><br><span class="line">有三种状态,pending(进行中),fulfilled(已经成功),rejected(已经失败)</span><br><span class="line">只有异步操作才能决定当前是哪一种状态。</span><br><span class="line">Promise的构造函数提供了两个参数resolve和reject，</span><br><span class="line">resolve是讲Promise对象的状态从未完成变成完成，reject是将状态从未完成变成失败.</span><br><span class="line">Promise实例生成后会用then方法分别指定resolved状态和rejected状态的回调函数</span><br></pre></td></tr></table></figure></p><h3 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a><span style="color:blue">对象和类</span></h3><p><strong>js创建对象的几种方式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字面量</span><br><span class="line">工厂模式</span><br><span class="line">构造函数</span><br><span class="line">原型模式</span><br><span class="line">组合模式</span><br></pre></td></tr></table></figure></p><p><strong>继承的几种方式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原型链继承</span><br><span class="line">子类.prototype = new 父类()</span><br><span class="line"></span><br><span class="line">构造函数继承</span><br><span class="line">父类.call(this)</span><br><span class="line"></span><br><span class="line">组合继承</span><br><span class="line">父类.call(this)</span><br><span class="line"></span><br><span class="line">子类.prototype = new 父类()</span><br><span class="line">子类.prototype.constructor = 父类</span><br></pre></td></tr></table></figure></p><p><strong>es6的类中 静态属性和构造函数谁先加载 为什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">静态属性先加载，因为构造函数需要等待类的实例生成时才能触发，</span><br><span class="line">而静态属性是加载时便已经存在了。</span><br></pre></td></tr></table></figure></p><p><strong>静态属性和方法是类的还是实例的</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态属性和方法是属于类的。</span><br></pre></td></tr></table></figure></p><p><strong>怎么在外部调用静态属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.属性名</span><br></pre></td></tr></table></figure></p><p><strong>new生成一个对象的过程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建了一个原生对象 例如obj = new Object();</span><br><span class="line">获得对象的构造函数的prototype对象,并赋值给obj的prototype。</span><br><span class="line">call构造函数的内部方法，把其中的this赋值为新创建的对象，并传入参数</span><br><span class="line">执行构造函数,返回创建的对象   return this</span><br></pre></td></tr></table></figure></p><p><strong>js基本对象类型和引用对象类型的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基本类型有: string number boolean null undefined</span><br><span class="line">引用类型有: Funtion Array Object</span><br><span class="line"></span><br><span class="line">访问方式</span><br><span class="line">    基本类型，直接操作和访问变量实际的值</span><br><span class="line">    引用类型，值保存在内存中，js不允许直接访问内存，操作的时候时通过对象的引用</span><br><span class="line">存储的位置</span><br><span class="line">    基本类型，保存在栈中</span><br><span class="line">    引用类型，引用存放在栈中，实际对象在堆中</span><br></pre></td></tr></table></figure></p><p><strong>js如何实现继承？ES6 class如何实现的继承？与ES5的区别是什么？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js是通过原型链实现继承的</span><br><span class="line">es6 通过关键字 extends 实现继承的，实际还是通过原型链只不过是封装了。</span><br><span class="line">es5是通过原型和构造函数，es6是通过封装的关键字</span><br></pre></td></tr></table></figure></p><p><strong>Object和Function的关系</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Object和Function都是构造函数,所有的构造函数都是Function的实例，所以Object是Function的实例。</span><br><span class="line">2. Function.prototype是Object的实例对象。</span><br><span class="line">3. 实例对象的原型(proto)会指向其构造函数的prototype属性，Object.proto === Function.prototype,</span><br><span class="line">    Function.proto === Function.prototype, Funtion.prototype === Object.protoype</span><br><span class="line">4. 当访问一个属性值时，它会沿着原型链向上查找，直到找到或者到Object.prototypr.proto(null)为止。</span><br></pre></td></tr></table></figure></p><p><strong>说一下原型链</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js对象是基于原型链的。有原型和原型链的概念。</span><br><span class="line">原型很简单，就是你继承于谁。</span><br><span class="line">js的对象只有__proto__属性，而函数有prototype和__proto__属性。</span><br><span class="line">因为对象和函数都是通过Funtion的构造函数生成的。所以对象的__proto__ 是继承于Funtion的构造函数(prototype)的。</span><br><span class="line">而函数的prototype就是他自己的构造函数(prototype)。函数的__proto__是继承于Object的构造函数(prototype)因为一切都继承于Object</span><br><span class="line">但是Object的__proto__为Null</span><br></pre></td></tr></table></figure></p><p><strong>对象和类的区别，具一个例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类是对象的抽象概念，对象是类的具体表达。《PHP核心技术与最佳实践》</span><br><span class="line">类是抽象的，不具体的，一些东西可以归为一类，不占空间的。</span><br><span class="line">对象是具体的，是一个类的具体表达，占空间的。</span><br><span class="line">例如动物是一类，猫，狗就是对象。猫狗是具体存在的，而动物是抽象的。</span><br></pre></td></tr></table></figure></p><p><strong>你理解的面向对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">面向对象编程需要抽象的思维，把一些直观的东西需要抽象，但是代码量会大一些。</span><br><span class="line">例如我之前写过一个象棋项目，他就分了很多类，棋子类，棋盘类，规则类等。</span><br><span class="line">如果是面向过程，就不分这么多，直接就写很多函数，完成就OK，但是不好扩展。</span><br><span class="line">面向对象的优势是，扩展性强，复用性好，维护简单。</span><br></pre></td></tr></table></figure></p><p><strong>加new和不加的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加new返回构造函数的实例，不加new 如果没有return对象  就是undefined</span><br></pre></td></tr></table></figure></p><p><strong>原型链继承</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.prototype = new 要继承的对象()</span><br></pre></td></tr></table></figure></p><p><strong>es6 extends</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），</span><br><span class="line">然后再用子类的构造函数修改this。</span><br></pre></td></tr></table></figure></p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a><span style="color:blue">基本概念</span></h3><p><strong>script标签里面的defer和async</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">都是防止js加载阻塞而出现的。</span><br><span class="line">区别是defer会等dom加载完毕后，按顺序依次执行。</span><br><span class="line">async不会等dom加载完毕后执行，并且加载顺序是谁先加载完毕就执行。</span><br><span class="line">它们和放在&lt;/body&gt;之前的区别就是，它们在外面已经加载好了。 节约了一些时间。</span><br></pre></td></tr></table></figure></p><p><strong>web worker</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在Javascript单线程执行的基础上，开启一个子线程，进行程序处理，而不影响主线程的执行，当子线程执行完毕之后再回到主线程上，</span><br><span class="line">在这个过程中并不影响主线程的执行过程。</span><br></pre></td></tr></table></figure></p><p><strong>attachEvent和addEventListener的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">兼容不同。</span><br><span class="line">attachEvent支持IE7 IE8</span><br><span class="line">addEventListener支持主流浏览器。</span><br></pre></td></tr></table></figure></p><p><strong>匿名函数的作用域</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匿名函数具有全局性，所有通常指向window.</span><br></pre></td></tr></table></figure></p><p><strong>事件捕获,事件冒泡,事件委托</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事件的捕获和冒泡都属于事件流</span><br><span class="line">事件捕获是从父元素一层一层的向下捕获直到点击的元素。</span><br><span class="line">事件冒泡是从点击的元素一层一层的向父元素冒泡。</span><br><span class="line">事件委托基于事件冒泡的机制，例如原本在li上点击的事件，可以委托在ul上,委托父级元素执行事件。</span><br></pre></td></tr></table></figure></p><p><strong>循环绑定事件问题</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多个作用域绑定同一个闭包，导致变量共享</span><br><span class="line">闭包解决即可。</span><br></pre></td></tr></table></figure></p><p><strong>准确的判断js数据类型</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(obj)</span><br></pre></td></tr></table></figure></p><p><strong>setInterval与setTimeout的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setInterval会不停的调用函数，从调用开始就周期性的执行</span><br><span class="line">setTimeout只执行一次,是延迟函数</span><br></pre></td></tr></table></figure></p><p><strong>js数组有哪些方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">join(),push(),pop(),shift(),unshift(),reverse(),sort()</span><br><span class="line">concat(),slice(),splice()等</span><br></pre></td></tr></table></figure></p><p><strong>哪些方法会改变原数组，哪些不改变原数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">改变的方法有</span><br><span class="line">pop(),push(),reverse(),shift(),sort(),splice().unshift()</span><br><span class="line">不改变的方法有</span><br><span class="line">concat(),join(),slice(),toString(),valueOf()</span><br></pre></td></tr></table></figure></p><p><strong>数组遍历的方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foreach for in for of ruduce map</span><br></pre></td></tr></table></figure></p><p><strong>如何实现闭包</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数里面返回函数即可。</span><br></pre></td></tr></table></figure></p><p><strong>js深拷贝和浅拷贝</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果没有循环引用,没有函数。JSON.parse(JSON.stringify(obj))</span><br><span class="line">否则递归，判断当前是否为object。</span><br><span class="line">浅拷贝 Object.assign</span><br></pre></td></tr></table></figure></p><p><strong>如何改变this的指向</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call,apply,bind</span><br><span class="line">区别就是call和apply可以看做某个对象的方法，可以通过调用方法的方式来调用此函数</span><br><span class="line">call传一个一个的参数，apply传数组</span><br><span class="line">而bind是将某个函数绑定到某个对象上</span><br></pre></td></tr></table></figure></p><p><strong>js文件加载阻塞</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原因</span><br><span class="line">    JavaScript是单线程，所以在运行时其他事情不能被浏览器处理。</span><br><span class="line">而大多数浏览器都是单线程来处理这些业务，所以同一时间，只能执行一个任务。  </span><br><span class="line">这就导致了执行js时，其他页面无法工作。</span><br><span class="line">解决</span><br><span class="line">    1. 老办法，将js放在&lt;/body&gt;前，确定dom已经渲染了，才引入js。</span><br><span class="line">        然而这样还是会阻塞。</span><br><span class="line">    2.  defer和async属性，只针对外联js。</span><br><span class="line">        使用defer的&lt;script&gt;标签是按照他们排列的顺序执行</span><br><span class="line">        而使用async的&lt;script&gt;标签是不按他们在HTML中的排列顺序执行</span><br><span class="line">        这样就解析js时就不会产生阻塞了。</span><br></pre></td></tr></table></figure></p><p><strong>问==和===的区别,<code>typeof null</code>是什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==是判断值是否相同，如果类型不同，会自动转化类型，再对比值</span><br><span class="line">===是判断类型和值是否都相同</span><br><span class="line">typeof null的值为object， 一个既是对象，又不是对象的东西</span><br></pre></td></tr></table></figure></p><p><strong>变量提升、函数名提升问题，哪些情况会有变量、函数名的提升？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数声明是函数的声明和实现都被提升了。</span><br><span class="line">函数表达式和变量表达式只是其声明被提升了。</span><br><span class="line">函数名和变量名重复时，优先提升函数名.</span><br></pre></td></tr></table></figure></p><p><strong>什么是IIFE立即执行函数？如何实现？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">声明的同时立即调用这个函数</span><br><span class="line">(function foo()&#123;</span><br><span class="line">var a = 10;</span><br><span class="line">console.log(a);</span><br><span class="line">&#125;)();</span><br><span class="line">在函数声明后添加一个().</span><br><span class="line">IIFE的目的是为了隔离作用域，防止污染全局命名空间。</span><br></pre></td></tr></table></figure></p><p><strong>null和undefined的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null的typeof是object, undefined的typeof就是undefined</span><br><span class="line">null是一个空对象指针，undefined是声明了但是没有初始化</span><br><span class="line">javascript权威指南说，undefined是系统级的值空缺,而null是程序级的值空缺</span><br></pre></td></tr></table></figure></p><p><strong>函数柯里化</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一种高阶函数，把参数变为一个一个的传。</span><br><span class="line">直到收到所有参数后才执行。</span><br><span class="line">需要闭包和递归。 应用场景为延迟背景等.</span><br></pre></td></tr></table></figure></p><p><strong>服务端渲染</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. seo</span><br><span class="line">2. 首屏加载</span><br></pre></td></tr></table></figure></p><p><strong>typeof返回值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number, string, boolean, object, function, undefined, symbol</span><br></pre></td></tr></table></figure></p><p><strong>es6用了哪些提高工作效率的特性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">默认参数</span><br><span class="line">模板文本</span><br><span class="line">解构</span><br><span class="line">箭头函数</span><br><span class="line">promises</span><br><span class="line">let const 块作用域</span><br><span class="line">class </span><br><span class="line">modules</span><br></pre></td></tr></table></figure></p><p><strong>如何判断一个变量是否是数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. instanceof</span><br><span class="line">2. constructor</span><br><span class="line">3. toString()   Object.prototype.toString.call(arr) === &apos;[object Array]&apos;</span><br></pre></td></tr></table></figure></p><p><strong>js的哪些操作会实现隐式转换</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 递增递减</span><br><span class="line">2. 逻辑操作符</span><br><span class="line">3. 关系操作符</span><br><span class="line">4. 相等操作符</span><br></pre></td></tr></table></figure></p><p><strong>闭包的原理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">闭包的实现和以下几个原理有关:</span><br><span class="line">变量作用域: 全局变量，全局都能使用，函数内部定义的变量，仅能在函数内部使用。</span><br><span class="line">函数作用域: 在函数内声明的变量，在函数体内始终是可见的。</span><br><span class="line">作用域链: 作用域链式一个对象，它定义了该作用域内的变量，保证作用域的变量函数的访问。</span><br><span class="line">作用域链的创建: 定义一个函数时会保存一个作用域链，调用一个函数时，会创建一个新的对象来存储器局部变量，并添加进保存的作用域链上。</span><br><span class="line">                每次调用函数，都会创建新的作用域链，虽然内部代码相同，但是作用域链是不同的。</span><br><span class="line">垃圾回收机制: js有自动回收垃圾的机制，会定期把不再使用的变量销毁，释放内存。（只会销毁局部变量，全局变量是关闭浏览器时才销毁）</span><br><span class="line">闭包的原理就是： 函数的执行依赖于函数定义的时候的作用域链，所以函数执行的时候用的作用域链是定义时候创建的，但当执行的函数的作用域</span><br><span class="line">                域链和定义的作用域链不同时，就会出现问题！即一个函数嵌套一个函数并返回函数时就会产生闭包的情况。</span><br><span class="line">                当外部函数把嵌套函数作为返回值返回时，其执行结果仍然是局部变量的值，而不是全局变量的值。</span><br><span class="line">                这就是因为函数执行时用到的作用域链，其实是函数定义时创建的。不管该函数在何时何地执行，它通过作用域链最先找到的变量就是相同外部函数中定义的变量</span><br><span class="line">                而闭包正是利用这种特性实现的：闭包可以捕捉到局部变量或参数，并一直保存下来，使其不会被当成垃圾回收。</span><br><span class="line">注意： 如果闭包使用不得当，会导致大量的局部变量没有回收，导致内存泄露！所以看看那些大框架是怎么使用闭包的吧！</span><br></pre></td></tr></table></figure></p><p><strong>箭头函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以简化代码.</span><br><span class="line">但是不绑定this,和arguments</span><br></pre></td></tr></table></figure></p><p><strong>垃圾回收机制的理解</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">垃圾回收机制是一种自动释放变量的机制。以免变量一直占用内存。</span><br><span class="line">js的垃圾回收机制是，当js检测到一个变量之后不会再使用的时候，就会把它释放。</span><br><span class="line">js的垃圾回收的两种方式，标记清除和引用计数</span><br><span class="line">1. 标记清除</span><br><span class="line">    这是js最常用的回收方式，当变量进入执行环境时，就标记为“进入环境”，</span><br><span class="line">    进入执行环境的变量不能释放，因为他们可能随时用到，当变量离开环境的时候，</span><br><span class="line">    则将其标记为“离开环境”，然后去掉环境中的变量和标记，然后垃圾收集器来搜集。</span><br><span class="line">    例如进入函数，函数里面的标记就变为进入环境，当离开环境后，局部变量就会被回收。</span><br><span class="line">2. 引用计数</span><br><span class="line">    不太常见的回收策略，跟踪每个值被引用的次数，当一个变量已经没有引用类型引用的时候，</span><br><span class="line">    就会把他回收。</span><br><span class="line">    例如a=3，现在a引用的是3，但当a=4的时候，这里的3仍在，并不是被替换。</span><br><span class="line">    而是a引用到4了，此时3已经没有任何变量引用它，它就会被回收了！</span><br></pre></td></tr></table></figure></p><p><strong>AMD和commonjs是怎么使用，怎么配置，有什么好处</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两者都是为了实现模块化编程的，</span><br><span class="line">Commonjs是服务端的，比如Node,是同步加载不同模块文件，</span><br><span class="line">ADM是异步模块定义，是适用于浏览器端的模块加载方式，是异步加载的方式，例如ajax</span><br><span class="line">所以浏览器时无法使用Commonjs的模式(除非有四个node环境的变量)</span><br><span class="line">好处就是，有了模块，我们可以更方便的使用别人的代码，想要什么功能，就加载什么模块。</span><br><span class="line">怎么配置？目前还没研究啊!</span><br></pre></td></tr></table></figure></p><p><strong>var let const区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var 变量提升，除非在function内，</span><br><span class="line">let 块变量，没有变量提升，未定义前，不能使用</span><br><span class="line">const 块常量， 不能更改值</span><br></pre></td></tr></table></figure></p><p><strong>伪数组如何转为数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 遍历</span><br><span class="line">2. Object.prototype.slice.call(array)</span><br><span class="line">3. from</span><br></pre></td></tr></table></figure></p><p><strong>foreach和map</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">都不会改变数组，</span><br><span class="line">foreach 只返回callback的参数</span><br><span class="line">map 会创建一个新数组</span><br></pre></td></tr></table></figure></p><h2 id="JQ相关"><a href="#JQ相关" class="headerlink" title="JQ相关"></a><span style="color:red">JQ相关</span></h2><p><strong>为什么Jquery只需要$即可生成Jquery对象</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Jquery3.X的源码文件，能够解释一切。</span><br><span class="line">if ( !noGlobal ) &#123;</span><br><span class="line">window.jQuery = window.$ = jQuery;</span><br><span class="line">&#125;</span><br><span class="line">return jQuery;</span><br><span class="line">&#125; );</span><br><span class="line">所以$() === jQuery()</span><br><span class="line">还是通过构造函数生成的。</span><br></pre></td></tr></table></figure></p><p> <strong>既然是构造函数,为什么不用new呢</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Jquery3.X的源码能说明一切</span><br><span class="line">jQuery = function( selector, context ) &#123;</span><br><span class="line">return new jQuery.fn.init( selector, context );</span><br><span class="line">&#125;,</span><br><span class="line">执行Jquery后，return一个new的Jquery并且初始化.</span><br><span class="line">没毛病，还是正常的new class。只是巧妙的封装了。</span><br></pre></td></tr></table></figure></p><p> <strong>JQ中 $(selector)用原生JavaScript哪个能实现</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">querySelector 选择一个元素</span><br><span class="line">querySelectorAll 选择多个元素</span><br></pre></td></tr></table></figure></p><p> <strong>如何元素实现$.on方法</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">元素原型添加一个on方法</span><br><span class="line">Element.prototype.on = function(type,fn)&#123;</span><br><span class="line">    window.addEventListener ? this.addEventListener(type,fn) : this.attachEvent(&apos;on&apos; + type,fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.querySelector(&apos;.aon&apos;).on(&apos;click&apos;,function()&#123;</span><br><span class="line">    alert(this.innerHTML);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p> <strong>jQuery ready原理、window.onload区别</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ready: DOM结构加载完毕,就可执行,可多次执行</span><br><span class="line">onload: 网页必须全部加载完,才能执行,只能执行一次</span><br></pre></td></tr></table></figure></p><p> <strong>documnent.ready window.onload谁先执行</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.ready 是dom加载完毕就执行</span><br><span class="line">window.onload 是页面所有资源加载完毕才开始执行</span><br></pre></td></tr></table></figure></p><h2 id="VUE相关"><a href="#VUE相关" class="headerlink" title="VUE相关"></a><span style="color:red">VUE相关</span></h2><p><strong>vue的特点</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.MVVM框架，数据双向绑定</span><br><span class="line">2.轻量级的渐进式框架</span><br><span class="line">3.组件单向流通</span><br><span class="line">4.有自己的指令</span><br><span class="line">5.大型单页式的网站</span><br></pre></td></tr></table></figure></p><p><strong>vue组件之间的通信</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vue是单向数据通信</span><br><span class="line">父传子 props</span><br><span class="line">子传父 $on, $emit</span><br><span class="line">非父子，可以通过使用一个空的Vue实例作为中央事件总线</span><br></pre></td></tr></table></figure></p><p><strong>vue-router 对应的组件状态存在哪儿</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage</span><br></pre></td></tr></table></figure></p><p><strong>vue双向数据绑定的原理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue是基于object.defneProperty()属性拦截器实现的</span><br></pre></td></tr></table></figure></p><p><strong>vue key的作用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提高列表的渲染速度</span><br><span class="line">标识元素的独立性。</span><br></pre></td></tr></table></figure></p><p><strong>vue的生命周期以及每个周期用来干什么的</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate 实例创建前,此时无法读取data、 methods</span><br><span class="line">created 实例创建后，这是已经有了data,属性和方法的运算，watch/event事件等，但是mount还未挂载,数据还未渲染。</span><br><span class="line">beforeMount 挂载开始前，相关的render调用</span><br><span class="line">mounted el的dom节点被vm.$el替换，实例数据在dom上渲染</span><br><span class="line">beforeUpdate 数据更新是调用，不进行dom重新渲染， 在数据更新前可以进行状态处理</span><br><span class="line">updated: 数据更新并且dom渲染，这时dom已经更新，每次数据更新都会执行updated</span><br><span class="line">beforeDestory 实例销毁前调用</span><br><span class="line">destroyed vue实例销毁后调用，vue所有的东西都会被解绑，所有的子实例也会销毁</span><br><span class="line">应用场景</span><br><span class="line">created 异步数据请求，初始化数据</span><br><span class="line">mounted 挂载元素内的dom节点获取</span><br><span class="line">nextTick 针对单一事件更新数据后立即操作dom</span><br><span class="line">updated 任何数据的更新，做同一的业务逻辑处理</span><br><span class="line">watch: 监听数据变化，做出相应的处理</span><br></pre></td></tr></table></figure></p><p><strong>vuex包括什么？对action理解的怎么样</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vuex是各个组件的状态管理器，也成为前端数据库吧。</span><br><span class="line">state: 状态的数据结构</span><br><span class="line">actions: 从服务端获取数据，（异步）调用commit来改变状态</span><br><span class="line">mutations: 唯一能改变状态的地方</span><br><span class="line">getters: 组件获取状态器的数据，需通过这里。</span><br><span class="line">modules: 一个store可以拆分为多个，每个都有自己的state,actions等</span><br><span class="line">actions我一般用来获取服务器的数据，更新，因为mutations是同步的，不行，而actions是异步的。</span><br></pre></td></tr></table></figure></p><p><strong>axios的原理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios是基于Promise的HTTP库</span><br><span class="line">请求还是通过XMLHttpRequest对象实现的</span><br></pre></td></tr></table></figure></p><p><strong>vuex解决的问题是什么</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.多个组件共享状态时，单向数据流的简洁性很容易被破坏：</span><br><span class="line">2.多个视图依赖于同一状态。</span><br><span class="line">3.来自不同视图的行为需要变更同一状态。</span><br></pre></td></tr></table></figure></p><h2 id="网络原理相关"><a href="#网络原理相关" class="headerlink" title="网络原理相关"></a><span style="color:red">网络原理相关</span></h2><p><strong>http和https的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP：超文本传输协议，明文传输，连接端口是80。    </span><br><span class="line">HTTPS：加密传输，是Http+ssl(安全套接字)协议构建的，端口是443，需要申请ca证书。</span><br></pre></td></tr></table></figure></p><p><strong>浏览器输入网址到页面渲染全过程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">其实原理挺复杂的，各方各面都有涉及，就写简约一点。</span><br><span class="line">    1. 浏览器把输入的域名进行dns解析，得到ip地址。</span><br><span class="line">    2. 通过ip和arp地址找到目标服务器地址。</span><br><span class="line">    3. 进行tcp连接。</span><br><span class="line">    4. 浏览器发送请求，等待响应。</span><br><span class="line">    5. 服务器处理请求，开始响应。</span><br><span class="line">    6. 浏览器收到响应，得到html代码。</span><br><span class="line">    7. 渲染页面。</span><br></pre></td></tr></table></figure></p><p><strong>HTTP头部</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">accept 客户端可以接受的MIME类型</span><br><span class="line">Cache-Control 缓存 </span><br><span class="line">content-type 请求中的媒体类型 </span><br><span class="line">referer 告诉服务器url的地址 </span><br><span class="line">cookie</span><br><span class="line">Connection 连接</span><br></pre></td></tr></table></figure></p><p><strong>HTTP1.0 HTTP1.1 HTTP2.0的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Http1.0和1.1的区别主要是长连接，HOST虚拟站点</span><br><span class="line">Http1.1和2.0的区别主要是服务器推送,加密传输,二进制格式,多路复用</span><br></pre></td></tr></table></figure></p><p><strong>HTTP常见状态码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">200 请求成功</span><br><span class="line">301 资源已经转移了</span><br><span class="line">302 请求的网页被重定向到新的地址</span><br><span class="line">304 请求成功，但是文档并没有改变</span><br><span class="line">401 用户验证</span><br><span class="line">403 服务器接受请求，但是拒绝处理</span><br><span class="line">404 找不到资源</span><br><span class="line">500 服务器内部错误</span><br></pre></td></tr></table></figure></p><p><strong>HTTP 参数放在header和body的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header一般放cookie等信息</span><br><span class="line">body是放post的数据</span><br><span class="line">header不够安全</span><br></pre></td></tr></table></figure></p><p><strong>HTTP和SOCKET的区别,为什么SOCKET更快</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP是一个协议, 短链接</span><br><span class="line">Socket是一个套接字接口, 长连接</span><br><span class="line">因为Socket不用反复请求了。</span><br></pre></td></tr></table></figure></p><p><strong>状态码304</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，</span><br><span class="line">则服务器应当返回这个304状态码。简单的表达就是：客户端已经执行了GET，但文件未变化。</span><br></pre></td></tr></table></figure></p><p><strong>TCP和UDP的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TCP是面向连接的传输方式(三次握手),UDP是非连接的传输方式</span><br><span class="line">TCP的数据按序到达，不错误，不丢失，不重复，UDP尽最大努力交付，不保证可靠。</span><br><span class="line">TCP面向字节流，UDP面向报文</span><br><span class="line">TCP是点对点，UDP支持一对一，一对多，多对一，多对多 </span><br><span class="line">TCP是全双工的可靠信道，UDP是不可靠信道</span><br><span class="line">TCP首部开销20字节，UDP首部开销8字节</span><br></pre></td></tr></table></figure></p><p> <strong>CDN是什么</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内容分发系统,会实时根据网络状态，负载节点等各种情况，找到用户最优的节点。</span><br><span class="line">提高用户访问的响应速度。</span><br></pre></td></tr></table></figure></p><p> <strong>web socket</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为了解决服务端向客户端发起请求，而出现的（轮询并不好）。</span><br><span class="line">是一种服务器推送技术，客户端和服务器都可以互相发生信息</span><br></pre></td></tr></table></figure></p><p> <strong>工作在各个层的协议</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">物理层: RJ45 CLOCK IEEE802.3(中继器, 集线器, 网关)</span><br><span class="line">链路层: PPP FR HDLC VLAN MAC(网桥, 交换机)</span><br><span class="line">网络层: IP ICMP ARP RARP OSPF IPX RIP IGRP(路由器)</span><br><span class="line">传输层: TCP(三次握手可靠传输) UDP(非连接传输) SPX</span><br><span class="line">会话层: NFS SQL NETBIOS RPC</span><br><span class="line">表示层: JPEG MPEG ASII</span><br><span class="line">应用层: FTP DNS TELNET SMTP HTTP WWW NFS</span><br></pre></td></tr></table></figure></p><p><strong>四次挥手的time-wait</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了获取到最后一个报文。</span><br></pre></td></tr></table></figure></p><p><strong>XSS脚本攻击</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">防御， 不然用户输入javascript，特殊字符转义等。</span><br></pre></td></tr></table></figure></p><p><strong>CSRF</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过冒充网站信任的用户，来入侵系统。</span><br><span class="line">加双cookie？</span><br></pre></td></tr></table></figure></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><span style="color:red">其他</span></h2><p><strong>首屏加载优化</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 除了首屏的图片，其他的图片都采用懒加载。</span><br><span class="line">2. 其他的和上面前端优化差不多</span><br><span class="line">3. 其实我也听说过一种叫做服务端渲染的技术，SSR？</span><br></pre></td></tr></table></figure></p><p><strong>排序算法有哪些</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，</span><br><span class="line">而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</span><br><span class="line">主要是内部排序</span><br><span class="line">直接插入排序(稳定)：设置标兵，标兵是前n个元素中最大(小)的元素，后面的与之相比较，大(小)则交换。</span><br><span class="line">希尔排序(不稳定)：减少增量排序，按数组增量分组。例如增量为2[2,3,1,4]分为[2,1][3,4]分别排序，然后合并。</span><br><span class="line">简单选择排序(不稳定)：每一轮选择第n大的数字与第n个位置交换。(例如最大的数位置和第一个位置交换);</span><br><span class="line">堆排序(不稳定)：将数组排列成堆，每个元素都与堆顶元素比较，将堆顶元素沉入堆底，重复操作即可。</span><br><span class="line">冒泡排序(稳定)：相邻元素第一个比第二个元素大(小)就交换，每一对比较，一轮下来最大最小就会在最后。比完即可。</span><br><span class="line">快速排序(不稳定)：左指针右指针和一个基数，左右指针重合的时候两边分别比基数大和基数小，然后再循环以上步骤即可。</span><br><span class="line">归并排序(稳定)：分治法，数组对半拆分直到不可分，然后逐渐合并排序，即可。</span><br><span class="line">桶排序(稳定)：把数组分在各个子区间，然后各个子区间分别排序，最后合并排序，即可。</span><br><span class="line">基数排序(稳定)：桶排序的扩展，将整数按位数切割排序，不足补0。即可。</span><br></pre></td></tr></table></figure></p><p><strong>MD5 和SHA-1的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">都是MD4发展来的。</span><br><span class="line">SHA的摘要比MD5多32比特.速度比MD5慢。</span><br></pre></td></tr></table></figure></p><p><strong>前端性能优化</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 减少Http请求（图片绘制成一张，然后客户端拆分）</span><br><span class="line">2. 使用CDN</span><br><span class="line">3. 添加Expires头,缓存组件</span><br><span class="line">4. 压缩组件，gzip什么的</span><br><span class="line">5. 样式表放在头部(避免白屏)</span><br><span class="line">6. 脚本放在底部（避免阻塞）</span><br><span class="line">7. 使用外部js和css，因为浏览器可能会缓存它们</span><br><span class="line">8. 避免css表达式</span><br><span class="line">9. 精简js和css代码</span><br><span class="line">10. 减少iframe的个数</span><br><span class="line">11. 预加载，延迟加载的合理应用。</span><br></pre></td></tr></table></figure></p><p><strong>MVVM和MVC的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MVVM是将&quot;数据模型数据双向绑定&quot;的思想作为核心，因此View和Model没有联系，通过ViewModel进行交互。  </span><br><span class="line">因此试图变化的数据会修改数据源，而数据源的变化也会反应到视图上。</span><br><span class="line">MVC还是传统的方式，只是逻辑分离了。用户操作视图(view0，反应到控制器(业务逻辑)，控制器调用模型(数据持久化)，最后反馈到视图。</span><br></pre></td></tr></table></figure></p><p><strong>模块化和组件化的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">组件则包含了 template、style 和 script，而它的 Script 可以由各种模块组成。</span><br><span class="line">组件化就是做一个知乎，把导航栏拆成一个组件，一个一个回答区域拆成一个组件，编辑区是一个组件，页脚是一个组件</span><br><span class="line">包含了html、css、js代码，可以简单理解为页面的一块。 </span><br><span class="line"></span><br><span class="line">Module模式的基本特征：</span><br><span class="line">模块化，可重用</span><br><span class="line">封装了变量和function，和全局的namaspace不接触，松耦合</span><br><span class="line">只暴露可用public的方法，其它私有方法全部隐藏</span><br></pre></td></tr></table></figure></p><p><strong>DNS查询过程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hosts静态文件查询</span><br><span class="line">本地(域)服务器查找</span><br><span class="line">顶级域服务器查找</span><br><span class="line">在顶级域服务器向下查找</span><br></pre></td></tr></table></figure></p><p><strong>进程和线程的区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程是资源分配的基本单位，线程是任务执行的最小单位。</span><br><span class="line">一个线程只能附属于一个进程，一个进程有多个线程。</span><br><span class="line">并发的最小单位是多进程。多线程允许一个进程同一时刻执行多个任务。</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>前途漫漫，耐心等待。</p>]]></content>
      
      <categories>
          
          <category> 备战系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TP5源码分析之Db类实现</title>
      <link href="/2018/08/10/TP5%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BDb%E7%B1%BB%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/08/10/TP5%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BDb%E7%B1%BB%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>从TP3.2到TP5，已经使用了TP框架快两年了。自认为使用TP处理一般的业务不成问题了。<br>可是，却从来没有深究过TP是如何实现这些功能的，仅仅只是会调用API而已，也不敢动框架的代码。<br>所以现在就整理一系列的文章来研究一下TP5的底层源码，设计模式，思想等。<br>额！算是开始一个坑吧。从最经典的Db类开始吧！ gogogo！<br><a id="more"></a></p><h3 id="对Db类的初识"><a href="#对Db类的初识" class="headerlink" title="对Db类的初识"></a>对Db类的初识</h3><p>一直觉得TP5的Db类是很方便的，只需要更改一下database配置文件即可连接各种数据库。<br>个人觉得还是挺强大的，他是如何通过配置文件更改一个值就能调用不同的数据库，这让我很是疑惑。<br>所以来研究一下吧，不过我刚看了一本书《PHP的核心技术与最佳实践》，了解了通过工厂模式是可以完成这个要求的。<br>不过还是看一下TP5是怎么实现的吧。</p><h3 id="Db类的相关文件分析"><a href="#Db类的相关文件分析" class="headerlink" title="Db类的相关文件分析"></a>Db类的相关文件分析</h3><p>本系列的部分细节参考了此文档<a href="https://www.kancloud.cn/zmwtp/tp5/155311" target="_blank" rel="noopener">戳我可见</a><br><strong>文件thinkphp是TP5的核心库</strong><br>而<code>thinkphp\think</code>目录下是我们各个类的入口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此目录下有一个Db.php是Db类的入口。</span><br></pre></td></tr></table></figure></p><p>TP5的Db类文件夹目录为:thinkphp\think\db<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">此文件夹为Db类的具体实现</span><br><span class="line">有如下文件</span><br><span class="line">db</span><br><span class="line">    builder Db驱动类</span><br><span class="line">        Mysql.php   Mysql数据库驱动</span><br><span class="line">        Pgsql.php   Pgsql数据库驱动</span><br><span class="line">        Sqlite.php  Sqlite数据库驱动</span><br><span class="line">        Sqlsrv.php  Sqlsrv数据库驱动</span><br><span class="line">    connector   Db连接器类</span><br><span class="line">        Mysql.php   Mysql数据库连接</span><br><span class="line">        Pgsql.php   Pgsql数据库连接</span><br><span class="line">        pgsql.sql   Pgsql类型转换</span><br><span class="line">        Sqlite.php  Sqlite数据库连接</span><br><span class="line">        Sqlsrv.php  Sqlsrv数据库连接</span><br><span class="line">    exception   Db错误类</span><br><span class="line">        BindParamException.php  Pdo参数绑定异常</span><br><span class="line">        DataNotFoundException.php   字段没有找到</span><br><span class="line">        ModelNotFoundException.php  模型不存在</span><br><span class="line">    Builder.php Db的抽象驱动类，通过此类构建对应的Db驱动类</span><br><span class="line">    Connection.php Db的抽象连接器类，通过此类连接对应Db连接器类</span><br><span class="line">    Query.php 将所有的Sql方法封装成一个类。</span><br></pre></td></tr></table></figure></p><h3 id="Db入口类分析"><a href="#Db入口类分析" class="headerlink" title="Db入口类分析"></a>Db入口类分析</h3><p>一般我们调用Db类是需要<code>use thinkphp\Db</code>,这文件就是我们的入口文件，所以我们看看他的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">namespace think; </span><br><span class="line"></span><br><span class="line">use think\db\Connection; </span><br><span class="line">use think\db\Query;</span><br><span class="line">class Db &#123;</span><br><span class="line">    // 数据库连接实例</span><br><span class="line">    private static $instance = [];</span><br><span class="line">    // 查询次数</span><br><span class="line">    public static $queryTimes = 0;</span><br><span class="line">    // 执行次数</span><br><span class="line">    public static $executeTimes = 0;</span><br><span class="line">    //   数据库初始化,并取得数据库类实例</span><br><span class="line">    public static function connect($config = [], $name = false)&#123;</span><br><span class="line">         .....先省略</span><br><span class="line">    &#125;</span><br><span class="line">    // 清除所有的实例</span><br><span class="line">    public static function clear() &#123;</span><br><span class="line">         self::$instance = null; // 很粗暴嘛</span><br><span class="line">    &#125;</span><br><span class="line">    // 数据库连接参数解析</span><br><span class="line">    private static function parseConfig($config)&#123;</span><br><span class="line">         ....先省略</span><br><span class="line">    &#125;</span><br><span class="line">    // DSN解析 把返回的参数解析一下 提取需要连接的关键字</span><br><span class="line">    private static function parseDsn($dsnStr)&#123;</span><br><span class="line">         ...先省略</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用驱动类的方法</span><br><span class="line">    public static function __callStatic($method, $params)&#123;</span><br><span class="line">          ...先省略</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是Db入口类的基本目录结构。<br>首先分析头部,命名空间为think,class为Db说明我们的入口没错。然后use两个类，一个连接器类，一个Query类。<br>看一看此类的各个方法，发现主要是初始化+解析config的配置。  </p><h4 id="首先看看Db入口类是如何获取到database里面的参数的"><a href="#首先看看Db入口类是如何获取到database里面的参数的" class="headerlink" title="首先看看Db入口类是如何获取到database里面的参数的"></a>首先看看Db入口类是如何获取到database里面的参数的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">database的配置是通过parseConfig方法获取到的，代码如下</span><br><span class="line">private static function parseConfig($config)</span><br><span class="line">    &#123;</span><br><span class="line">        if (empty($config)) &#123;</span><br><span class="line">            // 这里引入的database文件哟!!!</span><br><span class="line">            $config = Config::get(&apos;database&apos;);</span><br><span class="line">        &#125; elseif (is_string($config) &amp;&amp; false === strpos($config, &apos;/&apos;)) &#123;</span><br><span class="line">            // 支持读取配置参数</span><br><span class="line">            $config = Config::get($config);</span><br><span class="line">        &#125;</span><br><span class="line">        if (is_string($config)) &#123;</span><br><span class="line">            return self::parseDsn($config);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return $config;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里是通过了一个助手函数config把database里面的参数返回了，这样我们就得到了database的参数。  </p><h4 id="那我们看看database里面是什么样的呢"><a href="#那我们看看database里面是什么样的呢" class="headerlink" title="那我们看看database里面是什么样的呢?"></a>那我们看看database里面是什么样的呢?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">database在application目录下有，当然每一个模块下面也可以新建。</span><br><span class="line">return [</span><br><span class="line">    // 数据库类型</span><br><span class="line">    &apos;type&apos;           =&gt; &apos;&apos;,</span><br><span class="line">    // 服务器地址</span><br><span class="line">    &apos;hostname&apos;       =&gt; &apos;&apos;,</span><br><span class="line">    // 数据库名</span><br><span class="line">    &apos;database&apos;       =&gt; &apos;&apos;,</span><br><span class="line">    // 用户名</span><br><span class="line">    &apos;username&apos;       =&gt; &apos;&apos;,</span><br><span class="line">    // 密码</span><br><span class="line">    &apos;password&apos;       =&gt; &apos;&apos;,</span><br><span class="line">    // 端口</span><br><span class="line">    &apos;hostport&apos;       =&gt; &apos;3306&apos;,</span><br><span class="line">    // 连接dsn</span><br><span class="line">    &apos;dsn&apos;            =&gt; &apos;&apos;,</span><br><span class="line">    // 数据库连接参数</span><br><span class="line">    &apos;params&apos;         =&gt; [],</span><br><span class="line">    // 数据库编码默认采用utf8</span><br><span class="line">    &apos;charset&apos;        =&gt; &apos;utf8&apos;,</span><br><span class="line">    // 数据库表前缀</span><br><span class="line">    &apos;prefix&apos;         =&gt; &apos;qy_&apos;,</span><br><span class="line">    // 数据库调试模式</span><br><span class="line">    &apos;debug&apos;          =&gt; true,</span><br><span class="line">    // 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器)</span><br><span class="line">    &apos;deploy&apos;         =&gt; 0,</span><br><span class="line">    // 数据库读写是否分离 主从式有效</span><br><span class="line">    &apos;rw_separate&apos;    =&gt; false,</span><br><span class="line">    // 读写分离后 主服务器数量</span><br><span class="line">    &apos;master_num&apos;     =&gt; 1,</span><br><span class="line">    // 指定从服务器序号</span><br><span class="line">    &apos;slave_no&apos;       =&gt; &apos;&apos;,</span><br><span class="line">    // 是否严格检查字段是否存在</span><br><span class="line">    &apos;fields_strict&apos;  =&gt; true,</span><br><span class="line">    // 数据集返回类型 array 数组 collection Collection对象</span><br><span class="line">    &apos;resultset_type&apos; =&gt; &apos;\think\Collection&apos;,</span><br><span class="line">    // 是否自动写入时间戳字段</span><br><span class="line">    &apos;auto_timestamp&apos; =&gt; true,</span><br><span class="line">    // 是否需要进行SQL性能分析</span><br><span class="line">    &apos;sql_explain&apos;    =&gt; false,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>可以看见database文件把数据return了回来，所以可以获取到里面配置的所有内容，这样的解耦使我们的配置更加简便，不错！  </p><h4 id="然后看看最核心的连接类是如何执行的呢？"><a href="#然后看看最核心的连接类是如何执行的呢？" class="headerlink" title="然后看看最核心的连接类是如何执行的呢？"></a>然后看看最核心的连接类是如何执行的呢？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">如何通过配置文件即可连接相对于的数据库类呢？</span><br><span class="line">public static function connect($config = [], $name = false)</span><br><span class="line">    &#123;</span><br><span class="line">        if (false === $name) &#123;</span><br><span class="line">            $name = md5(serialize($config));</span><br><span class="line">        &#125;</span><br><span class="line">        if (true === $name || !isset(self::$instance[$name])) &#123;</span><br><span class="line">            // 解析连接参数 支持数组和字符串</span><br><span class="line">            $options = self::parseConfig($config);</span><br><span class="line">            if (empty($options[&apos;type&apos;])) &#123;</span><br><span class="line">                throw new \InvalidArgumentException(&apos;Undefined db type&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 就是这句代码哦，实现的加载不同的连接器哟！！！</span><br><span class="line">            $class = false !== strpos($options[&apos;type&apos;], &apos;\\&apos;) ? $options[&apos;type&apos;] : &apos;\\think\\db\\connector\\&apos; . ucwords($options[&apos;type&apos;]);</span><br><span class="line">            // 记录初始化信息</span><br><span class="line">            if (App::$debug) &#123;</span><br><span class="line">                Log::record(&apos;[ DB ] INIT &apos; . $options[&apos;type&apos;], &apos;info&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (true === $name) &#123;</span><br><span class="line">                $name = md5(serialize($config));</span><br><span class="line">            &#125;</span><br><span class="line">            self::$instance[$name] = new $class($options);</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance[$name];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>好吧，还是很经典的工厂模式。通过传入的配置参数，引入对应的文件。学习了，的确很方便！<br>到目前为止已经能够获取database的参数了，也能初始化不同的连接器了，还差一个查询方法了。<br>是的，还有一个<code>use think\db\Query</code>还没使用呢！对吧。</p><h4 id="驱动类的实现"><a href="#驱动类的实现" class="headerlink" title="驱动类的实现"></a>驱动类的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TP5把所有的SQL都通过PDO封装了，意思是无论你是什么数据库，查询的关键字都是这些！方便吧。</span><br><span class="line"> // 调用驱动类的方法</span><br><span class="line"> public static function __callStatic($method, $params)</span><br><span class="line"> &#123;</span><br><span class="line">     // 自动初始化数据库</span><br><span class="line">     return call_user_func_array([self::connect(), $method], $params);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>魔术方法，调用静态方法，每次调用前都会初始化数据库,并传入方法和参数。<br>然后因为引入的连接器不同，所以会调用相对于的构建类他们都继承builder，而builder封装了所有的查询方法。<br>这样就可以实现封装所有数据库的查询方法了！<br><strong><em>接下来看看那两个use分别是什么吧</em></strong></p><h3 id="Connection连接类"><a href="#Connection连接类" class="headerlink" title="Connection连接类"></a>Connection连接类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">db文件下有connector文件夹，封装了每一种数据库的连接方式，他们都继承于connection</span><br><span class="line">他们绑定了相对于的构建器。例如： </span><br><span class="line">connector下的Mysql.php</span><br><span class="line">protected $builder = &apos;\\think\\db\\builder\\Mysql&apos;;</span><br><span class="line">所以只需要连接的时候判断类型，就会获得相对于的builder构建器</span><br><span class="line">然后主要看它们的父类Connection连接器</span><br><span class="line">代码很多，截取最主要的吧</span><br><span class="line">abstract class Connection</span><br><span class="line">&#123;</span><br><span class="line">    protected $config = [</span><br><span class="line">         // 数据库类型</span><br><span class="line">         &apos;type&apos;            =&gt; &apos;&apos;,</span><br><span class="line">         // 服务器地址</span><br><span class="line">         &apos;hostname&apos;        =&gt; &apos;&apos;,</span><br><span class="line">         // 数据库名</span><br><span class="line">         &apos;database&apos;        =&gt; &apos;&apos;,</span><br><span class="line">         // 用户名</span><br><span class="line">         &apos;username&apos;        =&gt; &apos;&apos;,</span><br><span class="line">         // 密码</span><br><span class="line">         &apos;password&apos;        =&gt; &apos;&apos;,</span><br><span class="line">         // 端口</span><br><span class="line">         &apos;hostport&apos;        =&gt; &apos;&apos;,</span><br><span class="line">         // 连接dsn</span><br><span class="line">         &apos;dsn&apos;             =&gt; &apos;&apos;,</span><br><span class="line">         // 数据库连接参数</span><br><span class="line">         &apos;params&apos;          =&gt; [],</span><br><span class="line">         // 数据库编码默认采用utf8</span><br><span class="line">         &apos;charset&apos;         =&gt; &apos;utf8&apos;,</span><br><span class="line">         // 数据库表前缀</span><br><span class="line">         &apos;prefix&apos;          =&gt; &apos;&apos;,</span><br><span class="line">         // 数据库调试模式</span><br><span class="line">         &apos;debug&apos;           =&gt; false,</span><br><span class="line">         // 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器)</span><br><span class="line">         &apos;deploy&apos;          =&gt; 0,</span><br><span class="line">         // 数据库读写是否分离 主从式有效</span><br><span class="line">         &apos;rw_separate&apos;     =&gt; false,</span><br><span class="line">         // 读写分离后 主服务器数量</span><br><span class="line">         &apos;master_num&apos;      =&gt; 1,</span><br><span class="line">         // 指定从服务器序号</span><br><span class="line">         &apos;slave_no&apos;        =&gt; &apos;&apos;,</span><br><span class="line">         // 是否严格检查字段是否存在</span><br><span class="line">         &apos;fields_strict&apos;   =&gt; true,</span><br><span class="line">         // 数据返回类型</span><br><span class="line">         &apos;result_type&apos;     =&gt; PDO::FETCH_ASSOC,</span><br><span class="line">         // 数据集返回类型</span><br><span class="line">         &apos;resultset_type&apos;  =&gt; &apos;array&apos;,</span><br><span class="line">         // 自动写入时间戳字段</span><br><span class="line">         &apos;auto_timestamp&apos;  =&gt; false,</span><br><span class="line">         // 时间字段取出后的默认时间格式</span><br><span class="line">         &apos;datetime_format&apos; =&gt; &apos;Y-m-d H:i:s&apos;,</span><br><span class="line">         // 是否需要进行SQL性能分析</span><br><span class="line">         &apos;sql_explain&apos;     =&gt; false,</span><br><span class="line">         // Builder类</span><br><span class="line">         &apos;builder&apos;         =&gt; &apos;&apos;,</span><br><span class="line">         // Query类</span><br><span class="line">         &apos;query&apos;           =&gt; &apos;\\think\\db\\Query&apos;,</span><br><span class="line">         // 是否需要断线重连</span><br><span class="line">         &apos;break_reconnect&apos; =&gt; false,</span><br><span class="line">     ];</span><br><span class="line"> </span><br><span class="line">     // PDO连接参数</span><br><span class="line">     protected $params = [</span><br><span class="line">         PDO::ATTR_CASE              =&gt; PDO::CASE_NATURAL,</span><br><span class="line">         PDO::ATTR_ERRMODE           =&gt; PDO::ERRMODE_EXCEPTION,</span><br><span class="line">         PDO::ATTR_ORACLE_NULLS      =&gt; PDO::NULL_NATURAL,</span><br><span class="line">         PDO::ATTR_STRINGIFY_FETCHES =&gt; false,</span><br><span class="line">         PDO::ATTR_EMULATE_PREPARES  =&gt; false,</span><br><span class="line">     ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有很多很多代码，上面主要是默认的config和PDO连接参数的初始化。 因为是抽象类所以实例化的是他们的各个子类。</p><h4 id="builder的工厂模式"><a href="#builder的工厂模式" class="headerlink" title="builder的工厂模式"></a>builder的工厂模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public function getBuilder()</span><br><span class="line">   &#123;</span><br><span class="line">       if (!empty($this-&gt;builder)) &#123;</span><br><span class="line">           return $this-&gt;builder;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return $this-&gt;getConfig(&apos;builder&apos;) ?: &apos;\\think\\db\\builder\\&apos; . ucfirst($this-&gt;getConfig(&apos;type&apos;));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里是通过子连接器的属性，用工厂模式引入的相对于的构建器和Db入口类的思想也是一样的。<br><strong>其余的都是各种的数据库基本操作了</strong></p><h3 id="Query类"><a href="#Query类" class="headerlink" title="Query类"></a>Query类</h3><p>Query类封装了各种Sql原生语句实现的方法，算是独立出来的，因为model也可以使用这个。</p><h3 id="Db类总结"><a href="#Db类总结" class="headerlink" title="Db类总结"></a>Db类总结</h3><p>TP5的Db类差不多就是如上，思想主要是通过工厂模式来通过同一入口，创建不同的实例，其中查询时封装了一层Pdo层，<br>即方便了用户使用，也可以增强安全性。总之十分收益。不过我的描述不行，很多想写的不知道怎么写，再接再厉。<br>TP5源码分析系列第一步OK。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个简单版的mvvm</title>
      <link href="/2018/08/06/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%89%88%E7%9A%84mvvm/"/>
      <url>/2018/08/06/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%89%88%E7%9A%84mvvm/</url>
      <content type="html"><![CDATA[<h3 id="优雅的双向绑定"><a href="#优雅的双向绑定" class="headerlink" title="优雅的双向绑定"></a>优雅的双向绑定</h3><p>想当初，只接触过jquery的我，第一次遇见vue，它的双向绑定功能就深深的吸引住了我。<br>所以现在就研究一下这样魔法般的功能是如何实现的。<br><a id="more"></a></p><h3 id="Object-defineproperty"><a href="#Object-defineproperty" class="headerlink" title="Object.defineproperty"></a>Object.defineproperty</h3><p>vue的双向绑定是基于属性拦截器实现的，设计是基于订阅/发布模式开发的。<br>该API是双向绑定的核心，通过重写数据的get，set方法。从而实现双向绑定。</p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ol><li>实现数据监听器Observer,用Object.defineproperty重写数据的set和get，值更新就通知订阅者更新数据。</li><li>模板编译Complie，深度遍历dom树，对每一个元素节点文本节点进行替换数据和订阅数据。</li><li>使用watch连接Observer和Complie，订阅每一个元素的属性变动，执行指令绑定的回调函数从而更新视图。</li><li>mvvm的入口函数，整合以上。</li></ol><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://github.com/yuhongjing/img-folder/raw/master/img/mvvm.jpg" alt=""></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>mvvm模式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"mvvm.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123; test &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"reset"</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Mvvm(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'app'</span>,</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="javascript">            test: <span class="string">''</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        methods: &#123;</span></span><br><span class="line"><span class="undefined">            reset() &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.test = <span class="string">""</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;) </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mvvm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options)  &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; el, data, methods &#125; = options;</span><br><span class="line">        <span class="keyword">this</span>.methods = methods;</span><br><span class="line">        <span class="keyword">this</span>.target = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 初始化dispather</span></span><br><span class="line">        <span class="keyword">this</span>.observe(<span class="keyword">this</span>, data);</span><br><span class="line">        <span class="comment">// 初始化watcher</span></span><br><span class="line">        <span class="keyword">this</span>.compile(<span class="built_in">document</span>.getElementById(el));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    observe(root, data) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="keyword">this</span>.defineReactive(root, key, data[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个数据绑定订阅发布</span></span><br><span class="line">    defineReactive(root, key, value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> value == <span class="string">'object'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.observe(value, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> dep = <span class="keyword">new</span> Dispather();</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(root, key, &#123;</span><br><span class="line">            set(newValue) &#123;</span><br><span class="line">                <span class="keyword">if</span>(value == newValue) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                value = newValue;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                dep.notify(newValue);</span><br><span class="line">            &#125;,</span><br><span class="line">            get() &#123;</span><br><span class="line">                <span class="comment">// 订阅</span></span><br><span class="line">                dep.add(<span class="keyword">this</span>.target);</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译</span></span><br><span class="line">    compile(dom) &#123;</span><br><span class="line">        <span class="keyword">const</span> nodes = dom.childNodes;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> node <span class="keyword">of</span> nodes) &#123;</span><br><span class="line">            <span class="comment">// 元素节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.nodeType == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> attrs = node.attributes;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">const</span> attr <span class="keyword">of</span> attrs) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(attr.name == <span class="string">'v-model'</span>) &#123;</span><br><span class="line">                        <span class="keyword">const</span> name = attr.value;</span><br><span class="line">                        node.addEventListener(<span class="string">'input'</span>, e =&gt; &#123;</span><br><span class="line">                            <span class="keyword">this</span>[name] = e.target.value</span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="keyword">this</span>.target = <span class="keyword">new</span> Watcher(node, <span class="string">'input'</span>);</span><br><span class="line">                        <span class="keyword">this</span>[name];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(attr.name == <span class="string">'@click'</span>) &#123;</span><br><span class="line">                        <span class="keyword">const</span> name = attr.value;</span><br><span class="line">                        node.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.methods[name].bind(<span class="keyword">this</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// text节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.nodeType == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>;</span><br><span class="line">                <span class="keyword">const</span> match = node.nodeValue.match(reg);</span><br><span class="line">                <span class="keyword">if</span>(match) &#123;</span><br><span class="line">                    <span class="keyword">const</span> name = match[<span class="number">1</span>].trim();</span><br><span class="line">                    <span class="keyword">this</span>.target = <span class="keyword">new</span> Watcher(node, <span class="string">'text'</span>);</span><br><span class="line">                    <span class="keyword">this</span>[name];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispather</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.watchers = [];</span><br><span class="line">    &#125;</span><br><span class="line">    add(watcher) &#123;</span><br><span class="line">        <span class="keyword">this</span>.watchers.push(watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    notify(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.watchers.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> watcher.update(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(node, type) &#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    update(value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.type == <span class="string">'input'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.node.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.type == <span class="string">'text'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.node.nodeValue = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css绝对定位居中</title>
      <link href="/2018/08/06/css%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%B1%85%E4%B8%AD/"/>
      <url>/2018/08/06/css%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%B1%85%E4%B8%AD/</url>
      <content type="html"><![CDATA[<h3 id="绝对定位的元素如何居中"><a href="#绝对定位的元素如何居中" class="headerlink" title="绝对定位的元素如何居中"></a>绝对定位的元素如何居中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br><span class="line">top: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">margin: auto;</span><br></pre></td></tr></table></figure><p>即可居中。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git clone</title>
      <link href="/2018/07/19/Git-clone/"/>
      <url>/2018/07/19/Git-clone/</url>
      <content type="html"><![CDATA[<h3 id="git-clone-下载太慢的解决方式"><a href="#git-clone-下载太慢的解决方式" class="headerlink" title="git clone 下载太慢的解决方式"></a>git clone 下载太慢的解决方式</h3><p>设置代理的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:34828</span><br><span class="line">git config --global https.proxy https://127.0.0.1:34828</span><br></pre></td></tr></table></figure></p><p>这个不需要设置sock5<br><a id="more"></a><br>取消代理的命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure></p><p>也可以直接编辑git的设置文件，位置在用户目录下的<code>.gitconfig</code>,可能是隐藏文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编辑如下</span><br><span class="line">[https]</span><br><span class="line">    proxy = https://127.0.0.1:34828</span><br><span class="line">[http]</span><br><span class="line">    proxy = http://127.0.0.1:34828</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitbash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构与算法学习之路</title>
      <link href="/2018/06/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
      <url>/2018/06/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
      <content type="html"><![CDATA[<h3 id="内功心法"><a href="#内功心法" class="headerlink" title="内功心法"></a>内功心法</h3><p>都说数据结构与算法是程序员的内功心法，也是一种很枯燥很难的东西。<br>曾经在参加ACM备战的时候补了一阵的数据结构和算法，但是现在也快忘得差不多了。<br>现在准备系统的学习，提升一下自己，并记录一下我的学习过程和心得吧。<br><a id="more"></a></p><h3 id="学习路线图"><a href="#学习路线图" class="headerlink" title="学习路线图"></a>学习路线图</h3><p><img src="https://github.com/yuhongjing/img-folder/raw/master/img/sjjg.png" alt="">  </p><h3 id="相关-书籍"><a href="#相关-书籍" class="headerlink" title="相关 书籍"></a>相关 书籍</h3><ol><li>《数据结构与算法分析：C语言描述》</li><li>《剑指offer》</li></ol>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RESTful</title>
      <link href="/2018/06/13/RESTful/"/>
      <url>/2018/06/13/RESTful/</url>
      <content type="html"><![CDATA[<h3 id="前后端完全分离的现状"><a href="#前后端完全分离的现状" class="headerlink" title="前后端完全分离的现状"></a>前后端完全分离的现状</h3><p>目前这个阶段，大多数的项目的前后端都是完全分离的，他们的沟通都通过API来实现。<br>所以API的设计是否科学，是否易于前后端沟通，成了一个很重要的话题。<br>于是乎RESTful这种API接口的设计风格，逐渐被广大接受了起来。<br><a id="more"></a></p><h3 id="为什么会产生RESTful这种设计风格"><a href="#为什么会产生RESTful这种设计风格" class="headerlink" title="为什么会产生RESTful这种设计风格"></a>为什么会产生RESTful这种设计风格</h3><p>在以前，设计API没有那么多的规范，风格。大家写的API都很随意，这样导致了前端请求后端的数据的时候，不知道该从何处请求。<br>而且请求回来的数据的类型也都不一致，甚至于请求错误后，都不知道错误的原因是什么？<br>这样会导致开发的效率大打折扣。于是乎一种规范的，有层次设计风格在经验中被总结了出来。<br>这就是RESTful。</p><h3 id="RESTful的特点"><a href="#RESTful的特点" class="headerlink" title="RESTful的特点"></a>RESTful的特点</h3><p>REST的原则主要有以下几个：  </p><ol><li>资源与URL</li><li>统一资源接口</li><li>资源的表述</li><li>资源的链接</li><li>状态的转移  <h4 id="资源与URL"><a href="#资源与URL" class="headerlink" title="资源与URL"></a>资源与URL</h4>前端从后端获取资源是通过url的方式获取，所以后端的url设计是否易懂就很有必要。<br>例如，获取某个音乐的信息的路由就可以设置为:<br><code>https://yuhongjing.com/music/32</code><br>这样的设计很明显是获取音乐栏目的id为32号的信息，方便前端获取。<br>当然这只是一个小例子，真正的url设计还需要考虑分层，分级，分类型，分权限等一系列规范。  <h4 id="统一资源接口"><a href="#统一资源接口" class="headerlink" title="统一资源接口"></a>统一资源接口</h4>RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。<br>接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。<br>例如GET表示获取资源，POST表示修改资源，PUT表示插入资源，DELETE表示删除资源等。<br>并且还需要返回http请求的code码和错误信息等。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//例如GET请求</span><br><span class="line">GET</span><br><span class="line">* 安全且幂等</span><br><span class="line">* 获取表示</span><br><span class="line">* 变更时获取表示（缓存）</span><br><span class="line">* 200（OK） - 表示已在响应中发出</span><br><span class="line">* 204（无内容） - 资源有空表示</span><br><span class="line">* 301（Moved Permanently） - 资源的URI已被更新</span><br><span class="line">* 303（See Other） - 其他（如，负载均衡）</span><br><span class="line">* 304（not modified）- 资源未更改（缓存）</span><br><span class="line">* 400 （bad request）- 指代坏请求（如，参数错误）</span><br><span class="line">* 404 （not found）- 资源不存在</span><br><span class="line">* 406 （not acceptable）- 服务端不支持所需表示</span><br><span class="line">* 500 （internal server error）- 通用错误响应</span><br><span class="line">* 503 （Service Unavailable）- 服务端当前无法处理请求</span><br></pre></td></tr></table></figure></li></ol><p>当然这只是冰山一角，不同的请求有着不同的设计。  </p><h4 id="资源的表述"><a href="#资源的表述" class="headerlink" title="资源的表述"></a>资源的表述</h4><p>这个就比较简单，也就是返回的资源以什么格式返回。<br>RESTful默认所有的返回资源都以JSON的格式返回。<br>所以就不要以什么字符串啊，数组啊，xml等格式返回了。  </p><h4 id="在URL里边带上版本号"><a href="#在URL里边带上版本号" class="headerlink" title="在URL里边带上版本号"></a>在URL里边带上版本号</h4><p>项目的版本总要更新吧，所以需要在url带上你的版本号。<br>例如<code>http://yuhongjing.cn/blog/v1/api/token</code><br>这里是获取第一版本的token的api，假如需要更改为第二版本。直接更改为:<br><code>http://yuhongjing.cn/blog/v2/api/token</code><br>即可，设计好了就是这么简单方便。  </p><h4 id="资源的链接"><a href="#资源的链接" class="headerlink" title="资源的链接"></a>资源的链接</h4><p>我们知道REST是使用标准的HTTP方法来操作资源的，但仅仅因此就理解成带CURD的Web数据库架构就太过于简单了。<br>这种反模式忽略了一个核心概念：”超媒体即应用状态引擎（hypermedia as the engine of application state）”。 超媒体是什么?<br>当你浏览Web网页时，从一个连接跳到一个页面，再从另一个连接跳到另外一个页面，就是利用了超媒体的概念：把一个个把资源链接起来.  </p><h4 id="状态的转移"><a href="#状态的转移" class="headerlink" title="状态的转移"></a>状态的转移</h4><p>一句话吧，客户端不应该存有服务器资源的状态，服务器不应该存有客户端应用的状态。<br>各司其职，客户端只管理<code>应用</code>状态，服务器管理<code>资源</code>状态。  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在的项目都是前后端分离，所以RESTful风格的API设计，变得尤为重要。不过，这个得从项目中慢慢去体会。  </p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RESTful </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CORS</title>
      <link href="/2018/06/13/CORS/"/>
      <url>/2018/06/13/CORS/</url>
      <content type="html"><![CDATA[<h3 id="你不得不解决的跨域问题"><a href="#你不得不解决的跨域问题" class="headerlink" title="你不得不解决的跨域问题"></a>你不得不解决的跨域问题</h3><p>跨域是前后端传输数据不能逃避的问题，详情百度跨域，跨源，不过你肯定遇见过。<br>前面写过一篇文章，jsonp就是解决跨域的一种方式，但是这样的方式并不理想。<br>所以W3C出了一个CORS<code>(Cross-Origin Resource Sharing,跨源资源共享)</code>的标准。<br>其思想是自定义HTTP头部让浏览器与服务器沟通。<br>所以要使用这种方式的前提是：我们能够设置服务器。<br><a id="more"></a></p><h3 id="我的配置以及代码"><a href="#我的配置以及代码" class="headerlink" title="我的配置以及代码"></a>我的配置以及代码</h3><p>本人是使用apache的集成环境，搭建的本地虚拟服务器。<br>代码以Thinkphp为例,代码如下。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//行为文件</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">app</span>\<span class="title">api</span>\<span class="title">behavior</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CORS</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">appInit</span><span class="params">(&amp;$params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        header(<span class="string">'Access-Control-Allow-Origin: *'</span>);</span><br><span class="line">        header(<span class="string">"Access-Control-Allow-Headers: token,Origin, X-Requested-With, Content-Type, Accept"</span>);</span><br><span class="line">        header(<span class="string">'Access-Control-Allow-Methods: POST,GET'</span>);</span><br><span class="line">        <span class="keyword">if</span>(request()-&gt;isOptions())&#123;</span><br><span class="line">            <span class="keyword">exit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tag文件</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * app_init CORS跨域</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 应用行为扩展定义文件</span></span><br><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="comment">// 应用初始化</span></span><br><span class="line">    <span class="string">'app_init'</span>     =&gt; [</span><br><span class="line">        <span class="string">'app\\api\\behavior\\CORS'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 应用开始</span></span><br><span class="line">    <span class="string">'app_begin'</span>    =&gt; [],</span><br><span class="line">    <span class="comment">// 模块初始化</span></span><br><span class="line">    <span class="string">'module_init'</span>  =&gt; [],</span><br><span class="line">    <span class="comment">// 操作开始执行</span></span><br><span class="line">    <span class="string">'action_begin'</span> =&gt; [],</span><br><span class="line">    <span class="comment">// 视图内容过滤</span></span><br><span class="line">    <span class="string">'view_filter'</span>  =&gt; [],</span><br><span class="line">    <span class="comment">// 日志写入</span></span><br><span class="line">    <span class="string">'log_write'</span>    =&gt; [],</span><br><span class="line">    <span class="comment">// 应用结束</span></span><br><span class="line">    <span class="string">'app_end'</span>      =&gt; [],</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>从而对每一次的HTTP请求进行处理，完成CORS跨域的功能。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>CORS只是一种标准，代码的写法有成千上万种，但是核心即header，也就是http的响应头。<br>如果不知道，百度一下http的相关知识，学习WEB不知道这些最基础的知识可不行。  </p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CORS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHPCMS</title>
      <link href="/2018/06/12/PHPCMS/"/>
      <url>/2018/06/12/PHPCMS/</url>
      <content type="html"><![CDATA[<h3 id="PHPCMS与Thinkphp框架有何不同"><a href="#PHPCMS与Thinkphp框架有何不同" class="headerlink" title="PHPCMS与Thinkphp框架有何不同"></a>PHPCMS与Thinkphp框架有何不同</h3><p>之前也接触过，类似织梦CMS，帝国CMS。但是从来没有系统的了解过，这种几年前火遍大江南北的CMS和现在的框架有何不同。<br>好吧，现在简单的说一下。CMS是一个已经制作完毕的程序，所有的功能已经齐全可以直接使用，当然我们也可以替换模板二次开发。<br>而现在的框架，只是把一些功能，库封装好了，我们还需要直接编写功能，逻辑等。<br>所以说，CMS是已经完成了80%的程序，而Thinkphp只是搭了一个架构。<br><a id="more"></a></p><h3 id="几乎不需要编写代码的CMS"><a href="#几乎不需要编写代码的CMS" class="headerlink" title="几乎不需要编写代码的CMS"></a>几乎不需要编写代码的CMS</h3><p>CMS可以直接安装好，然后替换模板即可使用。几乎无需直接编写代码。  </p><h3 id="层次分类"><a href="#层次分类" class="headerlink" title="层次分类"></a>层次分类</h3><p>phpcms并非标准的MVC架构。其工作层次如下。<br>model连接数据库，配置数据库，但是不能书写业务逻辑，仅仅是一个连接配置。<br>modules就是控制器，处理调用数据。<br>templates就是视图，负责渲染前端。<br>MVC最主要的就是model，而phpcms中的model却不能处理业务，这也就是phpcms为什么不是标准的mvc的原因。<br>phpcms是完全通过源码书写的，没有什么框架，所以内核相对繁杂。</p><h3 id="目录架构"><a href="#目录架构" class="headerlink" title="目录架构"></a>目录架构</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">|-----api  接口文件目录  </span><br><span class="line">|-----caches 缓存文件目录  </span><br><span class="line">    |-----configs 系统配置文件目录  </span><br><span class="line">        |-----database.php  数据库配置文件  </span><br><span class="line">        |-----route.php     路由配置文件  </span><br><span class="line">        |-----system.php    系统配置文件  </span><br><span class="line">        |-----cache.php     缓存配置文件  </span><br><span class="line">    |-----configs_*         系统缓存文件目录  </span><br><span class="line">        |-----configs_commons/caches_data   主要用来存放后台设置的配置信息  </span><br><span class="line">            |-----category_content.cache.php栏目与站点映射所对应的配置文件  </span><br><span class="line">            |-----category_content_1.cache.php站点<span class="number">1</span>下所有栏目的详细配置信息  </span><br><span class="line">            |-----category_item_1.cache.php 文章模型下各栏目所对应的数据量  </span><br><span class="line">            |-----category_item_2.cache.php 下载模型下各栏目所对应的数据量  </span><br><span class="line">            |-----category_item_3.cache.php 图片模型下各栏目所对应的数据量  </span><br><span class="line">            |-----keylink.cache.php     关联链接配置缓存文件  </span><br><span class="line">            |-----model.cache.php       三大模型配置缓存文件  </span><br><span class="line">            |-----mood_program.cache.php    表情配置缓存文件  </span><br><span class="line">            |-----position.cache.php    推荐位配置缓存文件  </span><br><span class="line">            |-----poster_template_1.cache.php广告位模板配置缓存文件  </span><br><span class="line">            |-----sitelist.cache.php    站点列表配置文件，主要缓存所有站点的基本配置信息  </span><br><span class="line">            |-----type_content.cache.php    多个站点下的类别配置信息  </span><br><span class="line">            |-----type_content_1.cache.php  当前站点下类别配置信息缓存文件  </span><br><span class="line">            |-----urlrules.cache.php    url规则配置信息缓存文件  </span><br><span class="line">            |-----urlrules_detail.cache.php url规则详细配置信息缓存文件  </span><br><span class="line">            |-----special.cache.php     专题配置信息缓存文件  </span><br><span class="line">            |-----role.cache.php        角色配置缓存文件  </span><br><span class="line">            |-----link.cache.php        友情链接缓存文件  </span><br><span class="line">        |-----configs_model/caches_data  </span><br><span class="line">            |-----content_form.class.php    生成表单的类库缓存文件  </span><br><span class="line">            |-----content_input.class.php   入库时，对表单数据进行验证的类库缓存文件  </span><br><span class="line">            |-----content_output.class.php  对从数据表中查询出来的数据进行处理的函数  </span><br><span class="line">            |-----content_update.class.php  对要更新的数据进行有效性验证的函数  </span><br><span class="line">            |-----model_field_1.cache.php   文章模型所有模型字段的缓存信息  </span><br><span class="line">            |-----model_field_2.cache.php   下载模型所有模型字段的缓存信息  </span><br><span class="line">            |-----model_field_3.cache.php   图片模型所有模型字段的缓存信息  </span><br><span class="line"></span><br><span class="line">|-----phpcms                        phpcms框架主目录  </span><br><span class="line">       |-----languages                  框架语言包目录  </span><br><span class="line">       |-----libs                   框架主类库、主函数库目录  </span><br><span class="line">       |-----classes  </span><br><span class="line">            |-----form.class.php    表单生成类库文件  </span><br><span class="line">            |-----application.class.php 应用程序类库文件  </span><br><span class="line">            |-----image.class.php       图片处理类库文件  </span><br><span class="line">            |-----attachment.class.php  附件处理类库文件  </span><br><span class="line">            |-----param.class.php       URL参数处理类库文件  </span><br><span class="line">       |-----functions  </span><br><span class="line">            |-----<span class="keyword">global</span>.func.php       公共函数库文件  </span><br><span class="line">            |-----extension.class.php   扩展函数库文件  </span><br><span class="line">       |-----model                  框架数据库模型目录  </span><br><span class="line">       |-----content_model.class.php       内容模型文件  </span><br><span class="line">       |-----admin_model.class.php     管理员模型文件  </span><br><span class="line">       |-----attachment_model.class.php    附件模型文件  </span><br><span class="line">       |-----modules                    框架模块目录  </span><br><span class="line">       |-----admin             admin模块   </span><br><span class="line">            |-----index.php         index.php控制器文件  </span><br><span class="line">       |-----content               content模块  </span><br><span class="line">            |-----classes           content模块通用类库  </span><br><span class="line">            |-----fields            content模块模型字段  </span><br><span class="line">            |-----functions         content模块通用函数库  </span><br><span class="line">            |-----templates         content模块后台模板文件  </span><br><span class="line">            |-----index.php         index.php控制器文件  </span><br><span class="line">       |-----templates                  框架系统前台模板目录  </span><br><span class="line">            |-----<span class="keyword">default</span>               默认的模板风格  </span><br><span class="line">                |-----content           content模块模板目录  </span><br><span class="line">                    |-----category.html 频道页模板文件  </span><br><span class="line">                    |-----<span class="keyword">list</span>.html     列表页模板文件  </span><br><span class="line">                    |-----show.html     内容页模板文件  </span><br><span class="line">                |-----config.php        模板配置文件  </span><br><span class="line">|-----phpsso_server                 phpsso主目录  </span><br><span class="line">|-----statics                       网站素材文件目录  </span><br><span class="line">    |-----css                                   css文件  </span><br><span class="line">        |-----images                    images文件  </span><br><span class="line">        |-----js                    js文件  </span><br><span class="line">|-----uploadfile                    上传附件  </span><br><span class="line">|-----admin.php                     后台入口文件  </span><br><span class="line">|-----index.php                     前台入口文件</span><br></pre></td></tr></table></figure><h3 id="模板文件与路由"><a href="#模板文件与路由" class="headerlink" title="模板文件与路由"></a>模板文件与路由</h3><p><a href="http://域名/入口文件?m=模块名&amp;c=控制器&amp;a=方法名&amp;catid=参数值" target="_blank" rel="noopener">http://域名/入口文件?m=模块名&amp;c=控制器&amp;a=方法名&amp;catid=参数值</a><br>频道页：category<em>*.html<br>列表页：list</em><em>.html<br>内容页：show_</em>.html  </p><h3 id="系统类库、函数库、模型文件及配置文件的加载"><a href="#系统类库、函数库、模型文件及配置文件的加载" class="headerlink" title="系统类库、函数库、模型文件及配置文件的加载"></a>系统类库、函数库、模型文件及配置文件的加载</h3><p>pc_base::load_sys_class();//加载系统类库<br>pc_base::load_sys_func();//加载系统函数库<br>pc_base::load_model();//加载模型<br>pc_base::load_config();//加载配置文件或配置选项信息<br>pc_base::load_app_func();//加载应用程序函数库<br>pc_base::load_app_class();//加载应用程序类库  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>因为CMS已经开发完毕，所以你需要添加自定义功能就特别的麻烦。而Thinkphp这样的框架自由度就更高了，这也就是为什么现在的CMS不那么火了的原因。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHPCMS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Win10激活</title>
      <link href="/2018/05/31/Win10%E6%BF%80%E6%B4%BB/"/>
      <url>/2018/05/31/Win10%E6%BF%80%E6%B4%BB/</url>
      <content type="html"><![CDATA[<h3 id="Windows10家庭版和专业版的激活方法"><a href="#Windows10家庭版和专业版的激活方法" class="headerlink" title="Windows10家庭版和专业版的激活方法"></a>Windows10家庭版和专业版的激活方法</h3><p>几句命令即可，谁用谁知道<br><a id="more"></a></p><h3 id="ID码"><a href="#ID码" class="headerlink" title="ID码"></a>ID码</h3><p>先进入系统设置，输入对应的ID码<br>win10家庭版ID:00342-34947-91204-AAOEM<br>win10专业版ID:W269N-WFGWX-YVC9B-4J6C9-T83GX    </p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>输入以下命令:<code>slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</code><br>弹出窗口提示：“成功的安装了产品密钥”。  </li><li>继续输入以下命令：<code>slmgr /skms zh.us.to</code><br>弹出窗口提示：“密钥管理服务计算机名成功的设置为zh.us.to”。  </li><li>接下来输入以下命令：<code>slmgr /ato</code><br>时将弹出窗口提示：“成功的激活了产品”。  </li></ol><p>激活完毕!</p>]]></content>
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu命令整理</title>
      <link href="/2018/05/31/Ubuntu%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
      <url>/2018/05/31/Ubuntu%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>刚接触了Ubuntu系统，对于目前使用到的一些基础命令做了个大概的整理。<br><a id="more"></a></p><h3 id="文件-文件夹管理"><a href="#文件-文件夹管理" class="headerlink" title="文件/文件夹管理"></a>文件/文件夹管理</h3><h4 id="查看-寻找"><a href="#查看-寻找" class="headerlink" title="查看/寻找"></a>查看/寻找</h4><p>ls [-a| -l]    列出当前目录文件(不包含隐藏文件)[包含隐藏文件|包含详细信息]<br>find 路径 -name “字符串”     查找路径下满足字符串匹配的字符串</p><h4 id="创建-删除"><a href="#创建-删除" class="headerlink" title="创建/删除"></a>创建/删除</h4><p>mkdri 目录名     创建一个目录<br>rmdir 目录名    删除一个目录<br>rm 文件名 [文件名]     删除一个文件或读个文件<br>rm -rf 非空目录名    删除一个非空目录下的一切</p><h4 id="移动-改名"><a href="#移动-改名" class="headerlink" title="移动/改名"></a>移动/改名</h4><p>mv 路径/文件 绝对路径    移动文件<br>mv 文件名 新文件名      目录改名</p><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><p>uname -a     查看内核版本<br>cat /etc/issue    查看ubuntu版本<br>sudo ethtool eth0    查看网卡状态<br>cat /proc/cpuinfo    查看cpu信息<br>reboot        重启计算机</p><h3 id="打包-解压"><a href="#打包-解压" class="headerlink" title="打包/解压"></a>打包/解压</h3><p>tar [-c| -x| -v| -z]             创建包|释放包|显示命令过程|压缩包<br>tar –cvf benet.tar /home/benet         把/home/benet目录打包<br>tar –zcvf benet.tar.gz /mnt         把目录打包并压缩<br>tar –zxvf benet.tar.gz             压缩包的文件解压恢复<br>tar –jxvf benet.tar.bz2         解压缩 </p><h3 id="make编译"><a href="#make编译" class="headerlink" title="make编译"></a>make编译</h3><p>make             编译<br>make install         安装编译好的源码包 </p><h3 id="apt命令"><a href="#apt命令" class="headerlink" title="apt命令"></a>apt命令</h3><p>apt-cache search package         搜索包<br>apt-cache show package             获取包的相关信息，如说明、大小、版本等<br>sudo apt-get install package         安装包<br>sudo apt-get install package - - reinstall     重新安装包<br>sudo apt-get -f install         修复安装”-f = –fix-missing”<br>sudo apt-get remove package             删除包<br>sudo apt-get remove package - - purge         删除包，包括删除配置文件等<br>sudo apt-get update         更新源<br>sudo apt-get upgrade         更新已安装的包<br>sudo apt-get dist-upgrade         升级系统<br>sudo apt-get dselect-upgrade         使用 dselect 升级<br>apt-cache depends package         了解使用依赖<br>apt-cache rdepends package         是查看该包被哪些包依赖<br>sudo apt-get build-dep package         安装相关的编译环境<br>apt-get source package             下载该包的源代码<br>sudo apt-get clean &amp;&amp; sudo apt-get autoclean         清理无用的包<br>sudo apt-get check     检查是否有损坏的依赖<br>sudo apt-get clean     清理所有软件缓存（即缓存在/var/cache/apt/archives目录里的deb包）</p><h3 id="关键词-快捷键"><a href="#关键词-快捷键" class="headerlink" title="关键词/快捷键"></a>关键词/快捷键</h3><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>Ctrl+Alt+T    打开终端<br>Tab    自动补全<br>Win+A    打开软件大全<br>Alt+Tab    切换活动窗口</p><h4 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h4><p>dpkg    安装或删除.deb的软件包<br>apt-get    安装,卸载,更新软件<br>ls    查看目录<br>sudo    超级用户模式<br>vi    进入vi模式<br>cat    查看文件内容</p><h3 id="一些操作方法"><a href="#一些操作方法" class="headerlink" title="一些操作方法"></a>一些操作方法</h3><h4 id="vi模式下"><a href="#vi模式下" class="headerlink" title="vi模式下"></a>vi模式下</h4><p>按I键，进入编辑模式。按ESC键退出编辑模式，输入wq！保存并退出。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>刚玩Ubuntu不久，听说这是最适合Linux新手的系统,使用起来的感觉也的确特别好。不过命令也太多了，而且似乎很多MSOS的软件都无法使用，什么百度云盘、腾讯系的软件都不可以使用，连小程序开发工具都无法使用，还必须借助Wine来运行，唉～不得不说目前我还是离不开MSOS。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决Linux重启后DNS被重写</title>
      <link href="/2018/05/30/%E8%A7%A3%E5%86%B3Linux%E9%87%8D%E5%90%AF%E5%90%8EDNS%E8%A2%AB%E9%87%8D%E5%86%99/"/>
      <url>/2018/05/30/%E8%A7%A3%E5%86%B3Linux%E9%87%8D%E5%90%AF%E5%90%8EDNS%E8%A2%AB%E9%87%8D%E5%86%99/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本人的系统是’Ubuntu18.04 LTS’，而网上的教程一般是16.X之前的版本，所以说按照网上的办法修改什么base,tail,head，都是不可以的。<br>右键进入终端输入命令’cat /etc/resolv.conf’可以查看到当前的DNS配置文件，默认是没有什么谷歌，电信等DNS的，需要我们自己配置。而配置后重启计算机，刚才配置的又不见了。这是一个在linux系统下比较常见的问题。下面就是我的解决方法。<br><a id="more"></a></p><h3 id="修改文件为只读"><a href="#修改文件为只读" class="headerlink" title="修改文件为只读"></a>修改文件为只读</h3><p>网上的很多方法，我都已经试过了，都不能有效的解决我的问题。但是，其实问题很简单，将文件设置为只读即可。<br>首先，先手动添加DNS，命令如下’sudo gedit /etc/resolv.conf’即可编辑。<br>然后，将文件更改为只读，命令如下’sudo chattr +i /etc/resolv.conf’即可。<br>现在，就算重启也不会出现DNS被重置的情况了。  </p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>‘sudo chattr +i /etc/resolv.conf’当吧’+i’改为’-i’时，即为可以通过超级用户更改。  </p>]]></content>
      
      <categories>
          
          <category> 填坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单电脑管理多github账户</title>
      <link href="/2018/05/26/%E5%8D%95%E7%94%B5%E8%84%91%E7%AE%A1%E7%90%86%E5%A4%9Agithub%E8%B4%A6%E6%88%B7/"/>
      <url>/2018/05/26/%E5%8D%95%E7%94%B5%E8%84%91%E7%AE%A1%E7%90%86%E5%A4%9Agithub%E8%B4%A6%E6%88%B7/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有些时候，可能需要一台电脑连接两个github的账号，或者一台电脑同时需要连接两个平台，例如码云，github等。所以这个时候我们需要在一台电脑上配置多个SSH-Key。<br><a id="more"></a></p><h3 id="建立多个SSH"><a href="#建立多个SSH" class="headerlink" title="建立多个SSH"></a>建立多个SSH</h3><p>首先需要生成多个SSH-key,例如下面就生成了两个SSH-key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;one@gmail.com&quot;</span><br><span class="line"></span><br><span class="line">$ ssh-keygen -t rsa -C &quot;two@gmail.com&quot;</span><br></pre></td></tr></table></figure></p><p>ps: 不要一直按enter，需要新的命名，否则会覆盖。(默认文件名为id_rsa)  </p><h3 id="添加私钥"><a href="#添加私钥" class="headerlink" title="添加私钥"></a>添加私钥</h3><h4 id="打开ssh-agent"><a href="#打开ssh-agent" class="headerlink" title="打开ssh-agent"></a>打开ssh-agent</h4><p>如果你是github官方的bash：<br><code>$ ssh-agent -s</code><br>如果你是其它，比如msysgit：<br><code>$ eval $(ssh-agent -s)</code></p><h4 id="添加私钥-1"><a href="#添加私钥-1" class="headerlink" title="添加私钥"></a>添加私钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/id_rsa_one</span><br><span class="line"></span><br><span class="line">$ ssh-add ~/.ssh/id_rsa_two</span><br></pre></td></tr></table></figure><h3 id="创建config配置"><a href="#创建config配置" class="headerlink" title="创建config配置"></a>创建config配置</h3><p>在建立的config文件下添加如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line">Host pxy.github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_pxy</span><br></pre></td></tr></table></figure></p><h3 id="部署SSH-key"><a href="#部署SSH-key" class="headerlink" title="部署SSH key"></a>部署SSH key</h3><p>在网站的SSH上面把文件名为*.pub的内容复制进入即可。</p><h3 id="远程调试测试"><a href="#远程调试测试" class="headerlink" title="远程调试测试"></a>远程调试测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh –T one.github.com</span><br><span class="line"></span><br><span class="line">$ ssh –T two.github.com</span><br></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="注销全局用户配置"><a href="#注销全局用户配置" class="headerlink" title="注销全局用户配置"></a>注销全局用户配置</h4><p>首先注册全局用户的配置，然后进入文件单独配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --unset --global user.name</span><br><span class="line">git config --unset --global user.eamil</span><br></pre></td></tr></table></figure></p><h4 id="使用的区别"><a href="#使用的区别" class="headerlink" title="使用的区别"></a>使用的区别</h4><p>原本的使用方式<br><code>$ git clone git@github.com: one的用户名/learngit.git</code><br>现在的使用方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com: one的用户名/learngit.git</span><br><span class="line"></span><br><span class="line">$ git clone git@pxy.github.com: two的用户名/learngit.git</span><br></pre></td></tr></table></figure></p><p>ps.@后面的地址为我们config配置的Host字段值。从而区分是哪一个用户的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好吧，还是有点坑的了。不过玩过一次后，理清楚顺序后，还是比较清晰的。</p>]]></content>
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Get,Post,Put,Delete</title>
      <link href="/2018/05/21/Get-Post-Put-Delete/"/>
      <url>/2018/05/21/Get-Post-Put-Delete/</url>
      <content type="html"><![CDATA[<h3 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h3><p>从客户端到服务器端的请求消息，被称为Http请求。<br>它包括：消息首行中，对资源的请求方法、资源的标识符及使用的协议。<br>一般我们都是用GET的方式和POST的方式去请求。<br>然而，没想到除了GET和POST之外还有许多种请求方式，而且意义各不相同。。。。。<br><a id="more"></a></p><h3 id="GET方式"><a href="#GET方式" class="headerlink" title="GET方式"></a>GET方式</h3><p>GET并不安全，一般是向服务器索取信息。所以一般使用GET来执行一些查询的操作，也就是select的操作，例如查询用户资料。  </p><h3 id="POST方式"><a href="#POST方式" class="headerlink" title="POST方式"></a>POST方式</h3><p>POST相对安全,一般是向服务器发送信息。所以可以用来执行update的操作，例如修改密码什么的。  </p><h3 id="PUT方式"><a href="#PUT方式" class="headerlink" title="PUT方式"></a>PUT方式</h3><p>PUT同POST,一般向服务器发送信息。一般用来执行insert的操作，例如增加用户，增加种类。　</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>DELETE，就是用来删除数据的。一般用来执行delete的操作，例如删除用户，删除内容等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Get为查询，Post为修改,Put为增加,Delete为删除。　　<br>其实还有许多其他的Http请求方式。我却还不知道，一直乱用，接触了RESTFul才了解到这些。　　<br>所以不学习新的东西，就永远不知道自己错在了哪里。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向切面编程</title>
      <link href="/2018/05/20/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/05/20/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h3><p>spring-AOP:这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。<br>AOP不一定都像<code>Spring AOP</code>那样，是在运行时生成代理对象来织入的，还可以在编译期、类加载期织入，比如AspectJ。<br><a id="more"></a></p><h3 id="简要概论-为什么需要"><a href="#简要概论-为什么需要" class="headerlink" title="简要概论-为什么需要"></a>简要概论-为什么需要</h3><p>现在的编程基本上都是基于面向对象编程–继承，封装，多态。这些能够使代码的复用性大大的提高。然后复用性的提高却会使代码有很多重复的模块。<br>所以我们需要将重复的模块单独提出，统一处理，这就是AOP的工作。下面举个例子。</p><h3 id="小栗子"><a href="#小栗子" class="headerlink" title="小栗子"></a>小栗子</h3><p>我们接下来执行两个操作，第一个功能查询用户的金额。<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/AOP/AOP1.png" alt=""><br>第二个功能修改用户的资料。<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/AOP/AOP2.png" alt=""><br>他们都需要进行登录账户的操作，如果每一个地方都有判断登录用户的代码，那就是明显的重复。<br>所以我们可以将登录账户的模块，单独提出来，然后再插入到需要的地方。这样对于代码的维护，性能都有提升。<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/AOP/AOP3.png" alt="">  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>AOP只是一种编程的思想或者说设计的模式，可以将我们的代码梳理的清楚，维护更轻松。<br>所以AOP的善用，可以大大的提高我们的代码质量。</p>]]></content>
      
      <categories>
          
          <category> 研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Laravel配置</title>
      <link href="/2018/05/17/Laravel%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/05/17/Laravel%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><img src="https://github.com/yuhongjing/img-folder/raw/master/img/Laravel/top.png" alt=""><br>作为只接触过Thinkphp框架的我，每次看见Github上被Laravel刷屏的趋势榜单，终于仍不住来研究一下传说中优雅的Laravel。<br><a id="more"></a></p><h3 id="安装的苦恼"><a href="#安装的苦恼" class="headerlink" title="安装的苦恼"></a>安装的苦恼</h3><p>安装Laravel的第一道门槛就是“墙”！在我上大一的时候，就经常听学姐说安装Laravel花费了很久很久时间。<br>所以安装Laravel前，请先准备“梯子”。这样仅需1分钟就能搞定Laravel的配置。<br>幸运的是，我所在的学校的校园网是可以访问外网的，所以我最终仅花费就了一分钟，搞定了Laravel的配置。 </p><h3 id="安装Composer"><a href="#安装Composer" class="headerlink" title="安装Composer"></a>安装Composer</h3><p>进入Laravel的官网，直接下载Composer的安装包即可，下载后进行安装。<br>以默认地址安装会自动配置PATH变量，否则需手动配置PATH变量。<br>其中有一项需要选择自己电脑上的PHP.exe的支持文件。<br>安装完毕后打开命令行输入<code>Composer</code>出现提示，即说明安装成功！</p><h3 id="通过Laravel安装器安装"><a href="#通过Laravel安装器安装" class="headerlink" title="通过Laravel安装器安装"></a>通过Laravel安装器安装</h3><p>安装Composer后通过以下代码即可全局安装Laravel安装器。<br><code>composer global require &quot;laravel/installer&quot;</code><br>安装成功后，然后进入你想创建项目的地址，输入以下命令即可创建项目。<br><code>laravel new 项目名</code><br>出现如下图片就OK。<br> <img src="https://github.com/yuhongjing/img-folder/raw/master/img/Laravel/start.png" alt="">  </p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>之前一直听说安装Laravel很麻烦，其实只是“墙”的问题。<br>我一直很疑惑一款优雅的框架，怎么会安装这么麻烦，原来只是方法不对罢了。  </p>]]></content>
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHPstorm Xdebug工具安装</title>
      <link href="/2018/05/16/Xdebug%E5%AE%89%E8%A3%85/"/>
      <url>/2018/05/16/Xdebug%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<h3 id="Xdebug介绍"><a href="#Xdebug介绍" class="headerlink" title="Xdebug介绍"></a>Xdebug介绍</h3><p>Xdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况。<br>我们可以使用Xdebug对php代码进行断点调试，能够清楚的看清楚每个地方变量的值，不用再通过<code>echo</code>和<code>var_dump</code>来输出变量了。<br><a id="more"></a>  </p><h3 id="在PHPStorm下安装Xdebug工具"><a href="#在PHPStorm下安装Xdebug工具" class="headerlink" title="在PHPStorm下安装Xdebug工具"></a>在PHPStorm下安装Xdebug工具</h3><pre><code>1. 首先我们需要知道当前客户端的PHP版本，新建一个PHP文件，输入PHPINFO()函数即可。  2. 然后Ctrl + F搜索Xdebug，如果没有即表明的确没有安装Xdebug。  3. 浏览器输入Xdebug就能看见官网，点击Download，进入页面有一个Releases版本选项，点击进入。4. 然后回到php的info页面，点击查看源代码，全部复制进入Xdebug的文本框，即可看到当前PHP适应的Xdebug版本。  5. 根据出现的提示，将文件下载后，复制进目标文件内。  6. 然后在php.ini文件内添加如下信息，其中第一行复制于网站的代码  [xdebug];第一行需要复制网站上的代码zend_extension = D:\xampp\php\ext\php_xdebug-2.6.0-7.2-vc15.dllxdebug.remote_enable=1xdebug.remote_handler=dbgpxdebug.remote_mode=reqxdebug.remote_host=localhostxdebug.remote_port=9000xdebug.idekey=&quot;PHPSTORM&quot;7. 重新打开phpinfo文件，Ctrl+F搜索Xdebug如果存在，即表示安装成功。  8. 打开PHPStrom，点击右上角的下箭头，Edit Configurations进入配置需要调试的文件。  9. 配置里面的server，输入localhost即可。10. 点击爬虫图标即可，进行断点调试默认F8下一步。  </code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>调试工具对于寻找错误的效率有特别大的提示，因为编程从某种意义上来说，就是不断的发现错误。  </p>]]></content>
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue项目总结</title>
      <link href="/2018/05/08/vue%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/08/vue%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>本项目是一个翻新版本，第一版的记账本完全由Thinkphp完成（功能已经完善）。<br><a id="more"></a><br>本项目前端由Vue,Vue-cli,Vue-Router,axios完成,后端由Thinkphp5+Mysql+linux完成。<br>本项目完成了一款基础的记账本功能，主要包括用户的资料修改，记账，查账。<br>未完成的功能，用户注册，账本删除，种类新增等。  </p><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>前端分为了3个模块:用户登录模块,主页模块,功能模块(主要)<br>后端三个控制器对应三个模块:Login,Home,Index完成相应功能  </p><h1 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h1><p>前后端分离请求API跨域：因为我可以处理后台，所以直接从后台添加header即可，否则需要配置ngnix反向解析。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">_initialize</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    header(<span class="string">'Access-Control-Allow-Origin:*'</span>); </span><br><span class="line">    header(<span class="string">'Access-Control-Allow-Methods:GET,POST,PATCH,PUT,OPTIONS'</span>);</span><br><span class="line">    header(<span class="string">'Access-Control-Allow-Headers:x-requested-with, content-type'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Centos文件权限777：因为云服务器的系统为linux，忘了设置文件权限777，导致无法写日志，出现code500的错误，困扰了我很久。唉。<br>Thinkphp模型：一直使用Thinkphp的Db类，现在第一次接触模型来操作数据库，但是此次并没有使用模型的数据自动化和关联模型。<br>Vue-build：用vue-cli打包出来的程序，如果直接build会导致图片的地址出现错误，需要手动改变。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  首先修改config文件下的index.js中的build方法</span><br><span class="line">  assetsPublicPath: <span class="string">'./'</span></span><br><span class="line"></span><br><span class="line">  再修改build文件下的utils.js</span><br><span class="line">  <span class="keyword">if</span> (options.extract) &#123;</span><br><span class="line">    <span class="keyword">return</span> ExtractTextPlugin.extract(&#123;</span><br><span class="line">      use: loaders,</span><br><span class="line">      publicPath:<span class="string">'../../'</span>,</span><br><span class="line">      fallback: <span class="string">'vue-style-loader'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'vue-style-loader'</span>].concat(loaders)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>vue图片位置:如果图片放入assets中，会被编译打包，所以不能通过地址的方式动态引入，如果放在static中，不会被打包，但是必须通过data的方法引入才能显示。<br>vue全局变量的几种方法: vuex，新建一个js然后export出来引入main.js(全局注入)，也可以按需import进入,变量为webpack的global方式，当然还可以更改原型链<code>Vue.prototype.XXX = XXX</code><br>vue引入一些组件或UI：main.js中直接全局引入在Vue.use使用即可，css也是如此。也可以在各个组件中单独引入。例如axios也是如此.<br>vue安装插件:<code>npm install 插件名 -- save</code>不能在方便<br>vueUI的样式打包失效:main.js将引入的uiCSS放在vue之前即可<br>vue返回上一页:this.$router.back(-1)<br>vue图片的引入:import图片地址然后放入data中<br>后台用json方式传送数据到前端:因为json的键名和键值都是字符型，所以需要特别注意键值类型。<br>filter管道:可以格式化一些特定的数据，例如日期格式化  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>多总结，多温习。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js数组常用方法</title>
      <link href="/2018/04/21/js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2018/04/21/js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="js数组的一些常用方法"><a href="#js数组的一些常用方法" class="headerlink" title="js数组的一些常用方法"></a>js数组的一些常用方法</h1><p>本文章记录了一些js数组经常使用的方法和使用说明。<br><a id="more"></a></p><h2 id="数组添加元素和删除元素"><a href="#数组添加元素和删除元素" class="headerlink" title="数组添加元素和删除元素"></a>数组添加元素和删除元素</h2><p>push()方法<br>该方法可把一个元素或一组元素(数组)添加到当前数组的<strong><em>末尾</em></strong>并返回<strong><em>新的数组长度</em></strong>.<br>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.push(newelement1,newelement2,....,newelementX)</span><br></pre></td></tr></table></figure></p><p>unshift()方法<br>该方法可把一个元素或更多元素添加到<strong><em>数组的开头</em></strong>并返回<strong><em>新的数组长度</em></strong>.<br>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.unshift(newelement1,newelement2,....,newelementX)</span><br></pre></td></tr></table></figure></p><p>pop()方法<br>该方法可以删除并<strong><em>返回</em></strong>数组最后一个元素.<br>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.pop()</span><br></pre></td></tr></table></figure></p><p>shift()方法<br>该方法可以删除数组第一个元素，并<strong><em>返回</em></strong>第一个元素.<br>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.shift()</span><br></pre></td></tr></table></figure></p><p>splice()方法<br><strong><em>万金油方法</em></strong>,可以从数组添加/删除若干个元素，然后<strong><em>返回删除的元素</em></strong>.<br>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.splice(index,howmany,item1,.....,itemX)</span><br></pre></td></tr></table></figure></p><p>注释:index表示添加/删除的起始位置,howmany表示删除的个数(可以为0),item表示添加的元素.  </p><h2 id="数组的基本操作方法"><a href="#数组的基本操作方法" class="headerlink" title="数组的基本操作方法"></a>数组的基本操作方法</h2><p>reverse()方法<br>该方法用于颠倒数组的顺序，<strong><em>不会产生新的数组</em></strong>.<br>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.reverse()</span><br></pre></td></tr></table></figure></p><p>concat()方法<br>该方法可以连接两个个或多个数组，<strong><em>产生新的数组不会改变现有的数组</em></strong>.<br>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.concat(arrayX,arrayX,......,arrayX)</span><br></pre></td></tr></table></figure></p><p>join()方法<br>该方法把所有的数组元素放进一个字符串，<strong><em>按指定的字符进行分隔</em></strong>。<br>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.join(separator)</span><br></pre></td></tr></table></figure></p><p>sort()方法<br>该方法用于对数组的元素进行排序<strong><em>默认升序</em></strong>.<br>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.sort(sortby)</span><br></pre></td></tr></table></figure></p><p>注释:sortby为可选参数，规定函数的排序规则，必须是函数.<br>slice()方法<br>该方法可从已有的数组中返回选定的元素,返回了一个<strong><em>新的数组</em></strong>.<br>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.slice(start,end)</span><br></pre></td></tr></table></figure></p><h2 id="数组元素的查找"><a href="#数组元素的查找" class="headerlink" title="数组元素的查找"></a>数组元素的查找</h2><p>indexOf()方法<br>该方法可返回某个指定的字符串值在字符串中<strong><em>首次</em></strong>出现的位置。<br>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.indexOf(searchvalue,fromindex)</span><br></pre></td></tr></table></figure></p><p>lastIndexOf()方法<br>该方法返回一个指定的字符串值<strong><em>最后</em></strong>出现的位置，在一个字符串中的指定位置从后向前搜索。<br>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.lastIndexOf(searchvalue,fromindex)</span><br></pre></td></tr></table></figure></p><h2 id="数组的循环操作"><a href="#数组的循环操作" class="headerlink" title="数组的循环操作"></a>数组的循环操作</h2><p>forEach()方法<br>该方法用于调用数组的每个元素，并将元素传递给回调函数,该方法<strong><em>没有返回值</em></strong>。<br>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(function(currentValue, index, arr), thisValue)</span><br></pre></td></tr></table></figure></p><h2 id="数组的属性"><a href="#数组的属性" class="headerlink" title="数组的属性"></a>数组的属性</h2><p>length属性<br>该属性可设置或返回数组中元素的数目。<br>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.length</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学而时习之，可以为师矣。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git常用命令</title>
      <link href="/2018/04/07/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/04/07/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="Git的常用命令"><a href="#Git的常用命令" class="headerlink" title="Git的常用命令"></a>Git的常用命令</h1><p>配置全局用户NAME和E-mail  </p><blockquote><p>$ git config –global user.name “Your Name”<br>$ git config –global user.email “email@example.com”   </p></blockquote><a id="more"></a><p>仓库初始化  </p><blockquote><p>$ git init  </p></blockquote><p>添加文件到仓库 </p><blockquote><p>$ git add 文件名  </p></blockquote><p>提示：可反复添加。一个小数点为所有文件。 </p><p>提交到git仓库  </p><blockquote><p>$ git commit -m “注释”  </p></blockquote><p>查看仓库状态  </p><blockquote><p>$ git status  </p></blockquote><p>比较当前的文件修改  </p><blockquote><p>$ git diff 文件名  </p></blockquote><p>查看提交历史  </p><blockquote><p>$ git log  –pretty=oneline  </p></blockquote><p>回退版本  </p><blockquote><p>$ git reset –hard HEAD^  </p></blockquote><p>删除文件  </p><blockquote><p>$ rm 文件名  </p></blockquote><p>与远程仓库协作  </p><blockquote><p>$ git remote add origin git地址  </p></blockquote><p>删除本地库与远程库的关联  </p><blockquote><p>$ git remote rm origin  </p></blockquote><p>推送到远程仓库  </p><blockquote><p>$ git push origin 分支名  </p></blockquote><p>克隆一个远程库  </p><blockquote><p>$ git clone git地址  </p></blockquote><p>创建一个分支  </p><blockquote><p>$ git branch 分支名  </p></blockquote><p>切换分支  </p><blockquote><p>$ git checkout 分支名  </p></blockquote><p>创建并切换一个分支  </p><blockquote><p>$ git checkout -b 分支名  </p></blockquote><p>查看分支  </p><blockquote><p>$ git branch  </p></blockquote><p>合并分支到当前</p><blockquote><p>$ git merge 分支名  </p></blockquote><p>删除分支  </p><blockquote><p>$ git branch -d 分支名  </p></blockquote>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitbash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>闭包</title>
      <link href="/2018/03/16/%E9%97%AD%E5%8C%85/"/>
      <url>/2018/03/16/%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>研究了很久，一直也没敢写下这篇文章。闭包，一个非常重要的技术概念。也经常使用，但是一直不是特别清楚它的原理，这一次算是好好的整理一下吧。<br><a id="more"></a></p><h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>百度百科的解释为“闭包就是能够读取其他函数内部变量的函数”。字面的意思上理解就是闭包是一个函数，能够调用其他函数的变量？但是百度百科接下来还有一句解释，闭包本质就是函数内部与函数外部连接的桥梁。<br>这一下就有一点晕了。不愧是百度，搜索的答案总是对新手这么的不友好。<br>下面是针对js的闭包解释。<br><strong>JavaScript中的函数运行在它们被定义的作用域中,而不是他们被执行的作用域里</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var foo = function()&#123;</span><br><span class="line">    var name = &quot;exe&quot;;</span><br><span class="line">    return function inner()&#123;</span><br><span class="line">        console.log(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo(); //这里得到的是函数inner的引用,相当于只返回了return后面的那一个函数，而且此时并没有执行函数。</span><br><span class="line">bar(); //这里才开始执行inner函数</span><br></pre></td></tr></table></figure></p><p>上面一段代码，有两个特点。第一，return返回的是一个函数。第二，接受函数的是一个变量foo。这就是闭包的特点。<br>这样做有什么用吗？当然有用，你可以看见，我定义了一个bar，但是这个bar却可以访问foo下面的函数inner。<br>并且，如果我继续定义一个变量bar1，也是赋值foo()，惊人的事情就会发生了,虽然引用同一个函数，但是引用的变量却各不干扰。<br>实际情况举一个例子吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var foo = function()&#123;</span><br><span class="line">    var i = 0;</span><br><span class="line">    return function add()&#123;</span><br><span class="line">        i = i + 1;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo();</span><br><span class="line">bar();// i = 1;</span><br><span class="line">bar();// i = 2;</span><br><span class="line">var bar1 = foo();</span><br><span class="line">bar1(); //i = 1;</span><br><span class="line">bar1(); //i = 2;</span><br></pre></td></tr></table></figure></p><p>以上就可以看见闭包的一些特点。</p><h1 id="什么时候需要使用闭包"><a href="#什么时候需要使用闭包" class="headerlink" title="什么时候需要使用闭包"></a>什么时候需要使用闭包</h1><p>还是以js为例，js有一个特别的地方就是，函数内部是可以直接获取全局变量的值，而函数外部却不可以获取函数内部的值。<br>如果你需要获取函数内部的局部变量，正常情况下是不能做到的。所以需要通过闭包，在函数内部再定义一个函数！<br>这样即可获得函数内部的值。也就是说，当你需要函数内部的局部变量的时候，即可使用闭包。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>闭包的特点两个，可以取函数内局部变量，局部变量始终保持在内存中，不会因为调用被自动清除。<br>缺点也很明显，保存在内存会导致内存消耗大，而且在外部可以调用内部变量后，容易导致其他错误！<br>但是闭包总比定义很多全部变量强吧！哈哈！</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>W3c盒子模型</title>
      <link href="/2018/03/15/W3c%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/03/15/W3c%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="两种盒子模型"><a href="#两种盒子模型" class="headerlink" title="两种盒子模型"></a>两种盒子模型</h1><p>一种是IE的怪异盒子模型，一种是W3C的标准盒子模型。两种盒子模型的计算方式不同。目前IE高版本的浏览器已经放弃了怪异盒子模型。在此之前的前端开发者，深受此兼容困扰！庆幸我现在已经不用处理那么多的兼容。<br><a id="more"></a></p><h1 id="W3C盒子模型"><a href="#W3C盒子模型" class="headerlink" title="W3C盒子模型"></a>W3C盒子模型</h1><p><img src="https://github.com/yuhongjing/img-folder/raw/master/img/W3C_box.jpg" alt=""><br>标准盒子的计算方式为:width=border+padding+margin+content,其中content不包含其他。</p><h1 id="IE盒子模型"><a href="#IE盒子模型" class="headerlink" title="IE盒子模型"></a>IE盒子模型</h1><p><img src="https://github.com/yuhongjing/img-folder/raw/master/img/IE_box.jpg" alt=""><br>IE盒子模型又称为”怪异盒子模型”,计算方式为width=margin+content,其中content包含border+padding+content。</p><h1 id="选择哪种盒子模型？"><a href="#选择哪种盒子模型？" class="headerlink" title="选择哪种盒子模型？"></a>选择哪种盒子模型？</h1><p>目前主流的都是选择标准盒子模型，在页头加入DCOTYPE声明即可！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一些基础的必备知识！努力学习，努力积累，日积跬步，能至千里。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jsonp</title>
      <link href="/2018/03/15/Jsonp/"/>
      <url>/2018/03/15/Jsonp/</url>
      <content type="html"><![CDATA[<h1 id="什么是Jsonp"><a href="#什么是Jsonp" class="headerlink" title="什么是Jsonp"></a>什么是Jsonp</h1><p>JSONP是应用于JSON的一种新方法,常用于服务器与客户端的跨源通信，在WEB服务中非常流行。<br><a id="more"></a></p><h1 id="同源政策"><a href="#同源政策" class="headerlink" title="同源政策"></a>同源政策</h1><p>同源政策的本意是为了保护用户信息的安全，防止恶意的网站窃取数据，所以我们传统的AJAX技术就不能直接获取到协议不同，域名不同，端口不同的网站的数据。</p><h1 id="Jsonp是如何跨域获得数据的"><a href="#Jsonp是如何跨域获得数据的" class="headerlink" title="Jsonp是如何跨域获得数据的"></a>Jsonp是如何跨域获得数据的</h1><p>虽然Ajax不能跨域，但是开发者发现script标签的src属性是可以跨域的，于是网页通过一个script元素向服务器请求JSON数据，而JSON正好被js支持(object)，服务器收到请求后，将数据放在一个指定的回调函数里传回来。</p><h1 id="为什么叫做Jsonp"><a href="#为什么叫做Jsonp" class="headerlink" title="为什么叫做Jsonp?"></a>为什么叫做Jsonp?</h1><p>当通过script元素调用数据时，响应内容必须用javascript函数名和圆括号包裹起来。而不是发送这样一段JSON数据，这就是JSONP中P的意义所在。 </p><h1 id="Jsonp与AJAX的区别"><a href="#Jsonp与AJAX的区别" class="headerlink" title="Jsonp与AJAX的区别?"></a>Jsonp与AJAX的区别?</h1><ol><li>ajax和jsonp本质上是不同的东西。</li><li>ajax的核心是通过XmlHttprequest获取<strong>非本页</strong>内容。</li><li>jsonp的核心是动态添加script标签来调用<strong>服务器</strong>的js脚本。   </li></ol><h1 id="一个小小的例子"><a href="#一个小小的例子" class="headerlink" title="一个小小的例子"></a>一个小小的例子</h1><p>文件:example.js<br>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&apos;我是远程文件&apos;);</span><br></pre></td></tr></table></figure></p><p>本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;跨域服务器/remote.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>这就是直接引入一个js，页面弹出一个框，显示我是远程文件。  </p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Jsonp是WEB人员经常使用的东西，但是对于原理可能不那么清楚！多学习，多积累吧!加油!</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ajax是什么?</title>
      <link href="/2018/03/10/Ajax%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2018/03/10/Ajax%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<p>本篇博文是较为清晰的讲诉了什么是Ajax技术，能做什么？我结合了博客园，CSDN以及知乎的几个回答，整理总结得到的。<br><a id="more"></a></p><h1 id="Ajax是什么？"><a href="#Ajax是什么？" class="headerlink" title="Ajax是什么？"></a>Ajax是什么？</h1><p>Ajax全称Asynchronous_JavaScript_and_XML(异步的JavaScript和XML)。<br>首先Ajax不是一种新的编程语言，而是一种使用现在标准的新方法。Ajax是一种无需重新加载整个网页的情况下，就能更新部分网页的技术。  </p><h1 id="Ajax的工作原理"><a href="#Ajax的工作原理" class="headerlink" title="Ajax的工作原理"></a>Ajax的工作原理</h1><p>Ajax的工作原理是一个页面的指定位置可以加载另一个页面的所有输出内容，这样就实现了一个静态页面也能获取到数据库中返回的数据信息了。<br>所以Ajax实现了一个静态网页在不刷新整个页面的情况下与服务器通信，减少了用户等待时间，同时降低了网络流量，增强了客户体验的友好程度。<br>Ajax的核心技术是XMLHttpRequest,它是JavaScript的一个对象。</p><h1 id="Ajax的优点"><a href="#Ajax的优点" class="headerlink" title="Ajax的优点"></a>Ajax的优点</h1><ol><li>减轻了服务器端的负担。</li><li>在局部刷新的情况下更新，增加了页面的反应速度，用户体验更友好。</li><li>Ajax可使因特网应用程序更小，更快，更友好。</li><li>Ajax被广泛支持，不需要下载插件或者小程序。  </li></ol><h1 id="Ajax的缺点"><a href="#Ajax的缺点" class="headerlink" title="Ajax的缺点"></a>Ajax的缺点</h1><ol><li>不利于SEO推广优化，搜索引擎无法访问Ajax请求到的内容。</li><li>Ajax不支持浏览器back按钮。</li><li>破坏了程序的异常机制。</li><li>不容易调试。</li><li>Ajax暴露了与服务器交互的细节。 </li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之，目前Ajax在WEB中是最常用的技术之一，也是前景非常好的技术之一。总而言之，简单实用。必备之。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js正则表达式</title>
      <link href="/2018/03/09/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/03/09/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>本文主要记录js正则表达式中的难点:惰性匹配，贪婪匹配，分组组合，反向引用符。</p><h1 id="贪婪匹配与非贪婪匹配"><a href="#贪婪匹配与非贪婪匹配" class="headerlink" title="贪婪匹配与非贪婪匹配"></a>贪婪匹配与非贪婪匹配</h1><p>贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，<br>而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。非贪婪模式只被部分NFA引擎所支持。<br><a id="more"></a></p><h2 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h2><p>默认情况下，正则表达式使用最长的匹配原则，即贪婪匹配原则。<br>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">源字符串：aa &lt;div&gt;test1&lt;/div&gt; bb &lt;div&gt;test2&lt;/div&gt;cc</span><br><span class="line">贪婪模式的正则表达式:&lt;div&gt;.*&lt;/div&gt;</span><br><span class="line">匹配结果:&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>这就是贪婪匹配的结果，当第一个div结束后，依旧会向右匹配直到字符串结束。<br>仅从应用角度分析，可以这样认为，贪婪模式，就是在整个表达式匹配成功的前提下，尽可能多的匹配，也就是所谓的“贪婪”，通俗点讲，就是看到想要的，有多少就捡多少，除非再也没有想要的了。</p><h2 id="惰性匹配"><a href="#惰性匹配" class="headerlink" title="惰性匹配"></a>惰性匹配</h2><p>在一些使用NFA引擎的语言中，在匹配优先量词后加上“?”，即变成属于非贪婪模式的量词，也叫做忽略优先量词。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">源字符串：aa &lt;div&gt;test1&lt;/div&gt; bb &lt;div&gt;test2&lt;/div&gt;cc</span><br><span class="line">惰性模式的正则表达式:&lt;div&gt;.*&lt;/div&gt;</span><br><span class="line">匹配结果:&lt;div&gt;test1&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>当表达式匹配成功后，即结束匹配，不再向右尝试。<br>仅从应用角度分析，可以这样认为，非贪婪模式，就是在整个表达式匹配成功的前提下，尽可能少的匹配，也就是所谓的“非贪婪”，通俗点讲，就是找到一个想要的捡起来就行了，至于还有没有没捡的就不管了。<br><strong>当然这一切的前提是”匹配成功”</strong></p><h1 id="分组组合符与反向引用符"><a href="#分组组合符与反向引用符" class="headerlink" title="分组组合符与反向引用符"></a>分组组合符与反向引用符</h1><p>分组组合符是将表达式中某部分内容组合起来的符号，反向引用符则是用于匹配分组组合捕获到的内容的标识符。<br>在正则表达式中，可以用一对（英文）圆括号创建一个分组。比如([a-z]+)(/d+)这就是两个分组。<br>分组的作用表现在两个方面，一个是同一模式后续的组件中，称之为反向引用(back_reference)，二是替换模式中引用，称之为编号组。  </p><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>将第一个模式修改为([a-z]+)(/d+)/1之后现在就能够匹配ABC123ABC,A8A等等类似的字符串。这个修正模式后的/1就叫做方向引用，数字1表示引用模式中的第一个捕获组。<br><strong>再来一个例子:\w\w可以匹配”ac,bd,ef”等等,但是\w/1就只能匹配”aa,cc,dd,ee”等相同的字符，这个反向引用匹配的字符与捕获组是一致的。</strong><br>实际应用比如标签符&lt;(h[1-6])&gt;/w+&lt;//1&gt;这样就可以匹配h1到h6的标签符了。如果不反向引用就可以导致不对称的标签符，而反向引用是一致的。  </p><h2 id="替换模式"><a href="#替换模式" class="headerlink" title="替换模式"></a>替换模式</h2><p>编号组的概念也是建立在匹配模式中的分组之上的。它与反向引用的区别在于，编号组是在替换模式中使用的一个概念。<br>例子：([A-Z]{3})(/d{2})为例，该模式匹配ABC12,CDS56等3个字母2个数字的的字符序列。如果要在字母和数字间插入一个空格或者连字符作为分隔符，就可以在替换模式中使用编号组，比如：<br>$1-$2，其中$1就是([A-Z]{3}),$2就是(/d{2}),连字符就是-。这样就完成了需要的功能。<br>$1就相当于那一整个编号组。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>有时候也将在替换模式中使用的编号组称为反向引用。所以,可以认为无论是/1还是$1还是${date},只是因地制宜地使用了不同的形式而已，在本质上它们都是反向引用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一遍又一遍的学习正则表达式，这些难点总是使用时候就忘了，忘了又看。一直没有总结下，这一次重新学习基础，就总结一下这非常重要的正则表达式吧。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>流逝的风</title>
      <link href="/2018/02/17/%E6%B5%81%E9%80%9D%E7%9A%84%E9%A3%8E/"/>
      <url>/2018/02/17/%E6%B5%81%E9%80%9D%E7%9A%84%E9%A3%8E/</url>
      <content type="html"><![CDATA[<h1 id="风曾来自何方"><a href="#风曾来自何方" class="headerlink" title="风曾来自何方"></a>风曾来自何方</h1><p>世间的万物都会随着时间慢慢流逝，无论宏伟的高山或是低浅的河谷。随着时间，它们终将不复从前的模样。<br>过去的已经过去，但是还有谁能记得那曾经的过去，那曾经细细研磨的过去。<br>刺破云际的高峰，曾经也是一座小土堆；平静的小溪，曾经也是一条湍急的河流。<br>一阵微风轻拂我的面容，夹杂着远方的花香，我轻轻的嗅着，感受来自远方的问候。风儿来自何处？<br>它是否也曾越过洋流，也曾翻过高山，也曾与蝴蝶起舞。如今也将越过我，去往更遥远的天河。<br>我仍在轻嗅着这微风的香气，而风已经离去……<br><a id="more"></a></p><h1 id="风欲飘向何处"><a href="#风欲飘向何处" class="headerlink" title="风欲飘向何处"></a>风欲飘向何处</h1><p>我知道风是不能挽留的，亦是不能追逐的，我只能站在原地静静的看它离去。<br>再见了！朋友！我无力的在心中哭泣。为不能挽留的一切，哭泣。  </p><h1 id="风止于我心中"><a href="#风止于我心中" class="headerlink" title="风止于我心中"></a>风止于我心中</h1><p>谁能知道风与我相遇的那一刻？波光粼粼的湖边，夕阳透过随风舞动的柳枝将一束束的光芒印在你的脸上。<br>坐在长椅上，你的目光凝视着前方，直到我的出现，甜蜜的笑容逐渐浮现在你的脸上。<br>我曾错过无数的风景，每一刻都印成照片，贴在我的心墙。如今我的小裕，我不能承受再错过美丽的你了。<br>爱你，珍惜有你的每一刻。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>怀旧，是我最大的感情波动。人说无事夏迎春，可我却时常陷入过去。<br>我心心念念的风，它的曾经包括它的未来我都未曾参与，仅在某一刻与我擦肩而过，但我却深深不忘。<br>无论风儿来自何处，无论风儿飘向何方，但是风儿永远停在了我的心中。至少那一刻，那一瞬，风儿是永远属于我一人的。</p>]]></content>
      
      <categories>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>额叶切除手术</title>
      <link href="/2018/02/09/%E9%A2%9D%E5%8F%B6%E5%88%87%E9%99%A4%E6%89%8B%E6%9C%AF/"/>
      <url>/2018/02/09/%E9%A2%9D%E5%8F%B6%E5%88%87%E9%99%A4%E6%89%8B%E6%9C%AF/</url>
      <content type="html"><![CDATA[<h1 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h1><p>近几个月来，在影片或游戏中，我总能接触到一个名词“额叶切除手术”。在影片《禁闭岛》、《飞跃疯人院》、《美国恐怖故事第二季》以及游戏《光之镇》中都有此手术。我不知道这种手术究竟是什么，但我能感受到此手术的黑暗与绝望。因为无论是影片还是游戏中，接受此手术的人都变成了一具行尸走肉。为此我特别困惑，这究竟是什么手术，手术效果如此恐怖，如此受人诟病。<br><a id="more"></a></p><h1 id="精神病的难题"><a href="#精神病的难题" class="headerlink" title="精神病的难题"></a>精神病的难题</h1><p>对于大脑结构和情感都是最为复杂和脆弱的人类而言，精神问题由来已久。不论是生理的改变。遗传的影响抑或是心理创伤，都很容易让人坠入精神疾病的泥潭，而数千年来，人类都对此一无所知，束手无策。<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/yy4.jpg" alt=""><br>痛苦归痛苦，因为对精神疾病缺乏了解，人们对此毫无办法。患者能自行摆脱疾病困扰的少之又少，而旁人也提不出什么好的治疗方案，直到18世纪，人们依然认为精神病源于邪灵附体等外部原因，而直到20世纪初期都还只能通过监禁束缚病人身体，对其施以大量镇静剂甚至是鸦片暂时遏制其行为，得过且过。<br>这样毕竟治标不治本，病情并不能得到缓解，最后的结果是被送入精神病院的极少有康复者，新病人却源源不断涌入，以至于每家精神病院都容纳了数千名患者，人们急需找到有效的疗法。</p><h1 id="噩梦疗法"><a href="#噩梦疗法" class="headerlink" title="噩梦疗法"></a>噩梦疗法</h1><p>而后，“前脑叶白质切断术”横空出世。葡萄牙神经外科医生莫尼斯从一次动物实验报告会中获得了启发，尝试向精神病患者的前脑叶注射酒精杀死其部分脑神经。手术取得了成功——他是这样宣称的。尽管病人最终没能完全康复，但患者确实活了下来，而且精神病的程度看起来确实有所减轻。此手术还获得1949年的诺贝尔医学奖。<br>这次“成功”大大鼓舞了莫尼斯，他接下来又做了数十例这样的手术，并且向公众宣传。但这样的手术需要复杂的外科手术步骤，对手术设施也有很大的要求。<br>这时，另一个重要人物，美国医生沃尔特·弗里曼站出来，宣布了一项“重大改进”：冰锥疗法。<br>冰锥疗法所需要的设施很简单：螺丝刀、冰锥、钢针，只要是又粗又长又硬的东西就可以。手术室？不需要，直接把病人捆在床上，把冰锥从病人眼眶上方捅进去，捅到大脑前部，根据经验捣两下，捣烂了，收工，搞定。手术所需时间比拔个牙还快，疗程短，见效快，深得大众的欢迎。<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/bz1.jpg" alt=""><br><em>冰锥入脑，正是当年医生们“治疗”精神病人的常见方式</em><br>效果有多好？好像还真是意外地有效。再狂躁的患者，这样一捣，也马上变成了温驯的小绵羊，变得平静而乖巧，可以任人摆布——就是有点温顺过头了。哪怕是手术成功者，也变得几乎失去了一切的感情，失去了主观意识，失去了欲望，失去了智能，变得迟钝、麻木、呆滞，成了一具具行尸走肉。对于“手术成功者”而言也不过如此，如此简陋的手术，没有任何定位，就是靠医师经验乱捣一气，“失败者”也不在少数：或是死在手术台上、或是变得极端狂躁和抑郁、或是身体的某一部分残疾无法控制……这让脑叶白质切除手术成了一项轮盘赌博运动。  　然而当时确实没有什么更好的疗法，大家都病急乱投医，再加上平静温顺的木偶人正合院方和病人家属的愿望，这项手术居然得以顺利开展数十年，而其发明者甚至还获得了1949年的诺贝尔生理学或医学奖，更加助推了这场热潮。偶有反对的声音，也被淹没在人们的热情之下，　　<br>病人不配合怎么办？拉去做手术吧；　　<br>脾气太火爆怎么办？拉去做手术吧；　　<br>孩子不听话怎么办？拉去做手术吧；　　<br>……<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/bz2.jpg" alt=""><br>越来越多病人，甚至与精神病半点关系没有的人都被迫进行了这项恐怖手术。　　<br>噩梦疗法的存在，让那几十年内的精神病院，变得比监狱更为恐怖。在监狱你还能作为一个人活着，在精神病院，却只能成为一个白痴。<br>可能有点出乎我们的意料，但精神病药物，确实是从上世纪50年代中才开始出现的。精神病药物的出现吹响了人道主义的号角：过往的手术造成的后遗症大家都看在眼里，如今出现了只需服用便可以缓解病情的药物，落后的疗法又有何意义呢？随着反对的浪潮日益高涨，灭绝人性的前脑叶白质切除手术逐渐在各个国家被禁止使用。<br>而1975年上映的《飞越疯人院》，则成为了压垮骆驼的最后一根稻草。影片中对精神病院内部高压管制措施的揭露和对自由精神的歌颂，正式在全社会引起了对精神病院质量的关注。我们的故事舞台，沃尔泰拉精神病院也在1978年被意大利政府以“残忍对待病人”的理由关停，并在之后通过一项声明对其进行谴责。<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/yy1.jpg" alt=""><br><em>精神病医院的内景，虽然已经荒废，但不能忘却这里曾发生过的残忍事件</em><br>自此，“疯人院”时代宣告结束，终于迈进到真正的“精神病院“时代，完善的心理咨询、病理检测和药物控制，让精神病患者最终可以抬起头来，在医疗体系的扶持下接受治疗，走出阴影。　　<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/yy3.jpg" alt=""><br>然而，在那噩梦般的40年里，受到伤害的无数人，又该找谁算账？又有谁关心过他们的遭遇？<br>所以说一代人的诺贝尔奖疗法可能是另一代人最恐怖的噩梦。</p><h1 id="光之镇"><a href="#光之镇" class="headerlink" title="光之镇"></a>光之镇</h1><p>光之镇的游戏就是诉说着这个事实。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">She is so young,just 23.But is lacking all vitality.她很年轻，只有23岁而已。但是已经完全丧失了活力。  </span><br><span class="line">Her life has been thrown away.她的人生，已不复存在。  </span><br><span class="line">Nobody did anything to try to avoid this.从没有人想过通过任何手段制止这场悲剧的发生。</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/yuhongjing/img-folder/raw/master/img/girl1.jpg" alt=""><br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/girl2.jpg" alt=""><br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/girl3.jpg" alt=""><br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/girl4.jpg" alt=""><br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/girl5.jpg" alt=""><br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/girl6.jpg" alt=""><br>这款游戏是真实的事情改编（以曝光当年血腥的现实），让人琢磨不透的人物，没有黑暗，没有俗套的突然冒出来的不知名物体，连回忆都是漫画形式，它的恐怖之处就在于，黑暗不可怕，鬼怪不可怕，真正可怕的只有同类的迫害，因为提示什么的扑朔迷离，她在和谁说话，和她自己，和身为玩家的我们，还是谁？人们以“治疗”为由，用各种反人道的手段让病人安静，难道安静比生命更重要？（女主和母亲之间未被通过的信件，医生对女主实施暴行等等）讽刺当时对待有精神问题的人的手段。更让我们体会到，他们的无助和崩溃。最后的镜头女主无神的双眼让人很心疼。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上的资料只是冰山一角，不仅仅对于精神病人，对于很多“不听话的人”，都被实施了这种手术，从而使她“死亡”。而被强制实施了这种手术的人，你只能看见他空洞的眼神，和被剥夺灵魂的躯体。这种来自地狱的手术却获得了诺贝尔医学奖，不由得让人心中一颤。每当我看见影片，游戏或书籍中，那被实施手术的人，“安静”的样子，就觉得一身寒意。</p>]]></content>
      
      <categories>
          
          <category> 百科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 百科 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>5年的计划</title>
      <link href="/2018/02/02/5%E5%B9%B4%E7%9A%84%E8%AE%A1%E5%88%92/"/>
      <url>/2018/02/02/5%E5%B9%B4%E7%9A%84%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><p>Quora有人提出一个问题：作为一个23岁的学生，现在开始做一些什么事情可以在5年之后觉得受益匪浅？<br>其中有一个6千多like的答案，觉得很有用，分享给大家~<br><a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">There&apos;s already a lot here and you probably stopped reading,   </span><br><span class="line">but I couldn&apos;t resist writing a note to my 23 year old self:</span><br></pre></td></tr></table></figure><p>虽然很长你读不完，不过我真的很想把这些写给23岁的我：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If you do anything,do this first one:learn how to work hard and stick with something.  </span><br><span class="line">Learn how to turn off Facebook and control your addiction to social media.    </span><br><span class="line">You&apos;ll instantly be ahead of 90% of your generation.</span><br></pre></td></tr></table></figure></p><p>先学会这一点：无论做什么事情，都努力，坚持的做完。<br>一旦你学会了控制自己不要去玩社交媒体，学会了不去刷Facebook，你就已经比你同辈90%的人都要进步了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Video games are a time sink.If you can play for an hour and say &quot;That was fun,  </span><br><span class="line">let&apos;s do something else&quot; then you&apos;re ok.Otherwise,just get rid of them.</span><br></pre></td></tr></table></figure></p><p>玩游戏就跟浪费时间没区别。除非你真能控制住只玩一个小时之后愉快的去干别的事情，不然还是戒了吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pick up an athletic hobby that you can do through the years,</span><br><span class="line">or your sedentary academic lifestyle will do horrible things   </span><br><span class="line">to your posture,back,and gut.</span><br></pre></td></tr></table></figure></p><p>选一项运动当成兴趣，不然你的学术生涯会把你的身子毁掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Learn how to deal with interpersonal conflicts.  </span><br><span class="line">Read Crucial Conversations and practice - it&apos;s a lifechanger   </span><br><span class="line">(shameless plug:Crucial Conversations Tools for Talking  </span><br><span class="line">When Stakes Are High,Second Edition)</span><br></pre></td></tr></table></figure></p><p>学会处理人际冲突…上面的这本书就不错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Learn how to talk on the phone with people you don&apos;t know.  </span><br><span class="line">It still terrifies most people.Get a phone sales job and quit after a few weeks.</span><br></pre></td></tr></table></figure></p><p>学会怎么在电话上跟陌生人交流。去找一个电话销售的工作，干几个礼拜辞职就好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Start some kind of little side ventrue to learn entrepreneurial principles.  </span><br><span class="line">Start a window washing business,buy   and sell stuff on Craigslist,do anything.  </span><br><span class="line">You might need them if you&apos;re in between jobs.</span><br></pre></td></tr></table></figure></p><p>做一些小活来学会创业。比如洗窗户啦，在Craigslist上卖点小玩意啦。以后工作中你会用得到这些技能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Take a course on statistics and how they&apos;re misused,  </span><br><span class="line">specifically how faulty causal arguments are made.  </span><br><span class="line">It will change the way you approach almost any discussion,quantitative or not.</span><br></pre></td></tr></table></figure></p><p>上一些统计学的课，知道他们是怎么被误用的。将来对于识别一些谬论很有帮助。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Always have a private place where you can talk out loud to God every day.  </span><br><span class="line">Even if you&apos;re not relligious or don&apos;t believe in God.  </span><br><span class="line">Talk out loud to the universe.Sort out your thoughts,verbalize them,  </span><br><span class="line">and then write down what comes to mind.  </span><br><span class="line">Something wiser than you is listening and responding,   </span><br><span class="line">even if it&apos;s just another side of you.</span><br></pre></td></tr></table></figure></p><p>找一个属于自己的可以大声跟上帝说话的地方。哪怕你不信教，你也可以试着大声跟宇宙说话吧。理清你的思绪，然后写下来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Use http://Mint.com to track your expenses.  </span><br><span class="line">Make a budget and learn how to stick to it.  </span><br><span class="line">Learn to live lean how while you can,so you won&apos;t be forced to later on.</span><br></pre></td></tr></table></figure></p><p>用记录软件记录每天的开销，学会做预算。学会过一些简朴的生活。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Learn a foreign language,but only if you anticipate using it.</span><br></pre></td></tr></table></figure></p><p>学一门平常会用的外语。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Learn how to network.  </span><br><span class="line">Read &quot;Never Eat Alone.&quot;Hint:it&apos;s about doing things for other people.</span><br></pre></td></tr></table></figure></p><p>学会处理人际关系。这就是怎么跟人打交道的学问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Learn how to cook tasty,cheap food.</span><br></pre></td></tr></table></figure></p><p>学会做一些简单又美味的饭。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Find music that inspires you and makes you feel alive.  </span><br><span class="line">Listen to it every morning and if it&apos;s something embarrassing  </span><br><span class="line">just don&apos;t tell your friends about it.</span><br></pre></td></tr></table></figure></p><p>找一些能够激励你的音乐。每天早上起床后听着它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Save up a few thousand dollars and go somewhere crazy with a few friends.  </span><br><span class="line">Live in a hostel for a few weeks.  </span><br><span class="line">It will change your life and you will think about it forever.</span><br></pre></td></tr></table></figure></p><p>攒个几千块钱，可以跟朋友一起出去疯狂一次。比如在青年旅店住上几个星期，会改变你整个人生的看法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">When someone promises you easy money,run the other way.Yes,it is a scam.</span><br></pre></td></tr></table></figure></p><p>如果有人给你很容易挣钱的方法，别信，基本都是骗子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Read a book a week.When you get ridiculously wealthy,  </span><br><span class="line">read a book a day.Read fiction too.</span><br></pre></td></tr></table></figure></p><p>每周读一本书，等你称为富豪时，每天读一本。</p><h2 id="结言"><a href="#结言" class="headerlink" title="结言"></a>结言</h2><p>可能是最近我玩的太疯狂了，太堕落了。经常都能看见类似这样的文章。静下心来认真看，的确有道理。人的一生需要不停的学习再学习。<br>有一个场景我总记得，2005年，温家宝总理探望93岁高龄的钱学森，向他咨询教育方面的意见。在这次交流中，钱学森向温家宝发出了一个严峻的疑问：为什么我们的学校总是培养不出杰出人才？这就是著名的“钱学森之问”。钱学森说：我认为人不但要有科学技术，而且还要文化艺术跟音乐。<br>人的一生都需要来自各方面的学习，科学，艺术，生活，方方面面。向优秀的人学习优秀的品质。</p>]]></content>
      
      <categories>
          
          <category> 鸡汤 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>迷宫逃脱算法</title>
      <link href="/2017/12/18/%E8%BF%B7%E5%AE%AB%E9%80%83%E8%84%B1%E7%AE%97%E6%B3%95/"/>
      <url>/2017/12/18/%E8%BF%B7%E5%AE%AB%E9%80%83%E8%84%B1%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>第一行输入 迷宫x轴，y轴，门几秒开一次。输入S为你的起点，小数点.为可以通过的地方。<br>D为门的位置，X是不能通过的位置。当输入 0 0 0时结束。<br><a id="more"></a></p><h3 id="示例输入"><a href="#示例输入" class="headerlink" title="示例输入"></a>示例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4 4 5</span><br><span class="line">S . X .</span><br><span class="line">. . X .</span><br><span class="line">. . X D</span><br><span class="line">. . . .</span><br><span class="line">3 4 5</span><br><span class="line">S . X .</span><br><span class="line">. . X .</span><br><span class="line">. . . D</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure><h3 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a>示例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt; </span><br><span class="line">#include &lt;stdlib.h&gt; </span><br><span class="line">using namespace std;//命名空间  </span><br><span class="line"></span><br><span class="line">char map[9][9]; </span><br><span class="line">int n,m,t,di,dj; </span><br><span class="line">bool escape; </span><br><span class="line">int dir[4][2]=&#123;&#123;0,-1&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;; </span><br><span class="line"></span><br><span class="line">void dfs(int si,int sj,int cnt) //起点以及行走的时间(可根据递归改变) </span><br><span class="line">&#123;    int i,temp; </span><br><span class="line">   if(si&gt;n||sj&gt;m||si&lt;=0||sj&lt;=0) return; //不能走出地图之外 </span><br><span class="line">   if(cnt==t&amp;&amp;si==di&amp;&amp;sj==dj)    escape=1;//如果起点的坐标和门的位置相同，并且此时行走的步数和门的开启时间吻合  就能逃脱 </span><br><span class="line">   if(escape) return; //逃脱退出循环 </span><br><span class="line">  </span><br><span class="line">   temp=(t-cnt)-abs(si-di)-abs(sj-dj); //</span><br><span class="line">   if(temp&lt;0||temp&amp;1) return;  </span><br><span class="line">   for(i=0;i&lt;4;i++)&#123; </span><br><span class="line">      if(map[si+dir[i][0]][sj+dir[i][1]]!=&apos;X&apos;)</span><br><span class="line">  &#123; </span><br><span class="line">         map[si+dir[i][0]][sj+dir[i][1]]=&apos;X&apos;; </span><br><span class="line">         dfs(si+dir[i][0],sj+dir[i][1],cnt+1); </span><br><span class="line">         map[si+dir[i][0]][sj+dir[i][1]]=&apos;.&apos;; //递归回溯 </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   return; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">int i,j,si,sj; </span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;t)//行列时间 </span><br><span class="line">&#123; </span><br><span class="line">  if(n==0&amp;&amp;m==0&amp;&amp;t==0) break; //输入000时退出 </span><br><span class="line">  int wall=0;//墙的个数 </span><br><span class="line">  for(i=1;i&lt;=n;i++) </span><br><span class="line">         for(j=1;j&lt;=m;j++) //输入地图 </span><br><span class="line"> &#123; </span><br><span class="line">            cin&gt;&gt;map[i][j]; </span><br><span class="line">            if(map[i][j]==&apos;S&apos;) &#123; si=i; sj=j; &#125; //起点位置  这里没有判断起点是否唯一 </span><br><span class="line">            else if(map[i][j]==&apos;D&apos;) &#123; di=i; dj=j; &#125; //门的坐标位置 </span><br><span class="line">            else if(map[i][j]==&apos;X&apos;) wall++; //墙的数量 </span><br><span class="line">         &#125; </span><br><span class="line">       if(n * m - wall &lt;= t) //如果行列个数  比墙还少 有误！ </span><br><span class="line">   &#123;</span><br><span class="line">   cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">   continue;</span><br><span class="line">   &#125;</span><br><span class="line">   escape=0; //逃脱标记 </span><br><span class="line">       map[si][sj]=&apos;X&apos;; //起点默认为X  因为起点走了 不可能在回来了！！而且必须从起点开始出发 相当于起点是必经点 </span><br><span class="line">       dfs(si,sj,0); //递归判断 </span><br><span class="line">       if(escape) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; //如果标记为1说明逃脱了 </span><br><span class="line">       else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; </span><br><span class="line">   &#125; </span><br><span class="line">   return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>典型的迷宫问题，熟练此题，能够掌握递归回溯的搜索问题。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++文件读入</title>
      <link href="/2017/12/18/C-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%85%A5/"/>
      <url>/2017/12/18/C-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%85%A5/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>C++文件流入流出，iostream流，fstream流。<br><a id="more"></a></p><h3 id="单行文件读入"><a href="#单行文件读入" class="headerlink" title="单行文件读入"></a>单行文件读入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int cnt=0;</span><br><span class="line">    int i;</span><br><span class="line">    ifstream fin;</span><br><span class="line">    ofstream fout;</span><br><span class="line">    </span><br><span class="line">fin.open(&quot;D:\\homework--net\\test.txt&quot;, ios::in);</span><br><span class="line">    fout.open(&quot;D:\\homework--net\\test1.txt&quot;, ios::app);</span><br><span class="line">    </span><br><span class="line">    if(!fin)&#123;</span><br><span class="line">        printf(&quot;The file is not exist!&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!fin.eof())</span><br><span class="line">    &#123;</span><br><span class="line">        fin &gt;&gt; i;</span><br><span class="line">        int sum = i;</span><br><span class="line">        fout&lt;&lt;sum&lt;&lt;&quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    fin.close();</span><br><span class="line">    fout.close();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多行文件流出"><a href="#多行文件流出" class="headerlink" title="多行文件流出"></a>多行文件流出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int cnt=0;</span><br><span class="line">    int a[20][3];</span><br><span class="line">    ifstream fin;</span><br><span class="line">    ofstream fout;</span><br><span class="line">    </span><br><span class="line">fin.open(&quot;D:\\test.txt&quot;, ios::in);</span><br><span class="line">    fout.open(&quot;D:\\test1.txt&quot;, ios::app);</span><br><span class="line">    </span><br><span class="line">    if(!fin)&#123;</span><br><span class="line">        printf(&quot;The file is not exist!&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!fin.eof())</span><br><span class="line">    &#123;</span><br><span class="line">        fin &gt;&gt; a[cnt][0]&gt;&gt;a[cnt][1]&gt;&gt;a[cnt][2];</span><br><span class="line">        int sum = a[cnt][0] + a[cnt][1] + a[cnt][2];</span><br><span class="line">        fout&lt;&lt;sum&lt;&lt;&quot;\n&quot;;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    fin.close();</span><br><span class="line">    fout.close();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美女购物(动态规划)</title>
      <link href="/2017/12/07/%E7%BE%8E%E5%A5%B3%E8%B4%AD%E7%89%A9-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2017/12/07/%E7%BE%8E%E5%A5%B3%E8%B4%AD%E7%89%A9-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>一天，MM陪佳佳逛街，看到有许多漂亮的衣服，佳佳要让MM给她买衣服，但是MM发现衣服的价格实在高的令人胆寒，MM当然不愿意买这么贵的衣服。<br>因此她就想着从街头逛到街尾买到的衣服价格总要比前一件购买的价格低，绝不回头购买，但是他又想让佳佳高兴，所以他想尽可能的多买几件衣服，你能帮帮她吗？<br><a id="more"></a></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>测试数据包括两行:<br>第一行输入一个整数N（N&lt;10000）<br>第二行输入N个整数，表示从街头到街尾的衣服的价格（按从头到尾的顺序）。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>测试数据的输出只占一行，输出佳佳最多能买到多少件衣服。</p><h2 id="Example-Input"><a href="#Example-Input" class="headerlink" title="Example Input"></a>Example Input</h2><p>16<br>300 250 275 252 200 138 245 130 300 128 244 243 242 241 240 239</p><h2 id="Example-Output"><a href="#Example-Output" class="headerlink" title="Example Output"></a>Example Output</h2><p>10</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define N 100</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[N],b[N];</span><br><span class="line">    int n,i,j;</span><br><span class="line">    int max;</span><br><span class="line">    while(cin&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        for(i=0;i&lt;n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        b[0]=1;//初始化，以a[0]结尾的最长递增子序列长度为1      </span><br><span class="line">for(i=1;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i]=1;</span><br><span class="line">            for(j=0;j&lt;i;j++)</span><br><span class="line">            if(a[i]&lt;a[j]&amp;&amp;b[j]+1&gt;b[i])//关键算法，每次调用上一级的b[i];</span><br><span class="line">            b[i]=b[j]+1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=max=0;i&lt;n;i++)//求出整个数列的最长递增子序列的长度       </span><br><span class="line">if(max&lt;b[i])</span><br><span class="line">        max=b[i];</span><br><span class="line">        cout&lt;&lt;max;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Php魔术方法</title>
      <link href="/2017/12/04/Php%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"/>
      <url>/2017/12/04/Php%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>PHP在设计的时候，预先定义了9个超级全局变量、8个魔术变量和13个魔法方法，这些变量和函数可以在脚本任何地方不用声明就可以使用。<br>在PHP开发会频繁的使用这些变量和方法。会很方便的帮我们解决很多事情。<br><a id="more"></a></p><h2 id="PHP超级全局变量（9个）"><a href="#PHP超级全局变量（9个）" class="headerlink" title="PHP超级全局变量（9个）"></a>PHP超级全局变量（9个）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$GLOBALS        存储全局作用域中的变量</span><br><span class="line">$_SERVER        获取服务器相关信息</span><br><span class="line">$_REQUEST       获取POST和GET请求的参数</span><br><span class="line">$_POST          获取表单的POST请求参数</span><br><span class="line">$_GET           获取表单的GET请求参数</span><br><span class="line">$_FILES         获取上传文件的变量</span><br><span class="line">$_ENV           获取服务器端环境变量的数组</span><br><span class="line">$_COOKIE        浏览器cookie的操作</span><br><span class="line">    设置cookie    setcookie(name,value,expire,path,domain);</span><br><span class="line">    获取cookie    $_COOKIE[&quot;name&quot;];</span><br><span class="line">    删除cookie    setcookie(&quot;user&quot;,&quot;&quot;,time()-3600);//设置过期时间</span><br><span class="line">$_SESSION       服务器session的操作</span><br><span class="line">    启动session   session_start();</span><br><span class="line">    存储session   $_SESSION[&quot;name&quot;]=&quot;Li hua&quot;;</span><br><span class="line">    销毁session   unset($_SESSION[&quot;name&quot;]);</span><br><span class="line">    seesion_destroy()和unset($_SESSION);//销毁所有的session</span><br></pre></td></tr></table></figure><h2 id="PHP魔术变量（8个）"><a href="#PHP魔术变量（8个）" class="headerlink" title="PHP魔术变量（8个）"></a>PHP魔术变量（8个）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__LINE__　　        文件中的当前行号。</span><br><span class="line">　　__FILE__　　        文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。</span><br><span class="line">　　__DIR__　　         文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。</span><br><span class="line">　　__FUNCTION__　　    常量返回该函数被定义时的名字</span><br><span class="line">　　__CLASS__　　       常量返回该类被定义时的名字（区分大小写）。</span><br><span class="line">　　__METHOD__　　      类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。</span><br><span class="line">　　__NAMESPACE__　　   当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。</span><br></pre></td></tr></table></figure><h2 id="PHP魔术方法（13个）"><a href="#PHP魔术方法（13个）" class="headerlink" title="PHP魔术方法（13个）"></a>PHP魔术方法（13个）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　  __construct()　　      实例化对象时被调用，当__construct和以类名为函数名的函数同时存在时，__construct将被调用，另一个不被调用</span><br><span class="line">　　__destruct()　　       当删除一个对象或对象操作终止时被调用。</span><br><span class="line">　　__call()　　　　　     对象调用某个方法，若方法存在，则直接调用；若不存在，则会去调用__call函数。</span><br><span class="line">　　__get()　　　　        读取一个对象的属性时，若属性存在，则直接返回属性值；若不存在，则会调用__get函数。</span><br><span class="line">　　__set()　　　　        设置一个对象的属性时，若属性存在，则直接赋值；若不存在，则会调用__set函数。</span><br><span class="line">　　__toString()　　      打印一个对象的时被调用。如echo $obj;或print $obj;</span><br><span class="line">　　__clone()　　　       克隆对象时被调用。如：$t=new Test();$t1=clone $t;</span><br><span class="line">　　__sleep()　　　       serialize之前被调用。若对象比较大，想删减一点东东再序列化，可考虑一下此函数。</span><br><span class="line">　　__wakeup()　　        unserialize时被调用，做些对象的初始化工作。</span><br><span class="line">　　__isset()　　　       检测一个对象的属性是否存在时被调用。如：isset($c-&gt;name)。</span><br><span class="line">　　__unset()　　　　     unset一个对象的属性时被调用。如：unset($c-&gt;name)。</span><br><span class="line">　　__set_state()　　     调用var_export时，被调用。用__set_state的返回值做为var_export的返回值。</span><br><span class="line">　　__autoload()　　      实例化一个对象时，如果对应的类不存在，则该方法被调用。</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP魔法变量 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些我看的书</title>
      <link href="/2017/12/02/%E4%B8%80%E4%BA%9B%E6%88%91%E7%9C%8B%E7%9A%84%E4%B9%A6/"/>
      <url>/2017/12/02/%E4%B8%80%E4%BA%9B%E6%88%91%E7%9C%8B%E7%9A%84%E4%B9%A6/</url>
      <content type="html"><![CDATA[<h2 id="前瞻"><a href="#前瞻" class="headerlink" title="前瞻"></a>前瞻</h2><p>The essence of all time in the past， in the book.<br>过去一切时代的精华尽在书中。<br>Books are a great talent for the heritage of mankind.<br>书籍是伟大的天才留给人类的遗产。<br>Reading is to build up your mind with the help of other people’s idea.<br>读书是在别人思想的帮助下，建立自己的思想.<br><a id="more"></a></p><h2 id="计算机综合书"><a href="#计算机综合书" class="headerlink" title="计算机综合书"></a>计算机综合书</h2><ol><li>《微软的梦工厂》</li></ol><h2 id="算法及数据结构"><a href="#算法及数据结构" class="headerlink" title="算法及数据结构"></a>算法及数据结构</h2><ol><li>《数据结构与算法分析–c语言描述第二版》  </li><li>《剑指offer》 </li></ol><h2 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h2><ol><li>《数据库系统原理及应用–第二版》</li></ol><h2 id="C，C-，C"><a href="#C，C-，C" class="headerlink" title="C，C++，C"></a>C，C++，C</h2><ol><li>《C Primer Plus–第6版》</li></ol><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ol><li>《疯狂Java讲义–第二版》</li></ol><h2 id="其他书籍"><a href="#其他书籍" class="headerlink" title="其他书籍"></a>其他书籍</h2><ol><li>《肖申克的救赎》</li><li>《瓦尔登湖》</li></ol><h2 id="待看的书"><a href="#待看的书" class="headerlink" title="待看的书"></a>待看的书</h2><ol><li>《硅谷之火》</li><li>《Unix编程艺术》</li><li>《代码整洁之道》</li><li>《我编程，我快乐：程序员职业规划之道》</li><li>《赢得朋友》</li><li>《Head First设计模式》</li><li>《口渴之前先挖井》</li><li>《邻家的百万富翁》</li><li>《牧羊少年奇幻之旅》</li><li>《设计模式之禅》</li><li>《编码:隐匿在计算机软硬件背后的语言》</li><li>《深入理解计算机系统》</li><li>《程序员的自我修养》</li></ol>]]></content>
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Thinkphp基于linux的坑</title>
      <link href="/2017/12/01/Thinkphp%E5%9F%BA%E4%BA%8Elinux%E7%9A%84%E5%9D%91/"/>
      <url>/2017/12/01/Thinkphp%E5%9F%BA%E4%BA%8Elinux%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<h2 id="关于Thinkphp的缓存"><a href="#关于Thinkphp的缓存" class="headerlink" title="关于Thinkphp的缓存"></a>关于Thinkphp的缓存</h2><p>因为thinkphp会有一个runtime的缓存文件，而linux的文件默认没有写的权限，所以我们需要将文件设置为777即读写的权限。</p><h2 id="关于Thinkphp的URL大小写敏感"><a href="#关于Thinkphp的URL大小写敏感" class="headerlink" title="关于Thinkphp的URL大小写敏感"></a>关于Thinkphp的URL大小写敏感</h2><p>Thinkphp5会默认将url转为小写，然后再linux系统中是区分大小写的url，这将会导致无法找到文件。<br>所以在config添加一句’url_convert’=&gt;false,就可以取消thinkphp的url自动转换为小写。</p>]]></content>
      
      <categories>
          
          <category> 填坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue环境搭建</title>
      <link href="/2017/11/28/Vue%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2017/11/28/Vue%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h2 id="环境配置流程"><a href="#环境配置流程" class="headerlink" title="环境配置流程"></a>环境配置流程</h2><ol><li>安装Node.js</li><li>安装Vue-cli脚手架</li><li>初始化一个项目</li><li>模块依赖安装</li><li>启动<a id="more"></a></li></ol><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node.js安装后，在cmd中输入node -v 和 npm -v 如果出现版本号即安装成功</span><br><span class="line">全局安装Vue  在cmd输入npm install -g vue </span><br><span class="line">全局安装脚手架 npm install -g vue-cli</span><br><span class="line">创建一个项目 到目录位置 vue init webpack 项目名</span><br><span class="line">创建模块依赖   npm install </span><br><span class="line">启动项目    npm run dev</span><br><span class="line">发布项目    npm run build</span><br></pre></td></tr></table></figure><p>ps.如果安装过慢，可以使用国内的镜像cnpm!</p>]]></content>
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式</title>
      <link href="/2017/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当一个项目的数据特别大时，如果我们还是将数据，页面，和操作混杂在一起使用时。<br>就会明显发现逻辑特别的混杂，不方便我们之后的扩展等操作！所以为了理清楚逻辑。<br>我们需要将数据，页面，操作分开处理！！这也就产生了各种的设计模式。</p><a id="more"></a><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC(Model-View-Controller)是最常见的软件架构之一。非常容易理解，就是分离三个部分。</p><ol><li>视图(View):用户界面</li><li>控制器(Controller):业务逻辑操作</li><li>模型(Model):数据处理</li></ol><p>各部分之间的通信方式如下。<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/mvc.png" alt=""></p><ol><li>View传送指令到Controller</li><li>Controller完成业务逻辑后,让Model改变状态</li><li>Model传回数据到View,用户得到反馈</li></ol><p>ps.所有的通信都是单向的。<br>ps.Model的操作应该比Controller的重，我曾经就是所有东西都写在控制器中。。。没有理解到Model</p><p>优点：分层清晰，便于扩展<br>缺点：操作变得复杂，降低了性能<br>代表框架:Thinkphp</p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP(Model-View-Presenter)是从MVC演变而来的，思想差不多。唯一的变化就是View不能直接访问Model！<br>View视图需通过Presenter来访问Model。<br>其实在MVC中，我们也不建议View直接访问Model,最好通过Presenter来访问Model!  </p><ol><li>视图(View):用户界面</li><li>控制器(Presenter):业务逻辑操作渲染视图</li><li>模型(Model):数据处理</li></ol><p>各部分之间的通信方式如下。<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/mvp.png" alt="">  </p><ol><li>View传送指令到Presenter</li><li>Presenter处理逻辑调用Model</li><li>Model处理数据返回Presenter</li><li>Presenter返回数据到View</li></ol><p>ps.所有的通信都是双向的。</p><p>优点:模型视图分离，修改视图不影响模型,Presenter可以使用多个视图。<br>缺点:视图的渲染都放在了Presenter中，会导致视图和Presenter交互过于频繁。</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM(Model-View-ViewModel)与MVP模式完全一致(进化)，将Presenter改名为ViewModel。<br>唯一的区别是，它采用双向绑定。<br>View的变动，都会使ViewModel改变，反之亦然。</p><p><img src="https://github.com/yuhongjing/img-folder/raw/master/img/mvvm.png" alt=""></p><p>优点:简化了业务与页面的依赖关系，优化了数据更新频繁。<br>代表框架:Vue  Angular </p>]]></content>
      
      <categories>
          
          <category> 研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo常用命令</title>
      <link href="/2017/11/20/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/11/20/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="hexo配置命令"><a href="#hexo配置命令" class="headerlink" title="hexo配置命令"></a>hexo配置命令</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. npm install hexo -g #安装  </span><br><span class="line">2. npm update hexo -g  #升级  </span><br><span class="line">3. hexo init           #初始化</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="hexo基础命令"><a href="#hexo基础命令" class="headerlink" title="hexo基础命令"></a>hexo基础命令</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. hexo new "文章名" == hexo n "文章名" #新建文章</span><br><span class="line">2. hexo generate == hexo g    #生成本地静态文件</span><br><span class="line">3. hexo server == hexo s #启动服务预览</span><br><span class="line">4. hexo deploy == hexo d #部署</span><br><span class="line">5. hexo clean #清除缓存</span><br></pre></td></tr></table></figure><h3 id="hexo模板"><a href="#hexo模板" class="headerlink" title="hexo模板"></a>hexo模板</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. hexo new "文章名" #新建文章</span><br><span class="line">2. hexo new page "pageName" #新建页面</span><br></pre></td></tr></table></figure><h3 id="推送到服务器"><a href="#推送到服务器" class="headerlink" title="推送到服务器"></a>推送到服务器</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. hexo n #写文章</span><br><span class="line">2. hexo g #生成静态文件</span><br><span class="line">3. hexo d #部署  可与hexo g合并为 hexo d -g</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单线程？多线程？</title>
      <link href="/2017/11/20/%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2017/11/20/%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<p>作者：pansz<br>链接：<a href="https://www.zhihu.com/question/19901763/answer/13299543" target="_blank" rel="noopener">https://www.zhihu.com/question/19901763/answer/13299543</a></p><h2 id="来源：知乎-著作权归作者所有。"><a href="#来源：知乎-著作权归作者所有。" class="headerlink" title="来源：知乎 著作权归作者所有。"></a>来源：知乎 著作权归作者所有。</h2><h3 id="线程解释"><a href="#线程解释" class="headerlink" title="线程解释"></a>线程解释</h3><ol><li>单进程单线程：一个人在一个桌子上吃菜。</li><li>单进程多线程：多个人在同一个桌子上一起吃菜。</li><li>多进程单线程：多个人每个人在自己的桌子上吃菜。 </li></ol><a id="more"></a><h3 id="多线程的问题"><a href="#多线程的问题" class="headerlink" title="多线程的问题"></a>多线程的问题</h3><p>典型的银行家算法，哲学家进餐都是有关进程的问题。多线程的问题是多个人同时吃一道菜的时候容易发生争抢。<br>例如两个人同时夹一个菜，一个人刚伸出筷子，结果伸到的时候已经被夹走菜了。。。<br>此时就必须等一个人夹一口之后，在还给另外一个人夹菜，也就是说资源共享就会发生冲突争抢。</p><h3 id="windows与Linux的区别"><a href="#windows与Linux的区别" class="headerlink" title="windows与Linux的区别"></a>windows与Linux的区别</h3><ol><li>对于 Windows 系统来说,【开桌子】的开销很大,因此Windows鼓励大家在一个桌子上吃菜。<br>因此Windows多线程学习重点是要大量面对资源争抢与同步方面的问题。</li><li>对于 Linux 系统来说,【开桌子】的开销很小,因此Linux鼓励大家尽量每个人都开自己的桌子吃菜。  </li></ol><p>这带来新的问题是:坐在两张不同的桌子上说话不方便。因此Linux下的学习重点大家要学习进程间通讯的方法。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>开桌子的意思是指创建进程。开销这里主要指的是时间开销。<br>可以做个实验:创建一个进程,在进程中往内存写若干数据,然后读出该数据,然后退出.<br>此过程重复 1000 次，相当于创建/销毁进程1000次。<br>在我机器上的测试结果是:</p><ol><li>UbuntuLinux:耗时0.8秒</li><li>Windows7：耗时 79.8 秒  </li></ol><p>两者开销大约相差一百倍。这意味着,在Windows中,进程创建的开销不容忽视。<br>换句话说就是,Windows 编程中不建议你创建进程,如果你的程序架构需要大量创建进程,那么最好是切换到Linux系统。<br>大量创建进程的典型例子有两个,一个是gnu-autotools工具链，用于编译很多开源代码的。<br>他们在Windows下编译速度会很慢，因此软件开发人员最好是避免使用Windows.<br>另一个是服务器，某些服务器框架依靠大量创建进程来干活，甚至是对每个用户请求就创建一个进程，这些服务器在Windows下运行的效率就会很差。<br>这”可能”也是放眼全世界范围,Linux服务器远远多于Windows服务器的原因。</p><h3 id="再次补充"><a href="#再次补充" class="headerlink" title="再次补充"></a>再次补充</h3><p>如果你是写服务器端应用的，其实在现在的网络服务模型下，开桌子的开销是可以忽略不计的，<br>因为现在一般流行的是按照CPU核心数量开进程或者线程，开完之后在数量上一直保持。<br>进程与线程内部使用协程或者异步通信来处理多个并发连接，因而开进程与开线程的开销可以忽略了。<br>另外一种新的开销被提上日程：核心切换开销。现代的体系，一般CPU会有多个核心，而多个核心可以同时运行多个不同的线程或者进程。<br>当每个CPU核心运行一个进程的时候，由于每个进程的资源都独立，所以CPU核心之间切换的时候无需考虑上下文。<br>当每个CPU核心运行一个线程的时候，由于每个线程需要共享资源，所以这些资源必须从CPU的一个核心被复制到另外一个核心，才能继续运算，这占用了额外的开销。<br>换句话说，在CPU为多核的情况下，多线程在性能上不如多进程。因而，当前面向多核的服务器端编程中，需要习惯多进程而非多线程。</p><h3 id="一句话解释进程线程"><a href="#一句话解释进程线程" class="headerlink" title="一句话解释进程线程"></a>一句话解释进程线程</h3><ol><li>浏览器浏览一个页面，里面有很多图片，多线程，每个线程下载一副图片，他们相当于一个桌子上不同的菜。 </li><li>浏览器开了多个标签浏览不同网站，多进程，因为他们相当于“不同的桌子”</li></ol>]]></content>
      
      <categories>
          
          <category> 研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>梅花落</title>
      <link href="/2017/11/06/%E6%A2%85%E8%8A%B1%E8%90%BD/"/>
      <url>/2017/11/06/%E6%A2%85%E8%8A%B1%E8%90%BD/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">中庭多杂树,偏为梅咨嗟。</span><br><span class="line">问君何独然？念其霜中能作花，露中能作实。</span><br><span class="line">摇荡春风媚春日，念尔零落逐风飚，徒有霜华无霜质。</span><br><span class="line">                        ------鲍照 《梅零落》</span><br></pre></td></tr></table></figure><p>一夜风雨，桂花落满地。绿树已无零星，暗香仍残留。小雨淅淅，行客匆匆，何处为我安身处？<br>象牙塔内，皆随人流，而无一人同我行!  </p><p>昨夜梦他乡，泪湿满衣裳。寒窗残烛杯酒话星汉，酒不醉人人自醉；而今扶栏开绿帘，风雨飘摇人安笑。<br>呜呼！一人踏浪去，埋骨青山在。<br><a id="more"></a><br>无人共言书作伴，前途漫漫星为汉。若不使征途星辰，宁葬之大海。无意人言伤我身，乱我神。我亦不改！<br>仰天大笑出门去，燕雀安知我志哉。</p><p>羊者，草投之，足矣！狼也！非肉糜而不能驯之。奔袭千里，但使独狼耳，亦非肉糜而不食也。故狼行千里食肉！<br>每当孤独缠绕，寒冷便深入牙髓，我只能紧紧咬住双唇。忍住，再忍住。只要感到痛楚时，心中的梅花便落满南山。</p>]]></content>
      
      <categories>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>int main还是void main</title>
      <link href="/2017/11/05/int-main%E8%BF%98%E6%98%AFvoid-main/"/>
      <url>/2017/11/05/int-main%E8%BF%98%E6%98%AFvoid-main/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>从高一接触C语言开始到现在6年了，只是不停的重复学习基础的考试程序，从来<br>没有做过一个项目，所有的程序就是一个主函数main和几个被调函数组成。就连<br>主函数都没加过参数，因为坑爹的教科书也不写。<br> <a id="more"></a><br>直到大二学习C++才知道原来main前面有参数int,void等,然而我却一直写的是<br>void main，再次吐槽教科书坑爹啊，现在才知道int main才是标准的写法。<br>于是记录下来我搜集研究的东西。</p><h3 id="深入研究"><a href="#深入研究" class="headerlink" title="深入研究"></a>深入研究</h3><p>main函数，又称主函数,作为绝大多数C程序的唯一入口,是要求有返回值的，返回<br>给系统才能表明程序的执行状况。返回0表示正常执行成功。返回非0表示异常结束。<br>因此返回值的类型是int整型。于是有了int main是规范的写法,如果使用void main<br>没有返回值，那么操作系统不能判断程序状态，对于c程序构成的大型项目来说是致命的。<br>很多IDE在判断程序为int main时都会默认添加一句return 0;</p><h3 id="深入一点"><a href="#深入一点" class="headerlink" title="深入一点"></a>深入一点</h3><p>在最新的C99标准中只有以下两种方式是正确的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>void和int表明声明不同的主函数返回值，不声明默认返回为int整型。</li><li>int main可移植性强。</li><li>C语言不要声明为void main,最好声明为int main。</li><li>就算是测试小程序，也要摒弃使用void main的习惯，这不是单片机！</li></ol>]]></content>
      
      <categories>
          
          <category> 研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>本地项目与远程git仓库连接</title>
      <link href="/2017/11/04/%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%BF%9C%E7%A8%8Bgit%E4%BB%93%E5%BA%93%E8%BF%9E%E6%8E%A5/"/>
      <url>/2017/11/04/%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8E%E8%BF%9C%E7%A8%8Bgit%E4%BB%93%E5%BA%93%E8%BF%9E%E6%8E%A5/</url>
      <content type="html"><![CDATA[<ol><li>打开项目文件夹,输git init新建仓库,创建完会有一个.git文件夹   </li><li>添加所有文件 git add .</li><li>提交到本地仓库 git commit -m -a “备注信息”</li><li>在远程仓库的项目下复制SSH</li><li>本地仓库输入 git remote add origin (远程仓库的ssh) 连接远程仓库</li><li>将本地项目推送到远程仓库 git push -u origin master</li></ol><p>ps. 如果弹出bug，多半是本地没有README.md pull下来就行了。</p>]]></content>
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitbash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gitbash配置及连接github</title>
      <link href="/2017/11/02/gitbash%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/11/02/gitbash%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="Git有什么用"><a href="#Git有什么用" class="headerlink" title="Git有什么用?"></a>Git有什么用?</h3><p>为什么要搭建Git环境? </p><blockquote><p>-因为要把本地文件提交到远程仓库(gitbash,码云等)   </p></blockquote><p>版本库有什么用?</p><blockquote><p>-类似一个目录，每个文件的修改，删除都能够记录，并且在以后以还原。</p></blockquote><a id="more"></a><h3 id="搭建Git环境"><a href="#搭建Git环境" class="headerlink" title="搭建Git环境"></a>搭建Git环境</h3><p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或大或小的项目。</p><h4 id="下载Git安装包"><a href="#下载Git安装包" class="headerlink" title="下载Git安装包"></a>下载Git安装包</h4><p>在Git官网：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a> 下载安装包 Git-2.15.0-64-bit.exe<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/download_git.png" alt=""><br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/download_git_1.png" alt="">  </p><h4 id="测试安装正确"><a href="#测试安装正确" class="headerlink" title="测试安装正确"></a>测试安装正确</h4><p>桌面右键，打开 Git Bush Here，输入 git –version，出现版本号则说明 Git 环境配置成功，第二步完成！！！<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/git_version.png" alt="">  </p><h4 id="配置本机的Git"><a href="#配置本机的Git" class="headerlink" title="配置本机的Git"></a>配置本机的Git</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;你的名字&quot;</span><br><span class="line">$ git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><h4 id="生成密匙"><a href="#生成密匙" class="headerlink" title="生成密匙"></a>生成密匙</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;邮箱同上&quot;</span><br></pre></td></tr></table></figure><h4 id="复制密匙"><a href="#复制密匙" class="headerlink" title="复制密匙"></a>复制密匙</h4><p>在ｃ盘用户.ssh文件下用文本编辑器打开id_rsa.pub并复制文件的内容。<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/git_key.png" alt=""></p><h4 id="GitHub注册和配置"><a href="#GitHub注册和配置" class="headerlink" title="GitHub注册和配置"></a>GitHub注册和配置</h4><p>GitHub 是一个代码托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。<br>Github注册：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/github.png" alt=""></p><h4 id="提交公匙"><a href="#提交公匙" class="headerlink" title="提交公匙"></a>提交公匙</h4><p>点击用户下Settings的SSH and GPG keys下New SSH key添加之前的密匙复制进内容就可以了。<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/git_key_commit.png" alt=""></p><h3 id="连接完成测试"><a href="#连接完成测试" class="headerlink" title="连接完成测试"></a>连接完成测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ssh git@github.com</span><br></pre></td></tr></table></figure><p>输入代码如果不报错就说明配置完成!</p><p>Git使用教程可搜索廖雪峰教程！<br>廖雪峰:<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p>]]></content>
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitbash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java开发环境的搭建</title>
      <link href="/2017/11/01/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2017/11/01/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h3 id="一、安装JDK"><a href="#一、安装JDK" class="headerlink" title="一、安装JDK"></a>一、安装JDK</h3><p>下载地址:<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a><br>根据自己的平台下载适合的JDK版本<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/jdk.png" alt=""><br>大部分时候是无需选择Public JRE，因为Devepment Tools为JDK的核心。已经包含了<br>运行Java程序的JRE。<br><a id="more"></a></p><h3 id="二、设置PATH环境变量"><a href="#二、设置PATH环境变量" class="headerlink" title="二、设置PATH环境变量"></a>二、设置PATH环境变量</h3><p>对于Java程序开发而言，主要使用两个JDK的命令:javac.exe和java.exe。<br>因为这些命令不是windows自己的命令，所以要使用就得进行路径配置。<br>win10系统:  </p><ol><li>右键”计算机”-&gt;”高级系统设置”-&gt;”高级”-&gt;”环境变量”</li><li>新建-&gt;变量名”JAVA_HOME”，变量值”C:\Java\jdk1.8.0_05”（即JDK的安装路径） </li><li>编辑-&gt;变量名”Path”，在原变量值的最后面加上“;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin” </li><li><code>新建-&gt;变量名&quot;CLASSPATH&quot;,变量值&quot;.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar&quot;</code></li><li>变量可以添加在用户变量里，也可以添加在系统变量中(后者全用户都可以用)。<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/hjbl.png" alt=""><h3 id="三、确认环境是否正确"><a href="#三、确认环境是否正确" class="headerlink" title="三、确认环境是否正确"></a>三、确认环境是否正确</h3>在控制台分别输入java,javac,java -version命令，出现如下信息说明成功<br>java命令:<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/java.png" alt=""><br>javac命令:<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/javac.png" alt=""><br>java -version命令:<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/java_version.png" alt="">  <h3 id="四、在控制器写下一个java程序"><a href="#四、在控制器写下一个java程序" class="headerlink" title="四、在控制器写下一个java程序"></a>四、在控制器写下一个java程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;    </span><br><span class="line">    System.out.println(&quot;Hello Java&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>用记事本写好保存,文件名为Test，将后缀改为.java。<br>首先使用 javac Test.java编译文件<br>再使用java Test运行程序<br>打印结果为”hello Java”<br>至此恭喜你Java环境配置完成，当然你也可以使用一些IDE例如:eclipse，就可以<br>不用配置环境也可以编程。</p><p>ps:JRE和JDK不能再同一级目录，否则环境变量会出错。。。本人在此就踩坑了。JRE可以和JDK各自<br>存放在一个文件夹，也可以放在另一个子文件夹，但切不可放在同一个文件夹！！不过最好不用选择<br>Public JRE直接配置就Ok了！</p>]]></content>
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js文件应该放置于何处</title>
      <link href="/2017/10/29/js%E8%84%9A%E6%9C%AC%E4%BD%8D%E7%BD%AE/"/>
      <url>/2017/10/29/js%E8%84%9A%E6%9C%AC%E4%BD%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h2 id="如何使用js代码"><a href="#如何使用js代码" class="headerlink" title="如何使用js代码"></a>如何使用js代码</h2><p>一般来说使用js代码可以通过两种方式<br>    1.通过外部js文件引入<br>    2.html页面上直接写入脚本</p><h2 id="在哪里放置js代码"><a href="#在哪里放置js代码" class="headerlink" title="在哪里放置js代码"></a>在哪里放置js代码</h2><p>通常情况下，js代码是和html代码一起使用，可以将js代码放入html文档中的任何地方。<br>但是放置的地方会对js的正常执行产生不同的反应和影响。具体如下。<br><a id="more"></a></p><h3 id="放置于head之间"><a href="#放置于head之间" class="headerlink" title="放置于head之间"></a>放置于head之间</h3><p>将js代码放置于html文档的head之间是比较常见的做法。因为html文档是由浏览器从上至下<br>依次载入。这样即可确保脚本是在内容加载之前载入。<br>代码如下:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        ....</span></span><br><span class="line"><span class="undefined">        javaScript代码</span></span><br><span class="line"><span class="undefined">        ....</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        .... </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="放置于body之间"><a href="#放置于body之间" class="headerlink" title="放置于body之间"></a>放置于body之间</h3><p>也有部分情况下，需将js代码放于body之间，例如当js代码需要操作一个元素，而html文档<br>是从上往下依次载入，所以此时元素未加载，便会报错。所以这种情况下，我们需将js的代码<br>放在元素的后面，待元素加载完毕时，才使用js代码。代码如下。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        ....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">           document.getElementById('div1').innerHTML = "test";</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="放置于body后面"><a href="#放置于body后面" class="headerlink" title="放置于body后面"></a>放置于body后面</h3><p>js代码放在body之后有一个好处就是可以dom的生成就不会因为长时间执行script脚本而延迟阻塞，<br>从而加快了页面的加载速度。但是又不能将所有的script放在body之后，因为有一些页面的效果的<br>实现，是需要预先动态的加载一些js脚本。所以需依情况而定。代码如下。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        ....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        .... </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">                ....</span></span><br><span class="line"><span class="undefined">                javaScript 代码</span></span><br><span class="line"><span class="undefined">                ....</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="放置于html之外"><a href="#放置于html之外" class="headerlink" title="放置于html之外"></a>放置于html之外</h3><p>虽然js代码可以放置在html之外。但通常情况下，我们不建议将javascript的代码写到html之外。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        ....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        .... </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        ....</span></span><br><span class="line"><span class="undefined">        javaScript 代码  </span></span><br><span class="line"><span class="undefined">        ....</span></span><br><span class="line"><span class="undefined"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="放置于head-body之间"><a href="#放置于head-body之间" class="headerlink" title="放置于head body之间"></a>放置于head body之间</h3><p>一般来说“页面效果实现类的js应该放在body之前”而“动作，交互，事件驱动，需要访问dom属性的js都可以放在body之后”。<br>这样就既不会导致网页加载时间过长，也不会出现dom元素未加载，所以这种放置的方法还算比较科学。不过还是得依情况而定。<br>具体代码如下。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        ....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">         ....</span></span><br><span class="line"><span class="undefined">         javaScript 代码  </span></span><br><span class="line"><span class="undefined">         .....</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        .... </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>当你的js文件代码引用了其他jquery文件时，一定要将被引用的文件放在你的代码或者文件之前,否则会报错！<br>例如:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jq文件"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"你的文件"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    你的js代码中有引用jq的代码时，jq的文件必须在你的文件之前加载</span></span><br><span class="line"><span class="undefined">    否则提示不能找到！！！</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我个人喜欢将js的代码写入body之后，为了速度快。当然还是得依情况而定。</p>]]></content>
      
      <categories>
          
          <category> 研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>markdown使用github添加图片</title>
      <link href="/2017/10/25/markdown%E4%BD%BF%E7%94%A8github%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/"/>
      <url>/2017/10/25/markdown%E4%BD%BF%E7%94%A8github%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<h3 id="github-markdown-readme-md-添加图片"><a href="#github-markdown-readme-md-添加图片" class="headerlink" title="github markdown(readme.md)添加图片"></a>github markdown(readme.md)添加图片</h3><p><strong>步骤:</strong><br>1.将图片上传至github仓库中(先建立一个项目,专门用来存放图片)<br>2.复制图片在github的地址<br>例如:<br><a href="https://github.com/yuhongjing/img-folder/blob/master/img/%5BGIRAP3%40T9%7DVCXDPO9Y522F.png" target="_blank" rel="noopener">https://github.com/yuhongjing/img-folder/blob/master/img/%5BGIRAP3%40T9%7DVCXDPO9Y522F.png</a><br><a id="more"></a><br>3.注意将地址中的blob改为raw(github解析图片的方式，否则不显示图片)<br>例如:<a href="https://github.com/yuhongjing/img-folder/raw/master/img/%5BGIRAP3%40T9%7DVCXDPO9Y522F.png" target="_blank" rel="noopener">https://github.com/yuhongjing/img-folder/raw/master/img/%5BGIRAP3%40T9%7DVCXDPO9Y522F.png</a><br>4.在readme.md中输入! [] (图片地址)    —中间没有空格     </p><p>试试效果吧!</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BAT fighting</title>
      <link href="/2017/10/24/BAT-fighting/"/>
      <url>/2017/10/24/BAT-fighting/</url>
      <content type="html"><![CDATA[<h1 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h1><p><strong>hexo搭建的博客第一篇文章</strong>  </p><h2 id="以此明志"><a href="#以此明志" class="headerlink" title="以此明志   "></a><strong>以此明志 </strong>  </h2><blockquote><p>坚持努力到明年今日进入自己的梦想的公司(BAT)fighting!!!  </p><blockquote><p>为此定几个小目标  </p></blockquote></blockquote><pre><code>time:2017-10-24(程序员节)   </code></pre><p>1.熟练几门前端语言(html5+javascript+css3)<br>2.熟练几门后台语言(php7+python5)<br>3.熟练几门框架(vue.js+bootstrap3+Thinkphp5+laravel5.4)<br>4.数据库设计(mysql)<br><a id="more"></a><br>5.看《数据结构及算法分析第二版》《剑指offer》《编码:隐匿在计算机软硬件背后的语言》<br>《深入理解计算机系统》<br>6.了解(Jquery,sass,微信,Go语言,Java,C++,.net)<br>7.有多的时间就看看TCP/IP还有操作系统的死锁，银行家算法，哲学家思想什么的<br>8.嗯哼。。。。就这样吧！！加油吧!!<br><img src="https://github.com/yuhongjing/img-folder/raw/master/img/%5BGIRAP3@T9%7DVCXDPO9Y522F.png" alt="image"></p>]]></content>
      
      <categories>
          
          <category> 鸡汤 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
